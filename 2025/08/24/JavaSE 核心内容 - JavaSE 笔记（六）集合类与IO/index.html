

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="itbaima">
  <meta name="keywords" content="">
  
    <meta name="description" content="集合类与IO前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。 集合类集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。  集合类其实就是为了更好地组织、管理和操作我们的数据而">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO">
<meta property="og:url" content="http://me.broccoli.me/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8EIO/index.html">
<meta property="og:site_name" content="Broccoli">
<meta property="og:description" content="集合类与IO前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。 集合类集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。  集合类其实就是为了更好地组织、管理和操作我们的数据而">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/01/v3uzfnhamXV5St8.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/01/paeKLsGntNVfHPT.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/01/5HdFh74wlqbMoj6.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/8KS5jbTv7LoAVOs.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/HxjfipVB9TlEbz5.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/4ShtiO6kdIcwZ85.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/KejcFB8TChE5z4o.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/C3xNDTEWGaPLfO6.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/sCMgv9rl5b743BE.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/veHxlUkKyVYErgm.png">
<meta property="og:image" content="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/gn8i3teclAKbhQS.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/in8IX3QkwtsLgWN.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/02/92woGL5MiBsTcKe.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/bmEP9fgCS1Ksaqw.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/G5SZgKxvUJyPABD.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/9dSheG4xqFoXB5i.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/y5AoUG1iuWzhOSj.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/OekDqMlpVbxImsK.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/TpczL2Zi1OkaHWI.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/3VwDQzRxUTGrOZb.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/QSxqJLwiNM1nZlO.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/i2x6m3hzFC5GIAd.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/DNXqwk3UOPnMmlc.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/QHkWZsFvzASpxqL.png">
<meta property="og:image" content="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/A2rXocbU9StlDOC.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/E7GnIVjPAwf8Fol.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/2oJXBui5aD8q1Gh.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/22/vC7VGpdl268LWAk.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/22/o4xXJcsAh7DUinL.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/FP5z3X8SEMkGYtT.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/5BHq1u9JU3bhdI6.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/YytpnaFwL5XACiM.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/ol4TyBChMN6R1ut.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/09/nLO1SorCPdhWefH.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/09/A16JM4doHsXKtEv.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/03/r4AtmVRZ51y7uxd.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/QRBxXyA9OlC7sFf.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/7oh9XCp5cK6vJlL.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/RxgFLaSyft8Il6B.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/1reHCPgmLAMs7cX.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/09/An9adO416pRmLEc.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/Q8JGeMprkgHsnPY.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/13h7yTekm2FfnRw.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/08/1YIRTzM3nWwL8xK.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/S8O61JP2lqKTzjd.png">
<meta property="og:image" content="https://s2.loli.net/2022/10/04/w8RKJxLm6Ik5usn.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/9jLtir2Shd7DWPu.png">
<meta property="og:image" content="https://s2.loli.net/2025/07/07/14cyC8xMJeB5qYL.png">
<meta property="article:published_time" content="2025-08-24T09:42:09.765Z">
<meta property="article:modified_time" content="2025-08-24T09:44:45.794Z">
<meta property="article:author" content="Junxiang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="程序设计">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png">
  
  
  
  <title>JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO - Broccoli</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_5000870_yrj6w1sq7w.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"me.broccoli.me","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Broccoli</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        itbaima
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-24 17:42" pubdate>
          2025年8月24日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          245 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO</h1>
            
            
              <div class="markdown-body">
                
                <p><img src="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png" srcset="/img/loading.gif" lazyload alt="image-20221004131436371"></p>
<h1 id="集合类与IO"><a href="#集合类与IO" class="headerlink" title="集合类与IO"></a>集合类与IO</h1><p>前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。</p>
<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。</p>
<p><img src="https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png" srcset="/img/loading.gif" lazyload alt="image-20220930233059528"></p>
<p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。</p>
<p>集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：</p>
<ol>
<li>它们都是容器，都能够容纳一组元素。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>数组的大小是固定的，集合的大小是可变的。</li>
<li>数组可以存放基本数据类型，但集合只能存放对象。</li>
<li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li>
</ol>
<h3 id="集合根接口"><a href="#集合根接口" class="headerlink" title="集合根接口"></a>集合根接口</h3><p>Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;   <span class="hljs-comment">//集合类基本都是在java.util包下定义的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;树脂666&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：</p>
<p><img src="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png" srcset="/img/loading.gif" lazyload alt="image-20250708234355615"></p>
<p>这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//-------这些是查询相关的操作----------</span><br><br>   	<span class="hljs-comment">//获取当前集合中的元素数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看当前集合是否为空</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查询当前集合中是否包含某个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//返回当前集合的迭代器，我们会在后面介绍</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将集合转换为数组的形式</span><br>    Object[] toArray();<br><br>    <span class="hljs-comment">//支持泛型的数组转换，同上</span><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//-------这些是修改相关的操作----------</span><br><br>    <span class="hljs-comment">//向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求，</span><br>  	<span class="hljs-comment">//这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//从集合中移除某个元素，同样的，移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">//-------这些是批量执行的操作----------</span><br><br>    <span class="hljs-comment">//查询当前集合是否包含给定集合中所有的元素</span><br>  	<span class="hljs-comment">//从数学角度来说，就是看给定集合是不是当前集合的子集</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//添加给定集合中所有的元素</span><br>  	<span class="hljs-comment">//从数学角度来说，就是将当前集合变成当前集合与给定集合的并集</span><br>  	<span class="hljs-comment">//添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-comment">//移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素</span><br>  	<span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的差集</span><br>  	<span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//Java8新增方法，根据给定的Predicate条件进行元素移除操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();   <span class="hljs-comment">//这里用到了迭代器，我们会在后面进行介绍</span><br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">//只保留当前集合中在给定集合中出现的元素，其他元素一律移除</span><br>  	<span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的交集</span><br>  	<span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//清空整个集合，删除所有元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">//-------这些是比较以及哈希计算相关的操作----------</span><br><br>    <span class="hljs-comment">//判断两个集合是否相等</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//计算当前整个集合对象的哈希值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的流，我们会在后面进行讲解</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的并行流，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。</p>
<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。</p>
<p><img src="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png" srcset="/img/loading.gif" lazyload alt="image-20250708234355615"></p>
<p>List是集合类型的一个分支，它的主要特性有：</p>
<ul>
<li>是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置</li>
<li>列表中允许存在重复元素</li>
</ul>
<p>在List接口中，定义了列表类型需要支持的全部操作，List继承自SequencedCollection接口，此接口是Java 21新增接口，此前List接口直接继承自Collection接口（老版图片放在迭代器部分）此接口额外定义了获取第一个元素、最后一个元素，生成反向集合视图等功能，统一了所有有序集合的操作定义，这些内容我们会放在后面进行介绍。</p>
<p>可以看到在List接口中，很多地方重新定义了一次Collection和SequencedCollection接口中定义的方法，虽然没有任何修改，但是这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//List是一个有序的集合类，每个元素都有一个自己的下标位置</span><br><span class="hljs-comment">//List中可插入重复元素</span><br><span class="hljs-comment">//针对于这些特性，扩展了Collection接口中一些额外的操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    ...<br>   	<br>    <span class="hljs-comment">//将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span>;<br><br>    ...<br><br>   	<span class="hljs-comment">//Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123;<br>        Objects.requireNonNull(operator);<br>        <span class="hljs-keyword">final</span> ListIterator&lt;E&gt; li = <span class="hljs-built_in">this</span>.listIterator();  <span class="hljs-comment">//这里同样用到了迭代器</span><br>        <span class="hljs-keyword">while</span> (li.hasNext()) &#123;<br>            li.set(operator.apply(li.next()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123;<br>        Object[] a = <span class="hljs-built_in">this</span>.toArray();<br>        Arrays.sort(a, (Comparator) c);<br>        ListIterator&lt;E&gt; i = <span class="hljs-built_in">this</span>.listIterator();<br>        <span class="hljs-keyword">for</span> (Object e : a) &#123;<br>            i.next();<br>            i.set((E) e);<br>        &#125;<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-comment">//-------- 这些是List中独特的位置直接访问操作 --------</span><br><br>   	<span class="hljs-comment">//获取对应下标位置上的元素</span><br>    E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    <span class="hljs-comment">//直接将对应位置上的元素替换为给定元素</span><br>    E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    <span class="hljs-comment">//在指定位置上插入元素，就跟我们之前的顺序表插入是一样的</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    <span class="hljs-comment">//移除指定位置上的元素</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List中独特的搜索操作 -------</span><br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的第一次出现的下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的最后一次出现的下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List的专用迭代器 -------</span><br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    <span class="hljs-comment">//------- 这些是List的特殊转换 -------</span><br><br>    <span class="hljs-comment">//返回当前集合在指定范围内的子集</span><br>    List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span>;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多（如果需要学习老版本请观看22年旧版JavaSE视频课程）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br>		<br>    <span class="hljs-comment">//默认的数组容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    ...<br><br>    <span class="hljs-comment">//存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br><br>    <span class="hljs-comment">//记录当前数组元素数的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>   	<span class="hljs-comment">//这是ArrayList的其中一个构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];   <span class="hljs-comment">//根据初始化大小，创建当前列表</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//这是ArrayList的无参构造方法</span><br>  	<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br>  <br>  	...<br>      <br>   	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        modCount++;   <span class="hljs-comment">//用于后期判断是否出现并发异常，比如遍历时修改或是多线程操作（暂时忽略）</span><br>        add(e, elementData, size);  <span class="hljs-comment">//调用内部私有辅助方法实现插入操作，因为是尾插，index直接写size就行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//直接返回真插入成功</span><br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == elementData.length)   <span class="hljs-comment">//首先判断长度是否超出当前内部数组容量</span><br>            elementData = grow();   <span class="hljs-comment">//超出那么就得扩容，扩容会对类的elementData进行重新赋值，下面介绍</span><br>        elementData[s] = e;   <span class="hljs-comment">//接着正常插入元素即可</span><br>        size = s + <span class="hljs-number">1</span>;  <span class="hljs-comment">//让size自增</span><br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);   <span class="hljs-comment">//先判断插入位置是否超出范围</span><br>        modCount++;   <span class="hljs-comment">//同上</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> s;<br>        Object[] elementData;<br>      	<span class="hljs-comment">//看着有点绕，但实际上就是让s等于size，elementData等于类的elementData</span><br>        <span class="hljs-comment">//然后再比较长度是否已经一样，一样就扩容，跟上面思路是差不多的</span><br>        <span class="hljs-keyword">if</span> ((s = size) == (elementData = <span class="hljs-built_in">this</span>.elementData).length)<br>            elementData = grow();<br>        System.arraycopy(elementData, index,<br>                         elementData, index + <span class="hljs-number">1</span>,<br>                         s - index);  <span class="hljs-comment">//因为是中间插入，这里调用C++实现的数组移动操作，把位置让出来</span><br>        elementData[index] = element;  <span class="hljs-comment">//位置让出来之后，设置新元素</span><br>        size = s + <span class="hljs-number">1</span>;  <span class="hljs-comment">//让size自增</span><br>    &#125;<br>  	<br>  	...<br>  <br>    <span class="hljs-keyword">private</span> Object[] grow() &#123;<br>        <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);   <span class="hljs-comment">//调用内部其他方法实现，并制定扩容最小值为当前容量+1</span><br>    &#125;<br>  <br>  	<span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-type">int</span> minCapacity) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;   <span class="hljs-comment">//首先保存下现在的容量</span><br>        <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-comment">//判断当前容量是否不为0（因为初始就是0，不为0一定被扩容过）</span><br>            <span class="hljs-comment">//然后计算新的容量，这里传入当前长度、最小扩容长度和推荐扩容长度三个参数，通过辅助方法衡量该如何扩容</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> ArraysSupport.newLength(oldCapacity,<br>                    minCapacity - oldCapacity, <span class="hljs-comment">/* 最小扩容长度 */</span><br>                    oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* 推荐扩容长度 */</span>);<br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> Arrays.copyOf(elementData, newCapacity);  <span class="hljs-comment">//得到最终扩容大小，创建新数组</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//这里相当于现在容量为0，也就是初始状态，此时会直接创建一个容量为10的新数组</span><br>            <span class="hljs-comment">//注意这里需要取minCapacity和默认容量的最大值，因为grow不仅仅在单个插入时会调用，批量插入的时候也会调用，有可能出现批量插入20个的情况，那么初始容量就装不下了</span><br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中具体的ArrayList扩容辅助类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认的列表最大长度为Integer.MAX_VALUE - 8</span><br>  <span class="hljs-comment">//因为在部分JVM的C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长度</span><br>  <span class="hljs-comment">//所以这个8（保守估计，不一定是）就是存了数组_length字段（这个只做了解就行）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newLength</span><span class="hljs-params">(<span class="hljs-type">int</span> oldLength, <span class="hljs-type">int</span> minGrowth, <span class="hljs-type">int</span> prefGrowth)</span> &#123;<br>      <span class="hljs-comment">//计算新的长度，因为minGrowth和prefGrowth谁更大不确定，需要进行比较，然后得到新的长度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">prefLength</span> <span class="hljs-operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);<br>      <span class="hljs-comment">//接着比较新的长度是否已经超出数组允许的最大长度了</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;<br>          <span class="hljs-keyword">return</span> prefLength;  <span class="hljs-comment">//没有直接返回</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果超出最大长度，需要进一步处理</span><br>          <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth);<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeLength</span><span class="hljs-params">(<span class="hljs-type">int</span> oldLength, <span class="hljs-type">int</span> minGrowth)</span> &#123;<br>      <span class="hljs-comment">//先看看现在需要的最小长度，因为走到这里有可能是因为prefLength过长，但并不代表就真的需要这么长，因为prefLength有可能加的是prefGrowth，不一定是最小值</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> oldLength + minGrowth;  <br>      <span class="hljs-keyword">if</span> (minLength &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果加出来最小长度已经小于0了，那包是超过int最大值了（前面二进制章节有介绍为什么）</span><br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>(   <span class="hljs-comment">//直接无情抛异常</span><br>              <span class="hljs-string">&quot;Required array length &quot;</span> + oldLength + <span class="hljs-string">&quot; + &quot;</span> + minGrowth + <span class="hljs-string">&quot; is too large&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;  <span class="hljs-comment">//如果在最大长度允许范围内</span><br>          <span class="hljs-keyword">return</span> SOFT_MAX_ARRAY_LENGTH;   <span class="hljs-comment">//直接给最大的</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> minLength;  <br>          <span class="hljs-comment">//这种情况相当于在SOFT_MAX_ARRAY_LENGTH和int最大值之间，没法了，只能直接返回</span><br>          <span class="hljs-comment">//虽然有些JVM会可能直接抛出异常，但是可以抱着试试的心态搞一下</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>所以Java为我们提供的ArrayList，默认情况下内部就是一个空的数组，需要使用时候会变成初始值10（或初始批量插入的长度）后续在单个插入时，如果容量不够，会自动按照1.5倍进行扩容，直到最大限制。如果是后续批量插入，则根据情况而定。</p>
<p>一般的，如果我们要使用一个集合类，我们会使用接口的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();   <span class="hljs-comment">//使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类</span><br>    list.add(<span class="hljs-string">&quot;科技与狠活&quot;</span>);   <span class="hljs-comment">//使用add添加元素</span><br>  	list.add(<span class="hljs-string">&quot;上头啊&quot;</span>);<br>    System.out.println(list);   <span class="hljs-comment">//打印集合类，可以得到一个非常规范的结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的：</p>
<p><img src="https://s2.loli.net/2022/10/01/v3uzfnhamXV5St8.png" srcset="/img/loading.gif" lazyload alt="image-20221001002151164"></p>
<p>集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//添加Integer的值10</span><br>    list.remove((Integer) <span class="hljs-number">10</span>);   <span class="hljs-comment">//注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象</span><br>    System.out.println(list);   <span class="hljs-comment">//可以看到，此时元素成功被移除</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那要是这样写呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">//添加的是一个对象</span><br>    list.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">//删除的是另一个对象</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用<code>equals</code>方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用<code>equals</code>方法相等，那么集合中就是相同的两个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ArrayList源码部分</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;   <span class="hljs-comment">//这里只是对两个对象进行equals判断</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//只要判断成功，直接认为就是要删除的对象，删除就完事</span><br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>列表中允许存在相同元素，所以说我们可以添加两个一模一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哟唉嘛干你&quot;</span>;<br>    list.add(str);<br>    list.add(str);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/01/paeKLsGntNVfHPT.png" srcset="/img/loading.gif" lazyload alt="image-20221001231509926"></p>
<p>那要是此时我们删除对象呢，是一起删除还是只删除一个呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哟唉嘛干你&quot;</span>;<br>    list.add(str);<br>    list.add(str);<br>    list.remove(str);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/01/5HdFh74wlqbMoj6.png" srcset="/img/loading.gif" lazyload alt="image-20221001231619391"></p>
<p>可以看到，这种情况下，只会删除排在前面的第一个元素。</p>
<p>集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());   <span class="hljs-comment">//集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的</span><br>    System.out.println(list.get(<span class="hljs-number">0</span>).isEmpty());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Arrays工具类中，我们可以快速生成一个只读的List：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);   <span class="hljs-comment">//非常方便</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，也可以利用类中的代码块实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;   <span class="hljs-comment">//使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以）</span><br>            add(<span class="hljs-string">&quot;A&quot;</span>);<br>            add(<span class="hljs-string">&quot;B&quot;</span>);<br>            add(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;&#125;;<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//引用首结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">//引用尾结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//构造方法，很简单，直接创建就行了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>  <br>  	...<br>      <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;   <span class="hljs-comment">//内部使用的结点类</span><br>        E item;<br>        Node&lt;E&gt; next;   <span class="hljs-comment">//不仅保存指向下一个结点的引用，还保存指向上一个结点的引用</span><br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        linkLast(e);   <span class="hljs-comment">//调用内部方法进行尾部连接</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>  	<span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;   <span class="hljs-comment">//拿到当前尾结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);  <span class="hljs-comment">//创建新结点</span><br>        last = newNode;   <span class="hljs-comment">//更新尾结点</span><br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)  <br>            first = newNode;  <span class="hljs-comment">//如果当前尾结点为空说明是个空集合，将此结点同时作为首结点</span><br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;  <span class="hljs-comment">//否则更新当前尾结点的next引用，把新的结点串起来</span><br>        size++;   <span class="hljs-comment">//让size自增</span><br>        modCount++;<br>    &#125;<br>  <br>    E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;  <span class="hljs-comment">//拿到当前的待删除结点元素</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;   <span class="hljs-comment">//拿到前后结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            first = next;   <span class="hljs-comment">//如果前驱结点为空，说明这个结点就是就是第一个，直接让first等于next就行了</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = next;  <span class="hljs-comment">//否则让前驱结点直接去连接下一个</span><br>            x.prev = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//取消当前结点对于前驱结点的引用，便于JVM自动垃圾回收</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//同上，处于后驱结点，操作差不多</span><br>            last = prev;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.prev = prev;<br>            x.next = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        x.item = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//前后处理干净，然后把待删除结点对于元素的引用取消，彻底废弃掉此结点</span><br>        size--;   <span class="hljs-comment">//让size自减</span><br>        modCount++;<br>        <span class="hljs-keyword">return</span> element;  <span class="hljs-comment">//返回被删元素</span><br>    &#125;<br>  <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。</p>
<ul>
<li><strong>ArrayList：</strong> 更适合随机访问，因为可以直接读取某个下标的元素。插入则性能较差，因为需要移动一组元素，让出空间。</li>
<li><strong>LinkedList：</strong> 不适合随机访问，因为无法直接获取某个元素，只能遍历查找。插入性能较好，因为可以直接改变链表中结点的指向。</li>
</ul>
<p>如果更多的是对数据进行插入，选择LinkedList，如果更多是对于数据的查询，选择ArrayList。</p>
<p>只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们接着来介绍迭代器，实际上我们的集合类都是支持使用<code>foreach</code>语法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;   <span class="hljs-comment">//集合类同样支持这种语法</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是由于仅仅是语法糖，实际上编译之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> list.iterator();   <span class="hljs-comment">//这里使用的是List的迭代器在进行遍历操作</span><br><br>    <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var2.next();<br>        System.out.println(s);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么这个迭代器是一个什么东西呢？我们来研究一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>  	<span class="hljs-comment">//通过调用iterator方法快速获取当前集合的迭代器</span><br>  	<span class="hljs-comment">//Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现</span><br>    Iterator&lt;String&gt; iterator = list.iterator();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：</p>
<p><img src="https://s2.loli.net/2022/10/02/8KS5jbTv7LoAVOs.png" srcset="/img/loading.gif" lazyload alt="image-20221002150914323"></p>
<p>一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：</p>
<p><img src="https://s2.loli.net/2022/10/02/HxjfipVB9TlEbz5.png" srcset="/img/loading.gif" lazyload alt="image-20221002151110991"></p>
<p>每一次<code>next</code>操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用<code>next</code>将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。</p>
<p>我们来看看这个接口的源码定义了哪些操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//看看是否还有下一个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//遍历当前元素，并将下一个元素作为待遍历元素</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//移除上一个被遍历的元素（某些集合不支持这种操作）</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//对剩下的元素进行自定义遍历操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    cursor = i + <span class="hljs-number">1</span>;   <span class="hljs-comment">//移动指针</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];  <span class="hljs-comment">//直接返回指针所指元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>LinkedList就是不断向后寻找结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    next = next.next;   <span class="hljs-comment">//向后继续寻找结点</span><br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;  <span class="hljs-comment">//返回结点内部存放的元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;    <span class="hljs-comment">//每次循环一定要判断是否还有元素剩余</span><br>        System.out.println(iterator.next());  <span class="hljs-comment">//如果有就可以继续获取到下一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用<code>foreach</code>语法来快速遍历集合类，效果是完全一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    list.forEach(System.out::println);<br>    <span class="hljs-comment">//这里有一个常见误区，lambda里面禁止修改外部的非final变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;   <span class="hljs-comment">//foreach语法遍历每一个元素</span><br>        action.accept(t);   <span class="hljs-comment">//调用Consumer的accept来对每一个元素进行消费</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么我们来看一下，Iterable这个接口又是是什么东西？</p>
<p><img src="https://s2.loli.net/2022/10/02/4ShtiO6kdIcwZ85.png" srcset="/img/loading.gif" lazyload alt="image-20221002152713622"></p>
<p>我们来看看定义了哪些内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//生成当前集合的迭代器，在Collection接口中重复定义了一次</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//这个方法会在多线程部分中进行介绍，暂时不做讲解</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用<code>foreach</code>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;String&gt;&#123;   <span class="hljs-comment">//这里我们随便写一个类，让其实现Iterable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;String&gt;() &#123;   <span class="hljs-comment">//生成一个匿名的Iterator对象</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//这里随便写的，直接返回true，这将会导致无限循环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//每次就直接返回一个字符串吧</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;测试&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    <span class="hljs-keyword">for</span> (String s : test) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/02/KejcFB8TChE5z4o.png" srcset="/img/loading.gif" lazyload alt="image-20221002154018319"></p>
<p>是不是感觉集合类的设计非常巧妙？</p>
<p>我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看前面是否有已经遍历的元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//跟next相反，这里是倒着往回遍历</span><br>    E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回下一个待遍历元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回上一个已遍历元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">previousIndex</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将上一个已遍历元素修改为新的元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在遍历过程中，插入新的元素到当前待遍历元素之前</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们来测试一下吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>    ListIterator&lt;String&gt; iterator = list.listIterator();<br>    iterator.next();   <span class="hljs-comment">//此时得到A</span><br>    iterator.set(<span class="hljs-string">&quot;X&quot;</span>);  <span class="hljs-comment">//将A原本位置的上的元素设定为成新的</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/02/C3xNDTEWGaPLfO6.png" srcset="/img/loading.gif" lazyload alt="image-20221002154844743"></p>
<p>这种迭代器因为能够双向遍历，所以说可以反复使用。</p>
<h3 id="Queue和Deque"><a href="#Queue和Deque" class="headerlink" title="Queue和Deque"></a>Queue和Deque</h3><p>通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br></code></pre></td></tr></table></figure>

<p>这个Deque接口是干嘛的呢？我们先来看看它的继承结构：</p>
<p><img src="https://s2.loli.net/2022/10/02/sCMgv9rl5b743BE.png" srcset="/img/loading.gif" lazyload alt="image-20221002162108279"></p>
<p>我们先来看看队列接口，它扩展了大量队列相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插）</span><br>  	<span class="hljs-comment">//如果插入失败，会直接抛出异常</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//同样是添加操作，但是插入失败不会抛出异常</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//移除队首元素，但是如果队列已经为空，那么会抛出异常</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br>   	<span class="hljs-comment">//同样是移除队首元素，但是如果队列为空，会返回null</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常</span><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//同样是仅获取队首元素，但是如果队列为空，会返回null</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以直接将一个LinkedList当做一个队列来使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();   <span class="hljs-comment">//当做队列使用，还是很方便的</span><br>    queue.offer(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    queue.offer(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/02/veHxlUkKyVYErgm.png" srcset="/img/loading.gif" lazyload alt="image-20221002163512442"></p>
<p>我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是：</p>
<p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" srcset="/img/loading.gif" lazyload alt="image-20220725103600318"></p>
<p>普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作：</p>
<p><img src="https://s2.loli.net/2022/10/02/gn8i3teclAKbhQS.png" srcset="/img/loading.gif" lazyload alt="image-20221002164302507"></p>
<p><img src="https://s2.loli.net/2022/10/02/in8IX3QkwtsLgWN.png" srcset="/img/loading.gif" lazyload alt="image-20221002164431746"></p>
<p>利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在双端队列中，所有的操作都有分别对应队首和队尾的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//在队首进行插入操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在队尾进行插入操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span>;<br>		<br>  	<span class="hljs-comment">//不用多说了吧？</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在队首进行移除操作</span><br>    E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//在队尾进行移除操作</span><br>    E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//不用多说了吧？</span><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//获取队首元素</span><br>    E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//获取队尾元素</span><br>    E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>;<br><br>		<span class="hljs-comment">//不用多说了吧？</span><br>    E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//从队列中删除第一个出现的指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//从队列中删除最后一个出现的指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">// *** 队列中继承下来的方法操作是一样的，这里就不列出了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">// *** 栈相关操作已经帮助我们定义好了 ***</span><br><br>    <span class="hljs-comment">//将元素推向栈顶</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//将元素从栈顶出栈</span><br>    E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">// *** 集合类中继承的方法这里也不多种介绍了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">//生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">descendingIterator</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们可以来测试一下，比如我们可以直接当做栈来进行使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    deque.push(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    deque.push(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(deque.pop());<br>    System.out.println(deque.pop());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/02/92woGL5MiBsTcKe.png" srcset="/img/loading.gif" lazyload alt="image-20221002165618791"></p>
<p>可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    deque.addLast(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    deque.addLast(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    <br>    Iterator&lt;String&gt; descendingIterator = deque.descendingIterator();<br>    System.out.println(descendingIterator.next());<br><br>    Iterator&lt;String&gt; iterator = deque.iterator();<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，正向迭代器和反向迭代器的方向是完全相反的。</p>
<p>当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();   <span class="hljs-comment">//数组实现的栈和队列</span><br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();  <span class="hljs-comment">//优先级队列</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/bmEP9fgCS1Ksaqw.png" srcset="/img/loading.gif" lazyload alt="image-20221003210253093"></p>
<p>可以看到，我们的插入顺序虽然是10&#x2F;4&#x2F;5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);   <span class="hljs-comment">//按照从大到小顺序出队</span><br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/G5SZgKxvUJyPABD.png" srcset="/img/loading.gif" lazyload alt="image-20221003210436684"></p>
<p>只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列<strong>只能保证出队顺序是按照优先级</strong>进行的，我们可以打印一下：</p>
<p><img src="https://s2.loli.net/2022/10/03/9dSheG4xqFoXB5i.png" srcset="/img/loading.gif" lazyload alt="image-20221003210545678"></p>
<p>想要了解优先级队列的具体实现原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。</p>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    Object[] toArray();<br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//这个同样是删除指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//同样是只能插入那些不重复的元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//这个方法我们同样会放到多线程中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, Spliterator.DISTINCT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过：</p>
<ul>
<li>不允许出现重复元素</li>
<li>不支持随机访问（不允许通过下标访问）</li>
</ul>
<p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));   <span class="hljs-comment">//这里我们连续插入两个同样的字符串</span><br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set);   <span class="hljs-comment">//可以看到，最后实际上只有一个成功插入了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/y5AoUG1iuWzhOSj.png" srcset="/img/loading.gif" lazyload alt="image-20221003211330129"></p>
<p>在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set.remove(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于底层采用哈希表实现，所以说无法维持插入元素的顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/OekDqMlpVbxImsK.png" srcset="/img/loading.gif" lazyload alt="image-20221003211635759"></p>
<p>那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/TpczL2Zi1OkaHWI.png" srcset="/img/loading.gif" lazyload alt="image-20221003212147700"></p>
<p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/3VwDQzRxUTGrOZb.png" srcset="/img/loading.gif" lazyload alt="image-20221003212233263"></p>
<p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; b - a);  <span class="hljs-comment">//同样是一个Comparator</span><br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p>
<h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p>
<p><img src="https://s2.loli.net/2022/10/03/QSxqJLwiNM1nZlO.jpg" srcset="/img/loading.gif" lazyload alt="39e19f3e-04e8-4c43-8fb5-6d5288a7cdf8"></p>
<p>而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。</p>
<p><img src="https://s2.loli.net/2022/10/03/i2x6m3hzFC5GIAd.png" srcset="/img/loading.gif" lazyload alt="image-20221003213157956"></p>
<p>在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊</span><br><span class="hljs-comment">//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-comment">//-------- 查询相关操作 --------</span><br>  <br>  	<span class="hljs-comment">//获取当前存储的键值对数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的键</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的值</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>;<br><br>    <span class="hljs-comment">//通过给定的键，返回其映射的值</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br><br>    <span class="hljs-comment">//-------- 修改相关操作 --------</span><br><br>    <span class="hljs-comment">//向Map中添加新的映射关系，也就是新的键值对</span><br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br><br>    <span class="hljs-comment">//根据给定的键，移除其映射关系，也就是移除对应的键值对</span><br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span>;<br><br><br>    <span class="hljs-comment">//-------- 批量操作 --------</span><br><br>    <span class="hljs-comment">//将另一个Map中的所有键值对添加到当前Map中</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<br><br>    <span class="hljs-comment">//清空整个Map</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">//-------- 其他视图操作 --------</span><br><br>    <span class="hljs-comment">//返回Map中存放的所有键，以Set形式返回</span><br>    Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回Map中存放的所有值</span><br>    Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回所有的键值对，这里用的是内部类Entry在表示</span><br>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br><br>    <span class="hljs-comment">//这个是内部接口Entry，表示一个键值对</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; &#123;<br>        <span class="hljs-comment">//获取键值对的键</span><br>        K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">//获取键值对的值</span><br>        V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">//修改键值对的值</span><br>        V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>;<br><br>        <span class="hljs-comment">//判断两个键值对是否相等</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>        <span class="hljs-comment">//返回当前键值对的哈希值</span><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。</p>
<p>我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//使用put方法添加键值对，返回值我们会在后面讨论</span><br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小红&quot;</span>);<br>    System.out.println(map.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">//使用get方法根据键获取对应的值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" srcset="/img/loading.gif" lazyload alt="image-20221003214807048"></p>
<p>注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小红&quot;</span>);   <span class="hljs-comment">//这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" srcset="/img/loading.gif" lazyload alt="image-20221003214807048"></p>
<p>为了防止意外将之前的键值对覆盖掉，我们可以使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    map.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小红&quot;</span>);   <span class="hljs-comment">//Java8新增操作，只有在不存在相同键的键值对时才会存放</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有，我们在获取一个不存在的映射时，默认会返回null作为结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//Map中只有键为1的映射</span><br>    System.out.println(map.get(<span class="hljs-number">3</span>));  <span class="hljs-comment">//此时获取键为3的值，那肯定是没有的，所以说返回null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    System.out.println(map.getOrDefault(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;备胎&quot;</span>));   <span class="hljs-comment">//Java8新增操作，当不存在对应的键值对时，返回备选方案</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;牌&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;你能秒我&quot;</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/DNXqwk3UOPnMmlc.png" srcset="/img/loading.gif" lazyload alt="image-20221003220156062"></p>
<p>如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;牌&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;你能秒我&quot;</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/QHkWZsFvzASpxqL.png" srcset="/img/loading.gif" lazyload alt="image-20221003220458539"></p>
<p>实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过链地址法解决这种问题，最后哈希表就长这样了：</p>
<p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" srcset="/img/loading.gif" lazyload alt="image-20220820221104298"></p>
<p>实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是差不多的实现，我们来看看这里面是怎么定义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>  <br>  	...<br>    <br>  	<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;   <span class="hljs-comment">//内部使用结点，实际上就是存放的映射关系</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;   <span class="hljs-comment">//跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键</span><br>        V value;<br>        Node&lt;K,V&gt; next;<br>				...<br>    &#125;<br>  	<br>  	...<br>  <br>  	<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;   <span class="hljs-comment">//这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表）</span><br>  <br>  	<span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;   <span class="hljs-comment">//负载因子，这个东西决定了HashMap的扩容效果</span><br>  <br>  	<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">//当我们创建对象时，会使用默认的负载因子，值为0.75</span><br>    &#125;<br>  <br>  	...     <br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：</p>
<ul>
<li>HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板</li>
<li>HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构</li>
</ul>
<p>我们来研究一下它的put方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>  	<span class="hljs-comment">//这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)  <span class="hljs-comment">//如果底层哈希表没初始化，先初始化</span><br>        n = (tab = resize()).length;   <span class="hljs-comment">//通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方</span><br>  	<span class="hljs-comment">//因为传入的哈希值可能会很大，这里同样是进行取余操作</span><br>  	<span class="hljs-comment">//这里做了个优化 (n - 1) &amp; hash 等价于 hash % n （仅限n为2的幂可以这样做）这里的i就是最终得到的下标位置了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(hash, key, value, <span class="hljs-literal">null</span>);   <span class="hljs-comment">//如果这个位置上什么都没有，那就直接放一个新的结点</span><br>    <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//这种情况就是哈希冲突了</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;   <span class="hljs-comment">//如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作</span><br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))  <span class="hljs-comment">//依然是equals判断</span><br>            e = p;   <span class="hljs-comment">//这里直接将待插入结点等于原本冲突的结点，一会直接覆盖</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)   <span class="hljs-comment">//如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);  <span class="hljs-comment">//在红黑树中插入新的结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;  <span class="hljs-comment">//普通链表就直接在链表尾部插入</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">//e每次都更新为p.next</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);  <span class="hljs-comment">//找到尾部，直接创建新的结点连在后面</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">//如果当前链表的长度已经很长了，达到了阈值</span><br>                        treeifyBin(tab, hash);			<span class="hljs-comment">//那么就转换为红黑树来存放</span><br>                    <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//直接结束</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))  <span class="hljs-comment">//同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所以直接覆盖就行</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;  <span class="hljs-comment">//覆盖原本存储的值</span><br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;   <span class="hljs-comment">//覆盖之后，会返回原本的被覆盖值</span><br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)   <span class="hljs-comment">//键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容</span><br>        resize();   <span class="hljs-comment">//调用resize进行扩容</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">//正常插入键值对返回值为null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    System.out.println(map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>));<br>    System.out.println(map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;慈善家&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/A2rXocbU9StlDOC.png" srcset="/img/loading.gif" lazyload alt="image-20221003224137177"></p>
<p>现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树：</p>
<p><img src="https://s2.loli.net/2022/10/03/E7GnIVjPAwf8Fol.jpg" srcset="/img/loading.gif" lazyload alt="710c1c38-95a8-493d-8645-067b991af908"></p>
<p>但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看<code>resize()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;   <span class="hljs-comment">//先把下面这几个旧的东西保存一下</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;  <span class="hljs-comment">//这些是新的容量和扩容阈值</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//如果旧容量大于0，那么就开始扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">//如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;  <span class="hljs-comment">//这种情况不用扩了</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)   <span class="hljs-comment">//新的容量等于旧容量的2倍，同样不能超过最大值</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//新的阈值也提升到原来的两倍</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;   <span class="hljs-comment">//新的容量直接等于默认容量16</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="hljs-comment">//阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。</span><br>    &#125;<br>    ...<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;   <span class="hljs-comment">//将底层数组变成新的扩容之后的数组</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去</span><br>      	...   <span class="hljs-comment">//详细过程就不介绍了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。</p>
<blockquote>
<p> HashMap初始容量为0，第一次put的时候，会立即进行一次resize，第一次resize会直接生成一个数组作为哈希表，容量为16，阈值为16 * 0.75，当后续插入键值对超过阈值时，会进行第二次resize，第二次resize会将容量和阈值都变为原来的2倍，第三次以此类推。</p>
</blockquote>
<p>而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;   <span class="hljs-comment">//LinkedHashMap中的结点实现</span><br>    Entry&lt;K,V&gt; before, after;   <span class="hljs-comment">//这里多了一个指向前一个结点和后一个结点的引用</span><br>    Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。</p>
<p>当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，只需给予一个比较规则即可，跟之前的TreeSet是一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; b - a);<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;一个六&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;**&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/03/2oJXBui5aD8q1Gh.png" srcset="/img/loading.gif" lazyload alt="image-20221003231135805"></p>
<p>现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;   <span class="hljs-comment">//对，你没看错，底层直接用map来做事</span><br><br>    <span class="hljs-comment">// 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">//直接构造一个默认大小为16负载因子0.75的HashMap</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>		<br>  	...<br>      <br>    <span class="hljs-comment">//你会发现所有的方法全是替身攻击</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.keySet().iterator();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p>
<p>再来看TreeSet，实际上用的就是我们的TreeMap：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-comment">//底层需要一个NavigableMap，就是自动排序的Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><br>    <span class="hljs-comment">//不用我说了吧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    ...<br><br>    <span class="hljs-comment">//直接使用TreeMap解决问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>    &#125;<br>		<br>  	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同理，这里就不多做阐述了。</p>
<p>我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看<code>compute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.compute(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br>        <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>  	map.computeIfPresent(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//当Key存在时存在则计算并赋予新的值</span><br>      <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.computeIfAbsent(<span class="hljs-number">0</span>, (k) -&gt; &#123;   <span class="hljs-comment">//若不存在则计算并插入新的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>merge方法用于处理数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Student&gt; students = Arrays.asList(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">80</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">98</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">95</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">50</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">72</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">41</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">89</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">92</span>)<br>    );<br>    Map&lt;String, Integer&gt; scoreMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  	<span class="hljs-comment">//merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样：</span><br>    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));<br>    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + k + <span class="hljs-string">&quot;总分&quot;</span> + <span class="hljs-string">&quot;value:&quot;</span> + v));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String type, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.type = type;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>replace</code>方法可以快速替换某个映射的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span>);   <span class="hljs-comment">//直接替换为新的</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以精准匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;巴卡&quot;</span>, <span class="hljs-string">&quot;玛卡&quot;</span>);   <span class="hljs-comment">//只有键和值都匹配时，才进行替换</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>包括remove方法，也支持键值同时匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.remove(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);  <span class="hljs-comment">//只有同时匹配时才移除</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是不是感觉学习了Map之后，涨了不少姿势？</p>
<h3 id="比较相关接口"><a href="#比较相关接口" class="headerlink" title="比较相关接口"></a>比较相关接口</h3><p>在前面的学习中，我们发现很多的类中都存在一个<code>compareTo</code>方法，这实际上是因为这个类实现了<code>Comparable</code>接口获得的方法，我们常见的一些JDK提供的类型，如String、基本类型包装类、Date、LocalDate等，其实都实现了此接口，从而自带对于其类型对象之间的比较操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AAA&quot;</span>, s2 = <span class="hljs-string">&quot;BBB&quot;</span>;<br>System.out.println(s1.compareTo(s2));  <span class="hljs-comment">//按字典顺序比较两个字符串,比较基于字符串中每个字符的 Unicode 值。</span><br></code></pre></td></tr></table></figure>

<p>这与我们前面提到过的<code>Comparator</code>类似，当返回值大于0说明前者大于后者，小于0则是后者大于前者，如果等于0则表示这两者相等。但是注意<code>Comparator</code>是用于直接手动创建比较规则，而<code>Comparable</code>则是直接让类自行定义内部比较规则，包括这两者的使用的地方也不一样。</p>
<p>比如我们前面介绍的<code>Arrays</code>工具类，其中就包含<code>sort</code>方法进行排序，我们可以直接传入一个数组让其自动完成排序操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;DDD&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span> &#125;;<br>Arrays.sort(arr);<br>System.out.println(Arrays.toString(arr));<br></code></pre></td></tr></table></figure>

<p>但是注意，我们进行排序的类型必须是一个实现了<code>Comparable</code>接口的类型，否则无法进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Student[] arr = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#125;;<br>    Arrays.sort(arr);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/22/vC7VGpdl268LWAk.png" srcset="/img/loading.gif" lazyload alt="image-20250722143249240"></p>
<p>我们可以为我们自己定义的类实现<code>Comparable</code>接口，实现一个自己的比较操作即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Student[] arr = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">19</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">18</span>) &#125;;<br>    Arrays.sort(arr);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-keyword">return</span> age - o.age;   <span class="hljs-comment">//直接比较年龄</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>               <span class="hljs-string">&quot;age=&quot;</span> + age +<br>               <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上我们之前介绍的<code>TreeSet</code>和<code>TreeMap</code>，在我们不指定任何排序规则的情况下，默认也是采用类中Comparable的实现进行排序的，如果我们直接使用一个为实现<code>Comparable</code>接口的类型，同样会出现报错：</p>
<p><img src="https://s2.loli.net/2025/07/22/o4xXJcsAh7DUinL.png" srcset="/img/loading.gif" lazyload alt="image-20250722145029512"></p>
<p>不过，除了让类本身实现<code>Comparable</code>接口之外，对于一些第三方提供的类型我们无法进行修改的，此时也可以手动指定比较规则，也就是通过传入一个<code>Comparator</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Student&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((s1, s2) -&gt; s1.age - s2.age);  <span class="hljs-comment">//手动指定一个比较规则也可以</span><br>    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">19</span>));<br>    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">18</span>));<br>    System.out.println(set);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的，数组也有类似的<code>sort</code>方法，这里就不列出了。接下来我们就着重介绍一下<code>Comparator</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//我们需要实现的比较方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br><br>    <span class="hljs-comment">//从Object继承下来的方法，这里进行了重新定义，</span><br>    <span class="hljs-comment">//除了比较两个元素相等之外，它还额外要求两个元素compare得到的结果为0</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-comment">//根据当前实现的compare操作，生成一个相反的比较Comparator</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//在原有比较基础上，附加次级比较条件（也就是说如果比较出来两个对象相等，就继续按照次级条件比较得到谁前谁后）</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> compare(c1, c2);<br>            <span class="hljs-keyword">return</span> (res != <span class="hljs-number">0</span>) ? res : other.compare(c1, c2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//上面的进阶版，可以自定义类中属性(作为key)的获取规则，并对此属性进行比较</span><br>    <span class="hljs-keyword">default</span> &lt;U&gt; Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor,</span><br><span class="hljs-params">            Comparator&lt;? <span class="hljs-built_in">super</span> U&gt; keyComparator)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparing(keyExtractor, keyComparator));<br>    &#125;<br><br>    <span class="hljs-comment">//上面的简化版，只有类中属性(作为key)的获取规则，比较规则使用key默认的实现（Key必须是Comparable的实现类）</span><br>    <span class="hljs-keyword">default</span> &lt;U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparing(keyExtractor));<br>    &#125;<br><br>    <span class="hljs-comment">//针对于特定内置类型的提取并比较，同上，后续同理</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">thenComparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-built_in">super</span> T&gt; keyExtractor)</span> &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparingInt(keyExtractor));<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-comment">//------以下是所有的静态方法，可以直接生成一个新的Comparator对象</span><br>      <br>    <span class="hljs-comment">//生成一个指定类型（需要实现Comparable）的反向比较器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">reverseOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder();<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型（需要实现Comparable）的正向比较器</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">naturalOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型的正向比较器，且针对于null值，会优先排到前面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">nullsFirst</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.NullComparator&lt;&gt;(<span class="hljs-literal">true</span>, comparator);<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型的正向比较器，且针对于null值，会直接排到后面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">nullsLast</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.NullComparator&lt;&gt;(<span class="hljs-literal">false</span>, comparator);<br>    &#125;<br><br>    <span class="hljs-comment">//传入一个指定类型用于比较的Key的获取方式，然后再传入Key的比较操作实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor,</span><br><span class="hljs-params">            Comparator&lt;? <span class="hljs-built_in">super</span> U&gt; keyComparator)</span><br>    &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        Objects.requireNonNull(keyComparator);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),<br>                                              keyExtractor.apply(c2));<br>    &#125;<br><br>    <span class="hljs-comment">//传入一个指定类型用于比较的Key（需要实现Comparable）的获取方式，然后自动进行比较</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>    &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));<br>    &#125;<br><br>    <span class="hljs-comment">//针对于内置类型的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-built_in">super</span> T&gt; keyExtractor)</span> &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，有关两个比较相关的接口就介绍完成了。</p>
<h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。</p>
<p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Collections.max(list);<br>    Collections.min(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>);<br>    System.out.println(Collections.binarySearch(list, <span class="hljs-number">8</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    Collections.fill(list, <span class="hljs-number">6</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果集合中本身没有元素，那么<code>fill</code>操作不会生效。</p>
<p>有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用<code>emptyXXX</code>来快速生成一个只读的空集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Collections.emptyList();<br>  	<span class="hljs-comment">//Collections.singletonList() 会生成一个只有一个元素的List</span><br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以将一个可修改的集合变成只读的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    List&lt;Integer&gt; newList = Collections.unmodifiableList(list);<br>    newList.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以寻找子集合的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    System.out.println(Collections.indexOfSubList(list, Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  	<span class="hljs-comment">//使用原始类型接收一个Integer类型的ArrayList</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list.add(<span class="hljs-string">&quot;aaa&quot;</span>);   <span class="hljs-comment">//我们惊奇地发现，这玩意居然能存字符串进去</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/10/04/FP5z3X8SEMkGYtT.png" srcset="/img/loading.gif" lazyload alt="image-20221004001007854"></p>
<p>没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list = Collections.checkedList(list, Integer.class);   <span class="hljs-comment">//这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型</span><br>  	list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>checkedXXX</code>可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：</p>
<p><img src="https://s2.loli.net/2022/10/04/5BHq1u9JU3bhdI6.png" srcset="/img/loading.gif" lazyload alt="image-20221004001409799"></p>
<p>是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。</p>
<h3 id="Java-9-集合工厂方法"><a href="#Java-9-集合工厂方法" class="headerlink" title="(Java 9) 集合工厂方法"></a>(Java 9) 集合工厂方法</h3><p>有些时候我们可能需要创建一个携带默认数据的集合对象，比如一个水果清单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>fruit.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>fruit.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>fruit.add(<span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>像这样一个一个添加实在是太累了，我们前面学习了<code>Arrays</code>工具类，它可以快速用于创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruit = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>不过这种操作实际上更像是官方为数组设计的工具。在Java9之后，官方为我们提供了更加方便的工厂方法进行快速创建，不仅仅是List、包括Map、Set都被添加了若干个名字为<code>of</code>的静态方法：</p>
<p><img src="https://s2.loli.net/2025/07/07/YytpnaFwL5XACiM.png" srcset="/img/loading.gif" lazyload alt="image-20250707205131728"></p>
<p>通过这种方式就能像这样编写了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruits = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br>Set&lt;String&gt; fruitSet = Set.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>通过这种方式得到的集合对象同样是只读的，不可对其内容进行修改。其中<code>Set</code>和<code>List</code>的使用方法与之前提到的<code>Arrays</code>类似，直接依次填写即可。注意这里的Set集合默认使用的是类似HashSet的实现，元素没有特定顺序。</p>
<p>对于Map来说，我们需要把key和value交替进行编写，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; fruitMap = Map.of(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>其中前者为Key，后者为Value，使用方式与上面是差不多的。除了直接传入键值对，也可以传入Entry对象进行构建：</p>
<p><img src="https://s2.loli.net/2025/07/07/ol4TyBChMN6R1ut.png" srcset="/img/loading.gif" lazyload alt="image-20250707205406929"></p>
<h3 id="Java-21-有序集合功能规范"><a href="#Java-21-有序集合功能规范" class="headerlink" title="(Java 21) 有序集合功能规范"></a>(Java 21) 有序集合功能规范</h3><p>前面我们提到过，针对于有序集合类，Java 21新增了一系列<code>SequencedCollection</code>、<code>SequencedSet</code>和<code>SequencedMap</code>接口，这些接口扩展和规范了所有有序集合的功能，我们先来看比较简单的，我们以List列表为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(list.get(<span class="hljs-number">0</span>));   <span class="hljs-comment">//Java21之前获取首个元素</span><br>System.out.println(list.getFirst());  <span class="hljs-comment">//现在可以直接使用getFirst拿第一个了</span><br><br>System.out.println(list.get(list.size() - <span class="hljs-number">1</span>));  <span class="hljs-comment">//Java21之前获取最后一个元素，还得先拿到总长度</span><br>System.out.println(list.getLast());   <span class="hljs-comment">//现在直接能拿了，堪称史诗级更新</span><br></code></pre></td></tr></table></figure>

<p>原本只有LinkedList才有的列表首尾操作功能，现在所有有序列表都可以使用了，算是真正统一了列表的使用方式。包括原本LinkedList作为栈和队列才有的首尾插入操作，现在对于所有有序列表都能使用了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.addFirst(<span class="hljs-string">&quot;A&quot;</span>);<br>list.addFirst(<span class="hljs-string">&quot;B&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>其中比较重要的功能是我们可以直接生成对应列表的反转列表了，只需调用<code>reversed</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>System.out.println(list.reversed());<br></code></pre></td></tr></table></figure>

<p>但是注意它并不是直接对原列表进行修改，而是直接返回了一个新的列表对象，其具体实现为<code>ReverseOrderListView</code>倒序列表视图，为什么叫这样一个名字呢？首先大家需要理解视图的概念，视图相当于是对原来的数据换了一种方式进行展示，他可以像普通的列表一样进行查询，也可以像普通的列表那样去修改，但是其并不存储任何数据，所有对于视图的修改最终会作用到原列表上。</p>
<p>这样就很好理解了，我们可以通过下面的例子来解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>List&lt;String&gt; rlist = list.reversed();<br>System.out.println(rlist);<br><br>list.addLast(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//向原本列表的尾部插入元素D</span><br>System.out.println(rlist);<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/09/nLO1SorCPdhWefH.png" srcset="/img/loading.gif" lazyload alt="image-20250709003608414"></p>
<p>可以看到，在修改原本列表之后，其反转之后的列表视图打印的结果也跟着发生了变化。同样的，我们也可以直接对视图进行修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>List&lt;String&gt; rlist = list.reversed();<br>System.out.println(list);<br><br>rlist.addLast(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//向反转列表的尾部插入元素D，相当于在原列表首部插入元素D</span><br>System.out.println(list);<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/09/A16JM4doHsXKtEv.png" srcset="/img/loading.gif" lazyload alt="image-20250709003954386"></p>
<p>可以看到，我们向视图中进行的插入操作，最终作用到原本的列表上了，并且作用的效果也是相反的。因此，如果你只是单纯希望对列表内部元素进行倒序排序，可以考虑使用我们下面会讲解的<code>Collections</code>工具类，其中包含大量处理集合的操作。</p>
<p>而<code>SequencedSet</code>，它是对于<code>Set</code>的扩展，同样添加了头插尾插的操作，但是只有一部分Set集合类实现了此接口。</p>
<p>其中<code>SequencedMap</code>相关方法与上述内容类似，这里就不重复讲解了。</p>
<h3 id="Java-8-Stream流"><a href="#Java-8-Stream流" class="headerlink" title="(Java 8) Stream流"></a>(Java 8) Stream流</h3><p>Java 8 API添加了一个新的操作，我们称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<p><img src="https://s2.loli.net/2022/10/03/r4AtmVRZ51y7uxd.png" srcset="/img/loading.gif" lazyload alt="image-20221003232832897"></p>
<p>它看起来就像一个工厂的流水线一样，每一步都会对数据进行处理，乍一看好像没区别啊。我们来看看普通的处理和使用Stream处理有什么不一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  	<span class="hljs-comment">//这是普通的处理</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>  <br>  	<span class="hljs-comment">//移除为B的元素</span><br>  	Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        <span class="hljs-keyword">if</span>(iterator.next().equals(<span class="hljs-string">&quot;B&quot;</span>)) iterator.remove();<br>    &#125;<br>  <br>  	<span class="hljs-comment">//这是通过Stream的处理</span><br>    list = list     <span class="hljs-comment">//链式调用</span><br>            .stream()    <span class="hljs-comment">//获取流</span><br>            .filter(e -&gt; !e.equals(<span class="hljs-string">&quot;B&quot;</span>))   <span class="hljs-comment">//只允许所有不是B的元素通过流水线</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//将流水线中的元素重新收集起来，变回List</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看完这个例子之后，好像感觉除了写法高级了点之外，也没什么区别啊？这有啥用啊。虽然看起来是一样的，但是实际上它们的执行过程存在一定的差别。</p>
<p>同样是一批数据，直接编写操作对数据处理相当于吧这一批数据处理完之后，又开始下一个步骤继续处理这一批数据，每一步需要等到上一步结束之后，拿到上一批数据才能开始下一步，每一个流程依次进行：</p>
<p><img src="https://s2.loli.net/2025/07/07/QRBxXyA9OlC7sFf.png" srcset="/img/loading.gif" lazyload alt="image-20250707230607130"></p>
<p>而Stream则是提前编排好流程，每一个元素依次独立走完流水线，无需按批次完成：</p>
<p><img src="https://s2.loli.net/2025/07/07/7oh9XCp5cK6vJlL.png" srcset="/img/loading.gif" lazyload alt="image-20250707230814486"></p>
<p>前者需要在不同工厂之间传递整批数据，而后者则是直接把所有工厂揉在一起，形成流水线。</p>
<p>我们再通过一个例子来感受一下这种过程，下面的例子包含三个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; x)  <span class="hljs-comment">//map可以对实现接受一种类型的数据，转为同类型或另一类型的数据</span><br>        .map(x -&gt; x)  <span class="hljs-comment">//这里为了简单好理解，就不做任何处理原样返回</span><br>        .forEach(System.out::println);  <span class="hljs-comment">//最后一步是打印</span><br></code></pre></td></tr></table></figure>

<p>现在我们在每一步操作上都添加一个打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第一步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)  <span class="hljs-comment">//map可以对实现接受一种类型的数据，转为同类型或另一类型的数据</span><br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第二步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>得到的结果为：</p>
<p><img src="https://s2.loli.net/2025/07/07/RxgFLaSyft8Il6B.png" srcset="/img/loading.gif" lazyload alt="image-20250707232051022"></p>
<p>乍一看好像有点看不懂啊，这顺序怎么好像是乱的呢，实则不然，还记得我们上面说的每个元素依次走流水线吗？我们可以来看前三步，首先是1号元素进入到第一步，接着进入到第二步，最后在第三步打印时结束。此时1号元素结束，紧接着又是2号元素在进行同样的流水线流程，这下就很清晰了，确实是依次按照流水线执行。</p>
<p>实际上，在我们调用Stream的各种方法时，并不是像我们之前那样直接对数据进行处理，而是在进行编排，直到我们调用最后一步<code>forEach</code>或是<code>collect</code>这种收尾的方法时，整个流水线才开始运作（不相信可以试试看去掉最后的收尾操作，不会有任何操作执行）这也是Stream的一种惰性的体现。</p>
<p><strong>注意：</strong> 后续我们学习多线程之后，Stream甚至还能利用多线程，同时开展N条流水线进行处理，大大提升数据处理效率。</p>
<p>我们再来看一个例子，这个例子包含四个流水线操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第一步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment">//过滤掉所有奇数</span><br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第三步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/07/1reHCPgmLAMs7cX.png" srcset="/img/loading.gif" lazyload alt="image-20250707232933301"></p>
<p>其中，由于第二步中进行了过滤操作，很多元素在进入到第三步之前就被提前丢弃了。这在处理大量数据的时候非常有效，一次性处理全部数据会占用非常多的内存，而通过流水线一步一步进行，依次进行数据处理会省去很多内存开销。</p>
<p>同时，利用流中提供的预设操作，我们无需自己编写繁琐的操作流程代码，只需要调用几个方法进行编排即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><br>    list = list<br>            .stream()<br>      			.distinct()   <span class="hljs-comment">//去重（使用equals判断）</span><br>            .sorted((a, b) -&gt; b - a)    <span class="hljs-comment">//进行倒序排列</span><br>            .map(e -&gt; e+<span class="hljs-number">1</span>)    <span class="hljs-comment">//每个元素都要执行+1操作</span><br>            .limit(<span class="hljs-number">2</span>)    <span class="hljs-comment">//只放行前两个元素</span><br>            .collect(Collectors.toList());<br><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当遇到大量的复杂操作时，我们可以使用Stream来快速编写，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了。</p>
<p>接下来，我们用一堆随机数来进行更多流操作的演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <span class="hljs-comment">//没想到吧，Random支持直接生成随机数的流</span><br>    random<br>            .ints(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)   <span class="hljs-comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br>            .limit(<span class="hljs-number">10</span>)   <span class="hljs-comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br>            .filter(i -&gt; i &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//只保留小于0的数字</span><br>            .sorted()    <span class="hljs-comment">//默认从小到大排序</span><br>            .forEach(System.out::println);   <span class="hljs-comment">//依次打印</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>值得注意的是，由于Stream是惰性的，每次只会让Random生成一个新的数据，直到达到<code>limit()</code>阈值，Random则不会再继续生产新的数据了。</p>
<p>利用StreamAPI提供的快捷操作，我们可以创建一个<code>IntSummaryStatistics</code>统计实例对象来帮助我们快速进行统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> random<br>            .ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            .limit(<span class="hljs-number">100</span>)<br>            .summaryStatistics();    <span class="hljs-comment">//获取语法统计实例</span><br>    System.out.println(statistics.getMax());  <span class="hljs-comment">//快速获取最大值</span><br>    System.out.println(statistics.getCount());  <span class="hljs-comment">//获取数量</span><br>    System.out.println(statistics.getAverage());   <span class="hljs-comment">//获取平均值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>);<br>    list.stream()<br>            .mapToInt(i -&gt; i.length())    <span class="hljs-comment">//将每一个元素映射为Integer类型</span><br>            .summaryStatistics();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们还可以通过<code>flatMap</code>来对整个流进行进一步细分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A,B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C,D&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;E,F&quot;</span>);   <span class="hljs-comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br>    list = list<br>            .stream()    <span class="hljs-comment">//生成流</span><br>            .flatMap(e -&gt; Arrays.stream(e.split(<span class="hljs-string">&quot;,&quot;</span>)))    <span class="hljs-comment">//分割字符串并生成新的流</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//汇成新的List</span><br>    System.out.println(list);   <span class="hljs-comment">//得到结果</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list<br>            .stream()<br>            .reduce((a, b) -&gt; a + b)   <span class="hljs-comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br>            .get();    <span class="hljs-comment">//我们发现得到的是一个Optional类实例，通过get方法返回得到的值</span><br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。</p>
<h3 id="Java-9-11-16-Stream增强方法"><a href="#Java-9-11-16-Stream增强方法" class="headerlink" title="(Java 9&#x2F;11&#x2F;16) Stream增强方法"></a>(Java 9&#x2F;11&#x2F;16) Stream增强方法</h3><p>由于Java 8推出的Stream获得了不错的反响，于是在Java 9中为其添加了更多方便实用的方法。集合类可以很轻松地转换为Stream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>List&lt;String&gt; list = Arrays.asList(strings);  <span class="hljs-comment">//还得先转List</span><br>list.stream();<br></code></pre></td></tr></table></figure>

<p>同样的，Java 8为我们提供了<code>of</code>方法用于快速将数组或单个元素包装为Steam对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>Stream.of(strings).forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>在Java 9之后，对于可能为<code>null</code>的元素，我们也可以使用<code>ofNullable</code>方法来包装，如果发现传入的为<code>null</code>则返回一个空的Stream。</p>
<p>当然也新增了一些比较方便的操作，我们先来看<code>takeWhile</code>操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>);<br>list.stream()<br>        .takeWhile(s -&gt; s.length() &lt;= <span class="hljs-number">3</span>)   <span class="hljs-comment">//不断获取直到不满足条件为止，与filter类似，但是会提前终止</span><br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>与之相反的还有<code>dropWhile</code>会尝试不断丢弃，直到第一个不满足条件的出现，才开始依次把元素往下一个流水线输送。</p>
<p>针对于String类型，我们也可以使用流的形式处理其中的每一个字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">str.chars()  <span class="hljs-comment">//使用chars得到一个包含每个字符代码的IntStream</span><br>        .filter(c -&gt; c == <span class="hljs-string">&#x27;l&#x27;</span>)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>与其相似的还有一个codePoints方法，它可以按照按完整Unicode代码点处理，确保字符完整性和正确性，用于字符串中存在一些特殊字符的情况。</p>
</blockquote>
<p>还有一个就是Java 11新增的<code>lines()</code>方法，它会自动对字符串按行分割，返回每一行的子串流。</p>
<p>在Java 16中，Stream中的操作被进一步强化，其中最有用的是常用的<code>List</code>收集被直接整合为了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>Stream.of(strings)<br>        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>        .toList();   <span class="hljs-comment">//Java 16之后可以直接使用toList而不是collect</span><br></code></pre></td></tr></table></figure>

<p>除此之外，还有<code>mapMulti</code>以及其衍生方法，不过这个方法效果与<code>flatMap</code>相似，用法传参相对比较复杂，在一些特殊情况下使用，这里就不进行介绍了，感兴趣可以自行了解。</p>
<h3 id="Java-24-流聚集器"><a href="#Java-24-流聚集器" class="headerlink" title="(Java 24) 流聚集器"></a>(Java 24) 流聚集器</h3><p>传统Stream操作是无状态的，每个元素处理的流程单独进行，而Gatherers可以在处理过程中的同时维护状态，让前面元素的处理结果影响后续元素的处理方式，这里我们来尝试一下官方预设的一些操作。</p>
<p>现在给你一个需求，我们现在需要将包含<code>[A, B, C, D]</code>的流进行两两分组，得到<code>[[A, B],[C, D]]</code>然后再处理成每个分组内两个字符串合并的字符串，最后得到<code>[AB, CD]</code>，现在你该怎么做？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        <span class="hljs-comment">//需要使用Collectors的groupingBy工具进行分组，得到Map</span><br>        .collect(Collectors.groupingBy(s -&gt; list.indexOf(s) / <span class="hljs-number">2</span>))<br>  			<span class="hljs-comment">//把Map的值全部取出来，在转为stream</span><br>        .values()<br>        .stream()<br>        .map(group -&gt; group.get(<span class="hljs-number">0</span>) + group.get(<span class="hljs-number">1</span>))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>可以看到，在之前要对数据进行动态处理，实在是太累了，又有了Gatherers之后，我们可以像这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        .gather(Gatherers.windowFixed(<span class="hljs-number">2</span>))  <span class="hljs-comment">//使用Gatherers的windowFixed创建固定窗口，元素将按照窗口大小自动进行分组</span><br>        .map(item -&gt; item.getFirst() + item.getLast())<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>其中<code>windowFixed</code>就实现了对元素的有状态操作，它不断接受到来的元素，并将其暂存，达到窗口大小之后作为一个新的元素打包返回。</p>
<p>我们也可以自行编写一个聚集器来感受这种带状态的流操作，同样是实现上面的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; tempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();   <span class="hljs-comment">//临时使用一个外部的数组保存临时结果</span><br>list.stream()<br>        .gather(Gatherer.of((_, item, downstream) -&gt; &#123;  <span class="hljs-comment">//要求传入Integrator函数式接口，它用于依次处理流中每个元素</span><br>            tempList.add(item);   <span class="hljs-comment">//其中item就是当前元素，downstream代表下游，用于继续向下游发送元素</span><br>            <span class="hljs-keyword">if</span>(tempList.size() &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">//如果临时列表元素不足2个，则继续缓存</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//返回true表示就行处理下一个，false就终止</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                downstream.push(List.copyOf(tempList));  <span class="hljs-comment">//当元素存满2个时，向下游发送打包好的分组结果</span><br>                tempList.clear();   <span class="hljs-comment">//清理，给后面来的接着用</span><br>                <span class="hljs-keyword">return</span> downstream.isRejecting();  <span class="hljs-comment">//这里需要判断下游是否还愿意继续接受新元素，因为有可能下游存在limit之类的操作，不需要再继续发送元素了，所以要返回判断结果</span><br>            &#125;<br>        &#125;))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>当然，这里只是简单演示Gatherer的功能，<code>Gatherer.of</code>还包含更多参数选项。</p>
<p>此外，官方还为我们提供了一些其他的预设的工具，比如<code>fold</code>，它是一个多对一的有状态收集器，有点类似于<code>reduce</code>的感觉，比如我们想实现列表去重功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>list.stream()    <span class="hljs-comment">//让HashSet作为初始状态存储工具</span><br>        .gather(Gatherers.fold(HashSet::<span class="hljs-keyword">new</span>, (set, item) -&gt; &#123;<br>            set.add(item);   <span class="hljs-comment">//向Set中添加元素</span><br>            <span class="hljs-keyword">return</span> set;   <span class="hljs-comment">//操作完成后需要返回set用于下一轮</span><br>        &#125;))<br>        .flatMap(Collection::stream)  <span class="hljs-comment">//对得到的Set集合展平</span><br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p>接着是<code>scan</code>，它会依次扫描流中每个元素，并会在下一轮中给出上一轮被扫描过的元素，这很适合那些需要用到上一轮计算结果的操作。比如我想让列表<code>[A, B, C, D]</code>变成<code>[A, AB, ABC, ABCD]</code>这种金字塔状，就可以使用这种操作完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        .gather(Gatherers.scan(() -&gt; <span class="hljs-string">&quot;0&quot;</span>, (current, item) -&gt; current + item))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/09/An9adO416pRmLEc.png" srcset="/img/loading.gif" lazyload alt="image-20250709221429476"></p>
<p>最后还有一个<code>mapConcurrent</code>方法，它可以并发实现对元素的映射，相当于是多线程版本的<code>map</code>操作，有关多线程的内容，我们会放在后面的章节讲解。</p>
<hr>
<h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><p><strong>注意：</strong> 这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p>
<p>I&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I&#x2F;O设备。</p>
<p>我们可以大致看一下整个计算机的总线结构：</p>
<p><img src="https://s2.loli.net/2022/10/04/Q8JGeMprkgHsnPY.png" srcset="/img/loading.gif" lazyload alt="image-20221004002405375"></p>
<p>常见的I&#x2F;O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p>
<p>而我们在程序中，想要读取这些外部连接的I&#x2F;O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows&#x2F;Linux&#x2F;MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取&#x2F;写入请求。</p>
<p>从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p>
<p><img src="https://s2.loli.net/2022/10/04/13h7yTekm2FfnRw.png" srcset="/img/loading.gif" lazyload alt="image-20221004002733950"></p>
<p>（传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据）</p>
<p>JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO，</p>
<p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p>
<h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p>
<p>首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">//注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>);<br>        <span class="hljs-comment">//路径支持相对路径和绝对路径</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！比如在Windows下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C://User/lbw/nb    这个就是一个绝对路径，因为是从盘符开始的<br><span class="hljs-built_in">test</span>/test          这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径<br></code></pre></td></tr></table></figure>

<p>在Linux和MacOS下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/root/tmp       这个就是一个绝对路径，绝对路径以/开头<br><span class="hljs-built_in">test</span>/test       这个就是一个相对路径，不是以/开头的<br></code></pre></td></tr></table></figure>

<p>当然，这个其实还是很好理解的，我们在使用时注意一下就行了。</p>
<p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">//定义可以先放在try外部</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        inputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//建议在finally中进行，因为关闭流是任何情况都必须要执行的！</span><br>            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-literal">null</span>) inputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>)) &#123;   <span class="hljs-comment">//直接在try()中定义要在完成之后释放的资源</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;   <span class="hljs-comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">//无需再编写finally语句块，因为在最后自动帮我们调用了close()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后为了方便，我们都使用此语法进行教学。</p>
<p>现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用<code>read</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：a</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//使用read()方法进行字符读取</span><br>        System.out.println((<span class="hljs-type">char</span>) inputStream.read());  <span class="hljs-comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br>        System.out.println(inputStream.read());   <span class="hljs-comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read()) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//通过while循环来一次性读完内容</span><br>            System.out.println((<span class="hljs-type">char</span>)tmp);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>available</code>方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I&#x2F;O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    System.out.println(inputStream.available());  <span class="hljs-comment">//查看剩余数量</span><br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];   <span class="hljs-comment">//我们可以提前准备好合适容量的byte数组来存放</span><br>        System.out.println(inputStream.read(bytes));   <span class="hljs-comment">//一次性读取全部内容（返回值是读取的字节数）</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));   <span class="hljs-comment">//通过String(byte[])构造方法得到字符串</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以控制要读取数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(inputStream.read(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment">//第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span><br></code></pre></td></tr></table></figure>

<p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p>
<p>通过<code>skip()</code>方法可以跳过指定数量的字节，返回值为实际跳过的字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        System.out.println(inputStream.skip(<span class="hljs-number">1</span>));<br>        System.out.println((<span class="hljs-type">char</span>) inputStream.read());   <span class="hljs-comment">//跳过了一个字节</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p>
<p>既然有输入流，那么文件输出流也是必不可少的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//注意：若此文件不存在，会直接创建这个文件！</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&#x27;c&#x27;</span>);   <span class="hljs-comment">//同read一样，可以直接写入内容</span><br>      	outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());   <span class="hljs-comment">//也可以直接写入byte[]</span><br>      	outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//同上输入流</span><br>      	outputStream.flush();  <span class="hljs-comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-literal">true</span>)) &#123;  <span class="hljs-comment">//true表示开启追加模式</span><br>        outputStream.write(<span class="hljs-string">&quot;lb&quot;</span>.getBytes());   <span class="hljs-comment">//现在只会进行追加写入，而不是直接替换原文件内容</span><br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;   <span class="hljs-comment">//可以写入多个</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//使用长度为10的byte[]做传输媒介</span><br>        <span class="hljs-type">int</span> tmp;   <span class="hljs-comment">//存储本地读取字节数</span><br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//直到读取完成为止</span><br>            outputStream.write(bytes, <span class="hljs-number">0</span>, tmp);    <span class="hljs-comment">//写入对应长度的数据到输出流</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>      	reader.skip(<span class="hljs-number">1</span>);   <span class="hljs-comment">//现在跳过的是一个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) reader.read());   <span class="hljs-comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同理，字符流只支持<code>char[]</code>类型作为存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>        <span class="hljs-type">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>];<br>        reader.read(str);<br>        System.out.println(str);   <span class="hljs-comment">//直接读取到char[]中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>既然有了Reader肯定也有Writer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))&#123;<br>      	writer.getEncoding();   <span class="hljs-comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br>       writer.write(<span class="hljs-string">&#x27;牛&#x27;</span>);<br>       writer.append(<span class="hljs-string">&#x27;牛&#x27;</span>);   <span class="hljs-comment">//其实功能和write一样</span><br>      	writer.flush();   <span class="hljs-comment">//刷新</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Writer <span class="hljs-title function_">append</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    write(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p>
<p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件。</p>
<p>这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);   <span class="hljs-comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br>    System.out.println(file.exists());   <span class="hljs-comment">//此文件是否存在</span><br>    System.out.println(file.length());   <span class="hljs-comment">//获取文件的大小</span><br>    System.out.println(file.isDirectory());   <span class="hljs-comment">//是否为一个文件夹</span><br>    System.out.println(file.canRead());   <span class="hljs-comment">//是否可读</span><br>    System.out.println(file.canWrite());   <span class="hljs-comment">//是否可写</span><br>    System.out.println(file.canExecute());   <span class="hljs-comment">//是否可执行</span><br>  <br>    file.createNewFile();   <span class="hljs-comment">//创建新文件</span><br>    file.delete();   <span class="hljs-comment">//删除文件</span><br>    file.mkdir();    <span class="hljs-comment">//创建目录，但父级目录不存在会直接报错</span><br>    file.mkdirs();   <span class="hljs-comment">//创建目录，如果父级目录不存在会一起创建</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>System.out.println(Arrays.toString(file.list()));   <span class="hljs-comment">//快速获取文件夹下的文件名称列表</span><br><span class="hljs-keyword">for</span> (File f : file.listFiles())&#123;   <span class="hljs-comment">//所有子文件的File对象</span><br>    System.out.println(f.getAbsolutePath());   <span class="hljs-comment">//获取文件的绝对路径</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file))&#123;   <span class="hljs-comment">//直接做参数</span><br>    System.out.println(inputStream.available());<br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p>
<h3 id="Java-7-8-11-文件工具类"><a href="#Java-7-8-11-文件工具类" class="headerlink" title="(Java 7&#x2F;8&#x2F;11) 文件工具类"></a>(Java 7&#x2F;8&#x2F;11) 文件工具类</h3><p><code>Files</code>类是<code>java.nio.file</code>包中的一个实用类，在Java 7中推出，提供了许多静态方法，用于文件和目录的操作。它大大简化了文件处理的工作，例如创建、删除、读取、写入和属性管理等。比如之前的创建目录操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Files.createDirectory(Path.of(<span class="hljs-string">&quot;./test&quot;</span>));  <span class="hljs-comment">//使用createDirectory直接创建一个指定目录</span><br>    Files.createDirectories(Path.of(<span class="hljs-string">&quot;./test&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中提供了非常方便的方法直接创建目录，只不过此工具类的路径需要配合<code>Path</code>对象来指定，它代表一个文件路径，可以直接通过<code>of</code>方法来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;src/com/test&quot;</span>);<br>System.out.println(path.toAbsolutePath());   <span class="hljs-comment">//获取绝对路径</span><br>System.out.println(path.toAbsolutePath().getParent());  <span class="hljs-comment">//获取父路径</span><br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/08/1YIRTzM3nWwL8xK.png" srcset="/img/loading.gif" lazyload alt="image-20250708204944405"></p>
<p>利用此类型代表路径，可以为我们带来更多的便利，如快速获取绝对路径、父级目录等。现在回到<code>Files</code>类，对于文件的删除也是很方便的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;test&quot;</span>);<br>Files.delete(path);   <span class="hljs-comment">//删除，没有文件报错</span><br>Files.deleteIfExists(path);  <span class="hljs-comment">//删除，没有文件返回false否则返回true</span><br></code></pre></td></tr></table></figure>

<p>还有很多对于文件的快捷操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.readString(path)   <span class="hljs-comment">//Java 11新增，读取所有内容并以字符串返回</span><br>List&lt;String&gt; lines = Files.readAllLines(path);   <span class="hljs-comment">//一键读取所有文件内容并按行分割返回</span><br>Stream&lt;String&gt; linesStream = Files.lines(path);   <span class="hljs-comment">//同上，以Java 8之后的Stream形式返回</span><br><br>Files.write(path, <span class="hljs-string">&quot;HelloWorld&quot;</span>.getBytes());   <span class="hljs-comment">//一键写入内容</span><br>Files.writeString(path, <span class="hljs-string">&quot;HelloWorld&quot;</span>);  <span class="hljs-comment">//Java 11新增，更快捷的用字符串一键写入</span><br><br>Files.copy(path, Path.of(<span class="hljs-string">&quot;another&quot;</span>));   <span class="hljs-comment">//拷贝文件到另一个路径</span><br>Files.move(path, Path.of(<span class="hljs-string">&quot;another&quot;</span>));   <span class="hljs-comment">//移动文件到另一个路径</span><br><br>Files.exists(path);   <span class="hljs-comment">//判断文件是否存在</span><br>Files.notExists(path);  <span class="hljs-comment">//判断文件是否不存在</span><br><br>Files.isExecutable(path);  <span class="hljs-comment">//文件是否可执行</span><br>Files.isDirectory(path);  <span class="hljs-comment">//文件是否是文件夹</span><br>Files.isWritable(path);   <span class="hljs-comment">//文件是否可写</span><br>Files.isReadable(path);   <span class="hljs-comment">//文件是否可读</span><br>Files.isHidden(path);   <span class="hljs-comment">//文件是否为隐藏文件</span><br><br>Files.newInputStream(path);  <span class="hljs-comment">//创建新的文件输入流</span><br>Files.newOutputStream(path);   <span class="hljs-comment">//创建新的文件输出流</span><br></code></pre></td></tr></table></figure>

<p>此外，对于文件的查找，该工具类也给了非常好用API，其中<code>find</code>方法可以帮助我们快速查找文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其中第一个参数为起始查找点，第二参数为最大查找深度，最后就是一个断言函数式，就是判断每一个文件是否符合我们要查找的要求</span><br>Files.find(Path.of(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-number">4</span>, (path, attributes) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (path.getFileName().toString().equals(<span class="hljs-string">&quot;Main.java&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;).forEach(path -&gt; &#123;   <span class="hljs-comment">//find的结果会以Stream的形式返回</span><br>    System.out.println(path);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>对于整个目录下文件的遍历，我们可以使用<code>walkFileTree</code>方法，此方法需要我们手动实现一个<code>FileVisitor</code>类，用于指定文件的查找操作，假设我们希望遍历项目目录下所有文件并打印所有非文件夹的普通文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数指定起始位置，第二个参数实现FileVisitor</span><br>Files.walkFileTree(Path.of(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;找到目录: &quot;</span> + dir.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;  <span class="hljs-comment">//需要返回一个文件结果，CONTINUE就是继续，如果不想继续了也可以返回TERMINATE或是SKIP_SUBTREE跳过这个目录</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;找到文件: &quot;</span> + file.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFileFailed</span><span class="hljs-params">(Path file, IOException exc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.err.println(<span class="hljs-string">&quot;访问失败: &quot;</span> + file.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>不过上面这种方式写起来还是有点复杂，在Java8之后，Files也为我们提供了很方便的<code>walk</code>方法，它同样是返回一个Stream给我们，其中包含遍历的每一个文件的<code>Path</code>对象，这样就简单多了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.walk(Path.of(<span class="hljs-string">&quot;.&quot;</span>))  <span class="hljs-comment">//返回Stream&lt;Path&gt;</span><br>        .filter(Files::isRegularFile)   <span class="hljs-comment">//filter过滤判断是否为普通文件</span><br>        .forEach(System.out::println);   <span class="hljs-comment">//打印</span><br></code></pre></td></tr></table></figure>

<p>有关Files的相关操作就介绍到这里，详细内容各位小伙伴可以继续尝试探索。</p>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I&#x2F;O设备去获取数据，由于外部I&#x2F;O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p>
<p><img src="https://s2.loli.net/2022/10/04/S8O61JP2lqKTzjd.png" srcset="/img/loading.gif" lazyload alt="image-20221004125755217"></p>
<p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;   <span class="hljs-comment">//传入FileInputStream</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//操作和原来的流是一样的</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上进行I&#x2F;O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code>，我们会在设计模式篇中详细介绍。我们可以来观察一下它的<code>close</code>方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">byte</span>[] buffer;<br>    <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-built_in">this</span>, buffer, <span class="hljs-literal">null</span>)) &#123;  <span class="hljs-comment">//CAS无锁算法，并发会用到，暂时不需要了解</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> in;<br>            in = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>)<br>                input.close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Else retry in case a new buf was CASed in fill()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p>
<p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="hljs-comment"> * it may be replaced by another array of</span><br><span class="hljs-comment"> * a different size.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br></code></pre></td></tr></table></figure>

<p>I&#x2F;O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks the current position in this input stream. A subsequent</span><br><span class="hljs-comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="hljs-comment"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="hljs-comment"> * allow that many bytes to be read before the mark position gets</span><br><span class="hljs-comment"> * invalidated.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span><br><span class="hljs-comment"> *                      the mark position becomes invalid.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#in</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>    in.mark(readlimit);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        bufferedInputStream.reset();   <span class="hljs-comment">//回到mark时的位置</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">1</span>))&#123;  <span class="hljs-comment">//将缓冲区大小设置为1</span><br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//已经超过了readlimit，继续读取会导致mark失效</span><br>        bufferedInputStream.reset();   <span class="hljs-comment">//mark已经失效，无法reset()</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());<br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>操作和FileOutputStream一致，这里就不多做介绍了。</p>
<p>既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用和reader也是一样的，内部也包含一个缓存数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">char</span> cb[];<br></code></pre></td></tr></table></figure>

<p>相比Reader更方便的是，它支持按行读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(reader.readLine());   <span class="hljs-comment">//按行读取</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader<br>                .lines()<br>                .limit(<span class="hljs-number">2</span>)<br>                .distinct()<br>                .sorted()<br>                .forEach(System.out::println);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader.mark(<span class="hljs-number">1</span>);<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>        reader.reset();<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        reader.newLine();   <span class="hljs-comment">//使用newLine进行换行</span><br>        reader.write(<span class="hljs-string">&quot;汉堡做滴彳亍不彳亍&quot;</span>);   <span class="hljs-comment">//可以直接写入一个字符串</span><br>      	reader.flush();   <span class="hljs-comment">//清空缓冲区</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。</p>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//以操作Writer的样子写入OutputStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p>
<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">PrintStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        stream.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//其实System.out就是一个PrintStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p>
<p><img src="https://s2.loli.net/2022/10/04/w8RKJxLm6Ik5usn.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>因此实际上内部还包含这两个内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="hljs-comment"> * can be flushed without flushing the entire stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> BufferedWriter textOut;<br><span class="hljs-keyword">private</span> OutputStreamWriter charOut;<br></code></pre></td></tr></table></figure>

<p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p>
<p>而我们之前使用的Scanner，使用的是系统提供的输入流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);   <span class="hljs-comment">//系统输入流，默认是接收控制台输入</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们也可以使用Scanner来扫描其他的输入流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;秘制小汉堡.txt&quot;</span>));  <span class="hljs-comment">//将文件内容作为输入流进行扫描</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>相当于直接扫描文件中编写的内容，同样可以读取。</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(dataInputStream.readBoolean());   <span class="hljs-comment">//直接将数据读取为任意基本数据类型</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用于写入基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        dataOutputStream.writeBoolean(<span class="hljs-literal">false</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p>
<h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>      	outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;   <span class="hljs-comment">//必须实现Serializable接口才能被序列化</span><br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456</span>;   <span class="hljs-comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当发生版本不匹配时，会无法反序列化为对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">java.io.InvalidClassException: com.test.Main$People; local <span class="hljs-keyword">class</span> <span class="hljs-title class_">incompatible</span>: stream <span class="hljs-type">classdesc</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456</span>, local <span class="hljs-keyword">class</span> <span class="hljs-title class_">serialVersionUID</span> = <span class="hljs-number">1234567</span><br>	at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="hljs-number">699</span>)<br>	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="hljs-number">2003</span>)<br>	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="hljs-number">1850</span>)<br>	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number">2160</span>)<br>	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number">1667</span>)<br>	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">503</span>)<br>	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">461</span>)<br>	at com.test.Main.main(Main.java:<span class="hljs-number">27</span>)<br></code></pre></td></tr></table></figure>

<p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>        outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);  <span class="hljs-comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234567</span>;<br><br>    <span class="hljs-keyword">transient</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p>
<h3 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h3><p>这个流是一个非常特殊的流，它内部维护了一个<code>byte[]</code>类型的对象，用于直接包含流的数据。</p>
<p>有些时候我们可能希望将某些数据直接转换为流的形式，比如字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-string">&quot;我是一个可爱的字符串&quot;</span>.getBytes());<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">buffered</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(stream));<br>    System.out.println(buffered.readLine());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过构造<code>ByteArrayInputStream</code>来快速将我们需要的数据构造为流，它接受一个<code>byte[]</code>数组，此数组将直接作为其数据，当对流的数据进行读取时，直接返回数据中的内容。</p>
<p>与之相反的有一个叫<code>ByteArrayOutputStream</code>的流，它内部同样维护一个<code>byte[]</code>数组，用于存放外部写入的数据，在写入数据完成后，我们可以调用<code>toByteArray</code>来获取其中的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    stream.write(<span class="hljs-string">&quot;Hello, world!&quot;</span>.getBytes());<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(stream.toByteArray()));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这两种流在处理一些直接数据时非常方便。</p>
<h3 id="Java-9-11-12-输入流快捷操作"><a href="#Java-9-11-12-输入流快捷操作" class="headerlink" title="(Java 9&#x2F;11&#x2F;12) 输入流快捷操作"></a>(Java 9&#x2F;11&#x2F;12) 输入流快捷操作</h3><p>在Java9之后，InputStream中新增了很多实用的工具方法，这里我们来学习一下。</p>
<p>首先是内容读取，在之前我们如果需要读取一个文本文件的内容，需要写一个循环来不断<code>read</code>里面的内容，直到结束，这实在是太繁琐了，通过<code>available()</code>获取的剩余容量又不一定准确。所以，从Java 9 开始，官方内置一个新的方法来便于我们一次性读取文件内容，我们终于可以解放双手了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = stream.readAllBytes();   <span class="hljs-comment">//此方法可以阻塞地一次性读取流中所有剩余字节</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/07/9jLtir2Shd7DWPu.png" srcset="/img/loading.gif" lazyload alt="image-20250707214750947"></p>
<p>注意如果流已经被读取完成，调用此方法只能直接返回空数组，因为没数据可读了。</p>
<p>那如果我需要读取指定数量的数据怎么办呢？同样的，Java 9 为我们提供了<code>readNBytes</code>方法，它可以更灵活地控制读取流中的多少字节或是哪个位置开始的字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span>];<br>    stream.readNBytes(bytes, <span class="hljs-number">0</span>, bytes.length);  <span class="hljs-comment">//从流的起始位置开始读取9个字节</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2025/07/07/14cyC8xMJeB5qYL.png" srcset="/img/loading.gif" lazyload alt="image-20250707215146453"></p>
<p>注意<code>readNBytes</code>返回值为实际读取的字节数，因为有可能出现流中数据还没有想要的这么长的情况。</p>
<p>从Java 11开始，我们还可以直接使用一个重载之后的更简单的<code>readNBytes</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = stream.readNBytes(<span class="hljs-number">9</span>);   <span class="hljs-comment">//和readAllBytes一样，直接返回数组</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它可以直接指定要读取的数量，并返回对应的byte数组。</p>
<p>对于值之前的<code>skip()</code>方法，Java 12为我们提供了一个更强大的<code>skipNBytes</code>方法，此方法同样用于跳过指定字节，但是其行为是<strong>精确地跳过</strong>输入流中的 <code>n</code> 个，它不像<code>skip()</code>那样跳过多少算多少，而是要求必须跳过这么多字节，否则抛出<code>EOFException</code>异常，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>.getBytes())) &#123;<br>    stream.skipNBytes(<span class="hljs-number">200</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Java 11还为我们提供了一个直接生成已读取结束的流的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> InputStream.nullInputStream()) &#123; <span class="hljs-comment">//直接生成一个没有数据的等价于用完的流</span><br>    <span class="hljs-type">byte</span>[] bytes = stream.readAllBytes();<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));   <span class="hljs-comment">//读取出来的直接就是一个空数组，因为已经用过了</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似的还有OutputStream的<code>nullOutputStream</code>方法，生成一个可以无限倾倒数据的输出流，就像给黑洞吞了就没了。</p>
<p>最后还有一个非常实用的方法，它是Java 9提供的<code>transferTo</code>，它可以直接将当前输入流中的内容转换到一个输出流中，相当于用一个管道直接把输入输出连接起来，输入的内容直接往输出的地方跑。这就很方便了，比如我们要拷贝一个文件，可以直接使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>);<br>     <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;./hello2.txt&quot;</span>)) &#123;<br>    in.transferTo(out);   <span class="hljs-comment">//直接transfer到新文件里，并返回实际传输了多少字节的数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，一个文件拷贝就轻松实现了。</p>
<hr>
<h2 id="实战：图书管理系统"><a href="#实战：图书管理系统" class="headerlink" title="实战：图书管理系统"></a>实战：图书管理系统</h2><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p>
<p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a target="_blank" rel="noopener" href="https://www.itbaima.cn/zh-CN/document/k6fmxd6qabgkwm9i">https://www.itbaima.cn/zh-CN/document/k6fmxd6qabgkwm9i</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="print-no-link">#程序设计</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO</div>
      <div>http://me.broccoli.me/2025/08/24/JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>itbaima</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/" title="JavaSE 核心内容 - JavaSE 笔记（七）多线程与反射">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JavaSE 核心内容 - JavaSE 笔记（七）多线程与反射</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="JavaSE 核心内容 - JavaSE 笔记（五）泛型程序设计">
                        <span class="hidden-mobile">JavaSE 核心内容 - JavaSE 笔记（五）泛型程序设计</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a>Broccoli Github Page</a> <i class="iconfont icon-love"></i> <a>Based on</a> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <a>&</a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
