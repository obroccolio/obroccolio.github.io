<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（八）GUI程序开发</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AB%EF%BC%89GUI%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/26/Mu6qwoA9fc7THbQ.png" alt="image-20221026154454258"></p><h1 id="GUI程序开发"><a href="#GUI程序开发" class="headerlink" title="GUI程序开发"></a>GUI程序开发</h1><p>注意：开始学习之前请确保你完成了《Java SE》篇视频教程。</p><p>前面我们已经完成了JavaSE部分的全部内容学习，只不过我们在初学阶段一直都是开发的控制台程序，也就是最原始的命令窗口形式的程序，而Java也可以开发桌面图形化程序，所以我们接着来学习一下Java的图形化界面的开发。</p><h2 id="AWT组件介绍"><a href="#AWT组件介绍" class="headerlink" title="AWT组件介绍"></a>AWT组件介绍</h2><p>在Java正式推出的时候，它还包含一个用于基本GUI程序设计的类库，名字叫 Abstract Window Toolkit，简称AWT，抽象窗口工具包，我们可以直接使用Java为我们提供的工具包来进行桌面应用程序的开发。只不过这套工具包依附于操作系统提供的UI，具体样式会根据不同操作系统提供的界面元素进行展示。</p><p>实际上我们现代操作系统都是图形化界面，应用程序都是以一个窗口的形式展示出来的，我们可以直接使用鼠标点击窗口内的元素来使用应用程序，相比传统的命令行形式，可方便太多了，比如在Windows和MacOS这两种操作系统下：</p><p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p><p>可以看到，不同的操作系统的窗口样式稍微有一些不一样，但是大致的使用方式是差不多的，我们接着来看一下如何使用Java编写简单的桌面图形化程序。</p><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>既然我们要编写一个桌面程序，那么肯定是需要窗口来展示我们程序的内容的，所以说，我们可以使用AWT为我们提供的组件来创建窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>();   <span class="hljs-comment">//Frame是窗体，我们只需要创建这样一个对象就可以了，这样就会直接创建一个新的窗口</span><br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);   <span class="hljs-comment">//可以使用setSize方法设定窗体大小</span><br>    frame.setVisible(<span class="hljs-literal">true</span>);    <span class="hljs-comment">//默认情况下窗体是不可见的，我们如果要展示出来，还需要设置窗体可见性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，桌面的左上角已经展示出我们的窗口了：</p><p><img src="https://s2.loli.net/2022/10/26/ZSQs1NhWlJeyMmi.png" alt="image-20221026165600076"></p><p>在不同的操作系统下，窗口的样式会不同。</p><p>我们可以通过Frame的各种方法来设置窗口的各项属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>();<br>    frame.setTitle(<span class="hljs-string">&quot;我是标题&quot;</span>);   <span class="hljs-comment">//设置窗口标题</span><br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);    <span class="hljs-comment">//设置窗口大小</span><br>    frame.setBackground(Color.BLACK);   <span class="hljs-comment">//设置窗口背景颜色</span><br>  frame.setResizable(<span class="hljs-literal">false</span>);    <span class="hljs-comment">//设置窗口大小是否固定</span><br>  frame.setAlwaysOnTop(<span class="hljs-literal">true</span>);    <span class="hljs-comment">//设置窗口是否始终展示在最前面</span><br>    frame.setVisible(<span class="hljs-literal">true</span>);    <span class="hljs-comment">//注意，只有将可见性变为true时才会展示出这个窗口，否则窗口是隐藏的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上当我们创建一个窗口之后，会在其他线程中进行处理，包括窗口的绘制、窗口事件的监听等，所以说我们的主线程不会卡住。</p><p>实际上我们的程序打开都是默认居中显示的，所以说我们可以调整一下窗口的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLocation(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);   <span class="hljs-comment">//setLocation可以调整窗口位置</span><br></code></pre></td></tr></table></figure><p>注意，这里的窗口位置以及窗口大小都是以像素为单位。整个屏幕有多少个像素，是根据各位小伙伴电脑的显示器屏幕分辨率来决定的，比如我们的电脑显示器屏幕分辨率为 1920 x 1080，那么我们显示器就可以显示长为1920个像素，宽1080个像素的矩形，只要是在这个范围内的窗口，都可以显示到屏幕上：</p><p><img src="https://s2.loli.net/2022/10/26/CknumyFjpz659Ya.png" alt="image-20221026170449235"></p><p>那么问题就来了，如果现在我们希望将这个窗口居中，就需要手动调整位置，但我们是要去适配各种分辨率的显示器才可以，不然到其他分辨率下，就无法居中了，我们可以动态获取分辨率来进行位置计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>(<span class="hljs-string">&quot;我是标题&quot;</span>);<br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br><br>    <span class="hljs-type">Dimension</span> <span class="hljs-variable">screenSize</span> <span class="hljs-operator">=</span> Toolkit.getDefaultToolkit().getScreenSize();  <span class="hljs-comment">//获取到屏幕尺寸</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((screenSize.getWidth() - frame.getWidth()) / <span class="hljs-number">2</span>);   <span class="hljs-comment">//居中位置就是：屏幕尺寸/2 - 窗口尺寸/2</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) ((screenSize.getHeight() - frame.getHeight()) / <span class="hljs-number">2</span>);<br><br>    frame.setLocation(x, y);   <span class="hljs-comment">//位置设置好了之后再展示出来</span><br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们的窗口打开之后默认就是居中放置的了，是不是感觉用Java开发图形界面好像也不是那么难？</p><p>得益于Java已经为我们封装好了各种方法，所以说要实现什么功能直接调用对应的方法即可，比如我们想要个性化光标，我们可以使用<code>setCursor</code>方法来实现，JDK已经为我们提供了一些预设的光标样式：</p><p><img src="https://s2.loli.net/2022/10/27/drC1nx2NSK9Ewaf.png" alt="image-20221027151713661"></p><p>设定光标样式后，当我们的鼠标移动到这个窗口内部时，就会变成我们设定好的光标样式了。</p><p>有关其他方法，这里暂时不进行介绍。</p><h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>我们可以为窗口添加一系列的监听器，监听器会监听窗口中发生的一些事件，比如我们点击关闭窗口、移动鼠标、鼠标点击等，当发生对应的事件时，就会通知到对应的监听器进行处理，从而我们能够在发生对应事件时进行对应处理。</p><p><img src="https://s2.loli.net/2022/10/27/DAz1hnUekV6RNqd.png" alt="image-20221027161611050"></p><p>比如我们现在希望点击关闭按钮关闭当前的窗口，但是我们发现默认情况下实际上是关不掉的，因为我们并没有对关闭事件进行处理，默认情况下对于这种点击时没有设定任何动作的，万一我们点了之后并不是要关闭窗口呢。要实现关闭窗口，我们可以使用<code>addXXXListener</code>来添加对应的事件监听器，比如窗口相关的操作那么就是WindowListener：</p><p><img src="https://s2.loli.net/2022/10/27/IiwomHF7YWe8Vuh.png" alt="image-20221027155830335"></p><p>这里我们可以给一个接口实现，或是使用对应的适配器（适配器模式是设计模式中的一种写法，因为接口中要实现的方法太多，但是实际上我们并不需要实现那么多，只需要实现对应的即可，所以说就可以使用适配器）我们只需要重写对应的方法，当发生对应事件时就会自动调用我们已经实现好的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;   <span class="hljs-comment">//windowClosing方法对应的就是窗口关闭事件</span><br>        frame.dispose();    <span class="hljs-comment">//当我们点击X号关闭窗口时，就会自动执行此方法了</span><br>        <span class="hljs-comment">//使用dispose方法来关闭当前窗口</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosed</span><span class="hljs-params">(WindowEvent e)</span> &#123;   <span class="hljs-comment">//对应窗口已关闭事件</span><br>        System.out.println(<span class="hljs-string">&quot;窗口已关闭！&quot;</span>);   <span class="hljs-comment">//当窗口成功关闭后，会执行这里重写的内容</span><br>      System.exit(<span class="hljs-number">0</span>);    <span class="hljs-comment">//窗口关闭后退出当前Java程序</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们可以来看看效果，现在我们点击X号关闭窗口就可以成功执行了，并且窗口关闭后我们的Java程序就结束了。当然，监听器可以添加多个，并不是只能有一个。</p><p>这里总结一下窗口常用的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WindowListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowOpened</span><span class="hljs-params">(WindowEvent e)</span>;   <span class="hljs-comment">//当窗口的可见性首次变成true时会被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span>;   <span class="hljs-comment">//当以后企图关闭窗口（也就是点击X号）时被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosed</span><span class="hljs-params">(WindowEvent e)</span>;   <span class="hljs-comment">//窗口被我们成功关闭之后被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowIconified</span><span class="hljs-params">(WindowEvent e)</span>;    <span class="hljs-comment">//窗口最小化时被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowDeiconified</span><span class="hljs-params">(WindowEvent e)</span>;   <span class="hljs-comment">//窗口从最小化状态变成普通状态时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowActivated</span><span class="hljs-params">(WindowEvent e)</span>;    <span class="hljs-comment">//当窗口变成活跃状态时被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowDeactivated</span><span class="hljs-params">(WindowEvent e)</span>;   <span class="hljs-comment">//当窗口变成不活跃时被调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了监听窗口相关的动作之外，我们也可以监听鼠标、键盘等操作的事件，比如键盘事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addKeyListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyTyped</span><span class="hljs-params">(KeyEvent e)</span> &#123;    <span class="hljs-comment">//监听键盘输入事件，当我们在窗口中敲击键盘输入时会触发</span><br>        System.out.print(e.getKeyChar());   <span class="hljs-comment">//可以通过KeyEvent对象来获取当前事件输入的对应字符</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>键盘事件甚至可以细致到键盘按键的几种状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">KeyListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyTyped</span><span class="hljs-params">(KeyEvent e)</span>;   <span class="hljs-comment">//当一个按键按下之后触发（感觉跟下面这个没啥区别）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyPressed</span><span class="hljs-params">(KeyEvent e)</span>;   <span class="hljs-comment">//当一个按键按下后触发（按下之后如果不松开会连续触发此事件）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">keyReleased</span><span class="hljs-params">(KeyEvent e)</span>;   <span class="hljs-comment">//当一个按键按下然后松开后触发</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以监听鼠标相关的事件，比如当鼠标点击我们界面上某一个位置时，我们就可以获取一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addMouseListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> &#123;   <span class="hljs-comment">//mouseClicked是监听鼠标点击事件（必须要用真的鼠标点击，不知道为啥，笔记本的触摸板不行，可能是MacOS的BUG吧）</span><br>        System.out.println(<span class="hljs-string">&quot;鼠标点击：&quot;</span>+e.getX()+<span class="hljs-string">&quot;,&quot;</span>+e.getY());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，当我们点击窗口中的某个位置时，就可以获取对应的坐标并打印出来：</p><p><img src="https://s2.loli.net/2022/10/27/VQm7FjSNidLhI1r.png" alt="image-20221027164500070"></p><p>注意这里的坐标并不是按照我们在数学中学习的平面直角坐标系来的，它的X轴是从左往右，但是Y轴是从上往下，原点也不是整个屏幕开始，而是我们的窗口左上角。所以说当我们点击右下角时，就会得到一个接近于窗口大小的坐标了。</p><p>我们也可以获取鼠标是使用哪个键点击的，我们的鼠标一般情况下有三个按键：</p><ul><li>BUTTON1   -   鼠标左键，也是我们用的最多的键</li><li>BUTTON2   -   鼠标中键，一般是鼠标滚轮，也是是可以点击的（不会有人以为鼠标滚轮只能滚不能按吧）</li><li>BUTTON3   -   鼠标右键，右键一般就是辅助点按，展开各种选项等</li></ul><p>如果是游戏鼠标，也许能监听到一些其他的按键，这里我们就不测试了，我们来尝试监听一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addMouseListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseClicked</span><span class="hljs-params">(MouseEvent e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;鼠标点击：&quot;</span>+e.getButton());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>鼠标滚动事件也可以进行监听：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addMouseWheelListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseWheelMoved</span><span class="hljs-params">(MouseWheelEvent e)</span> &#123;<br>        System.out.println(e.getScrollAmount());    <span class="hljs-comment">//获取滚动数量</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>MacOS下的鼠标滚动是平滑滚动，会触发很多次，不像Windows下是一格一格的僵硬滚动。</p><p>通过使用这些监听器，我们就可以更好的控制我们的GUI程序了。</p><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><p>前面我们介绍了监听器，我们接着来看看常用的一些组件，那么什么是组件呢？</p><p>组件实际上是AWT为我们预设好的一些可以直接使用的界面元素，比如按钮、文本框、标签等等，我们可以使用这些已经帮我们写好的组件来快速拼凑出一个好看且功能强大的程序：</p><p><img src="https://s2.loli.net/2022/10/27/D6hslN2pHybmVdF.png" alt="image-20221027170224462"></p><p>在开始学习组件之前，我们先将布局设定为<code>null</code>（因为默认情况下会采用BorderLayout作为布局）有关布局我们会在下一部分中进行介绍，这节课我们先介绍没有布局的情况下如何使用这些组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLayout(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>首先我们来介绍一下最简单的组件，标签组件相当于一个普通的文本内容，我们可以将自己的标签添加到窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Label</span> <span class="hljs-variable">label</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;我是标签&quot;</span>);   <span class="hljs-comment">//添加标签只需要创建一个Label对象即可</span><br>label.setLocation(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>);   <span class="hljs-comment">//注意，必须设定标签的位置和大小，否则无法展示出来</span><br>label.setSize(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>);<br>frame.add(label);    <span class="hljs-comment">//使用add方法添加组件到窗口中</span><br></code></pre></td></tr></table></figure><p>注意，组件的位置是以整个窗口的左上角为原点开始的（整个窗口指的是包括标题栏在内）所以说我们如果想要设置组件的位置，我们还得注意加上标题栏的高度，否则会被标题栏遮挡：</p><p><img src="https://s2.loli.net/2022/10/27/VjCdNbAUIi5R61Z.png" alt="image-20221027175842110"></p><p>我们可以自由修改文本的字体和大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接构造并传入一个Font对象即可</span><br>label.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;SimSong&quot;</span>, Font.BOLD, <span class="hljs-number">15</span>));   <span class="hljs-comment">//Font构造方法需要字体名称、字体样式（加粗、斜体）、字体大小</span><br></code></pre></td></tr></table></figure><p>注意必须是操作系统已经安装的字体才支持展示，如果各位小伙伴不知道操作系统有哪些字体，可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts()<br></code></pre></td></tr></table></figure><p>来获取所有的系统字体：</p><p><img src="https://s2.loli.net/2022/10/27/Fsj8PqHryUYdgeC.png" alt="image-20221027181909908"></p><p>这里我们直接使用前面的<code>family</code>即可，比如我们要使用宋体，那么就输入其名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">label.setFont(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Font</span>(<span class="hljs-string">&quot;Songti SC&quot;</span>, Font.BOLD, <span class="hljs-number">15</span>));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/zy4L2T67rGQe3HI.png" alt="image-20221027182010485"></p><p>可以看到字体已经成功修改了，当然，为了方便，如果我们的窗口中有很多的标签都想统一使用某一个字体，我们可以直接对窗口设定字体，那么只要是添加到窗口中的组件都会默认使用这个字体，除非单独指定组件字体。</p><p>要修改字体的颜色也很简单，我们可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">label.setBackground(Color.BLACK);    <span class="hljs-comment">//setBackground依然是背景颜色，注意背景填充就是我们之前设定的大小</span><br>label.setForeground(Color.WHITE);    <span class="hljs-comment">//setForeground是设定字体颜色</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/R5cDrYxoKtpCJk6.png" alt="image-20221027183745934"></p><p>我们接着来认识一下下一个组件，这个组件的名字叫做按钮，实际上按钮也是我们经常会使用的一个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;点击充值&quot;</span>);   <span class="hljs-comment">//Button是按钮组件</span><br>button.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br>frame.add(button);<br></code></pre></td></tr></table></figure><p>这样就可以添加一个按钮到我们的窗口中了：</p><p><img src="https://s2.loli.net/2022/10/27/gArLdNTI1ClWh5K.png" alt="image-20221027182903783"></p><p>只不过，既然是按钮，那么肯定要添加一些点击动作才可以，比如点击按钮之后打印充值成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">button.addActionListener(e -&gt; System.out.println(<span class="hljs-string">&quot;充值成功&quot;</span>));  <span class="hljs-comment">//addActionListener就是按钮点击监听器</span><br></code></pre></td></tr></table></figure><p>是不是感觉还是很简单？当然，如果要修改按钮的字体或是颜色，依然使用之前的方式即可。</p><p>只不过光有按钮似乎太单调了一点，我们接着来认识下一个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextField</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>();   <span class="hljs-comment">//TextField是文本框</span><br>field.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">25</span>);<br>frame.add(field);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/ZhpojvR6u5DTmVP.png" alt="image-20221027184138604"></p><p> 我们经常要在一些软件上登录，那么就要输入我们的用户名和密码，所以说文本框的作用还是非常明显的，我们也可以通过AWT组件来实现这些功能，我们可以来试试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TextField</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextField</span>();<br>field.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">25</span>);<br>frame.add(field);<br><br><span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;点击登录&quot;</span>);<br>button.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br><span class="hljs-comment">//点击按钮直接获取文本框中的文本内容，只需要调用getText方法即可</span><br>button.addActionListener(e -&gt; System.out.println(<span class="hljs-string">&quot;输入的用户名是：&quot;</span>+field.getText()));<br>frame.add(button);<br></code></pre></td></tr></table></figure><p>我们来试试看吧：</p><p><img src="https://s2.loli.net/2022/10/27/7re3aBis2jW9wvP.png" alt="image-20221027184618359"></p><p><img src="https://s2.loli.net/2022/10/27/Erb6npLZqsCPGzQ.png" alt="image-20221027184627653"></p><p>是不是感觉有内味了？当然，可能会有小伙伴觉得如果我们输入密码的话，不应该将展示的文字隐藏起来吗？我们可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">field.setEchoChar(<span class="hljs-string">&#x27;*&#x27;</span>);   <span class="hljs-comment">//setEchoChar设定展示字符，无论我们输入的是什么，最终展示出来的都是我们指定的字符</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/Er4wqYUNfAy2HBS.png" alt="image-20221027184814288"></p><p>当然，我们在获取输入的文本时还是输入的文本本身，不会变成展示的文本，只是一个视觉效果而已。这样，我们就可以将密码框做出来了。各位小伙伴可以尝试做一个登录界面。</p><p>但是肯定有小伙伴疑问，不是还有一个记住密码的勾选框吗？安排：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Checkbox</span> <span class="hljs-variable">checkbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Checkbox</span>(<span class="hljs-string">&quot;记住密码&quot;</span>);<br>checkbox.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);   <span class="hljs-comment">//这个大小并不是勾选框的大小，具体的勾选框大小要根据操作系统决定，跟Label一样，是展示的空间大小</span><br>frame.add(checkbox);<br></code></pre></td></tr></table></figure><p>最终展示出来的效果就是：</p><p><img src="https://s2.loli.net/2022/10/27/pErwuKAGOa3dQ5l.png" alt="image-20221027185748324"></p><p>效果还是挺不错的，我们也可以设定一个多选框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CheckboxGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckboxGroup</span>();   <span class="hljs-comment">//创建勾选框组</span><br><br><span class="hljs-type">Checkbox</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Checkbox</span>(<span class="hljs-string">&quot;选我&quot;</span>);<br>c1.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br>frame.add(c1);<br><br><span class="hljs-type">Checkbox</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Checkbox</span>(<span class="hljs-string">&quot;你干嘛&quot;</span>);<br>c2.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br>frame.add(c2);<br><br>c1.setCheckboxGroup(group);    <span class="hljs-comment">//多个勾选框都可以添加到勾选框组中</span><br>c2.setCheckboxGroup(group);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/27/y8713x9VBlCaQm6.png" alt="image-20221027190207441"></p><p>我们可以使用<code>getSelectedCheckbox</code>方法来获取已经被选中的勾选框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(group.getSelectedCheckbox());<br></code></pre></td></tr></table></figure><p>常用组件就暂时介绍到这里。</p><h3 id="布局和面板"><a href="#布局和面板" class="headerlink" title="布局和面板"></a>布局和面板</h3><p>前面我们介绍了各种各样的组件，现在我们就可以利用这些组件来拼凑一个好看的程序了。</p><p>只不过，如果不使用布局，那么我们只能手动设置组件的位置以及大小，这就使得我们的程序在尺寸的设计上很有限，因为一旦窗口的大小发生变化，我们的组件依然是会放置在原本的位置上，要保证我们的设计不被破坏就只能固定窗口大小，但是很多应用都是支持放大和缩小的，并且在不同的大小下组件会自己调整位置：</p><p><img src="https://s2.loli.net/2022/10/28/ro7Cxi5Oe8wuALv.png" alt="image-20221028135701447"></p><p>可以看到窗口的大小可以自由移动并且组件的位置会根据窗口大小自己进行调整。</p><p>这正是因为使用了布局实现的，布局可以根据自己的一些性质，对容器（这里可以是我们的窗口）内部的组件自动进行调整，包括组件的位置、组件的大小等，Java为我们提供了各种各样的布局管理器，我们来看看吧。</p><p>默认情况下，我们的窗口采用的是边界布局（BorderLayout）这种布局方式支持将组件放置到五个区域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>());   <span class="hljs-comment">//使用边界布局</span><br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;1号按钮&quot;</span>), BorderLayout.WEST);  <span class="hljs-comment">//在添加组件时，可以在后面加入约束</span><br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;2号按钮&quot;</span>), BorderLayout.EAST);<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;3号按钮&quot;</span>), BorderLayout.SOUTH);<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;4号按钮&quot;</span>), BorderLayout.NORTH);<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;5号按钮&quot;</span>), BorderLayout.CENTER);<br></code></pre></td></tr></table></figure><p>注意，约束只有在当前容器为对应布局时才可以使用。这里我们采用的是边界布局，边界布局可以将组件设定到五个区域：</p><p><img src="https://s2.loli.net/2022/10/28/ZigtAkDbrMVqjWz.png" alt="image-20221028140816161"></p><p>可以看到，分别在东、南、西、北、中心位置都可以添加组件，组件的大小会被自动调整，并且随着我们的窗口大小变化，组件的大小也会跟着自动调整，是不是感觉挺方便的？边界布局的性质：</p><ul><li>BorderLayout布局的容器某个位置的某个组件会直接充满整个区域。</li><li>如果在某个位置重复添加组件，只有最后一个添加的组件可见。</li><li>缺少某个位置的组件时，其他位置的组件会延伸到该位置。</li></ul><p>我们还可以调整组件之间的间距：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BorderLayout</span> <span class="hljs-variable">borderLayout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BorderLayout</span>();<br>borderLayout.setHgap(<span class="hljs-number">50</span>);   <span class="hljs-comment">//Hgap是横向间距</span><br>borderLayout.setVgap(<span class="hljs-number">50</span>);   <span class="hljs-comment">//Vgap是纵向间距</span><br></code></pre></td></tr></table></figure><p>调整之后，边距就非常明显了：</p><p><img src="https://s2.loli.net/2022/10/28/XQqnd6GHa7hVOtR.png" alt="image-20221028143042506"></p><p>我们接着来认识一下下一个布局，FlowLayout 流式布局，流式布局实际上就是按顺序排列的一种布局：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());   <span class="hljs-comment">//采用流式布局</span><br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;1号按钮&quot;</span>));<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;2号按钮&quot;</span>));<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;3号按钮&quot;</span>));<br></code></pre></td></tr></table></figure><p>采用流式布局后，按钮会根据内容大小，自动调整为对应的大小，并且他们之间是有间距的：</p><p><img src="https://s2.loli.net/2022/10/28/471ED3GaefjzHy8.png" alt="image-20221028142144585"></p><p>当我们对窗口大小进行调整时，流式布局也会进行自动调整：</p><p><img src="https://s2.loli.net/2022/10/28/hJrBtcVj7MDGqfw.png" alt="image-20221028142326191"></p><p>我们也可以在设定流式布局时指定对齐模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>(FlowLayout.RIGHT));   <span class="hljs-comment">//指定为右对齐</span><br></code></pre></td></tr></table></figure><p>对齐方式会直接决定组件的排列方式：</p><p><img src="https://s2.loli.net/2022/10/28/QlU8IPoVA2j4E6t.png" alt="image-20221028142506961"></p><p>我们同样可以使用Hgap和Vgap来调整组件之间的间距：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FlowLayout</span> <span class="hljs-variable">flowLayout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>();<br>flowLayout.setHgap(<span class="hljs-number">50</span>);<br>flowLayout.setVgap(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/28/vVN4O8XynAdW5Jb.png" alt="image-20221028143230216"></p><p>我们接着来看卡片布局，CardLayout对象将卡片作为一个容器中的每个组件，这个卡片布局怎么说呢，有点像iOS14新出的叠放小组件（安卓应该也有）就像很多张卡片叠在一起，每次只能看到最顶上的这张卡片，但是我们可以将下层的卡片切到顶上来：</p><p><img src="https://s2.loli.net/2022/10/28/CqE9FkVSMJXOLY8.png" alt="image-20221028143949323"></p><p>卡片布局就是这样，我们可以添加多个组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CardLayout</span> <span class="hljs-variable">layout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CardLayout</span>();<br>frame.setLayout(layout);<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;我是1号&quot;</span>));<br>frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;我是2号&quot;</span>));<br><br>frame.setVisible(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    Thread.sleep(<span class="hljs-number">3000</span>);<br>    layout.next(frame);    <span class="hljs-comment">//我们需要使用CardLayout对象来进行切换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们每三秒钟切换一次卡片，可以看到我们添加的标签每三秒就会变化一次，实际上我们可以利用卡片布局来做一个类似跑马灯的效果，是不是感觉很神奇？</p><p>我们接着来看网格布局，GridLayout以矩形网格的形式对组件进行管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(i + <span class="hljs-string">&quot;号按钮&quot;</span>));<br></code></pre></td></tr></table></figure><p>这种布局就很好理解了，默认情况下会生成一行按格子划分的相等区域：</p><p><img src="https://s2.loli.net/2022/10/28/joR1s467rFzJqOE.png" alt="image-20221028145118733"></p><p>我们也可以手动指定行数和列数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GridLayout</span> <span class="hljs-variable">gridLayout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>();<br>gridLayout.setRows(<span class="hljs-number">2</span>);<br>frame.setLayout(gridLayout);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>    frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(i + <span class="hljs-string">&quot;号按钮&quot;</span>));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/28/DtnRaCJh7qzc4w3.png" alt="image-20221028145330522"></p><p>所有的组件都会整齐排列在网格中。</p><p>最后一种布局是GridBagLayout，是最灵活的布局管理器，它同样是按照网格进行划分，但是一个组件可以同时占据多个网格。这种情况其实也是经常会出现的，比如计算器上的按钮虽然看起来也是按照网格排列的，但是有些按钮同时占据了横向或是纵向的两个网格，这种情况使用GridBagLayout布局就可以很好的处理：</p><p><img src="https://s2.loli.net/2022/10/28/JNmjEVWIG2nkxbf.png" alt="image-20221028145752545"></p><p>虽然这个布局很强大，但是用起来也是很麻烦的，所以说这里就不做讲解了，感兴趣的小伙伴可以自行了解。</p><p>虽然认识了这么多的布局，但是我们发现，很多应用程序并不只是由单一的布局组成的，而是多种布局相互嵌套的结果，比如我们的IDEA界面，就不仅仅是一个布局完成的（这里只是举个例子）而是多种布局在嵌套使用：</p><p><img src="https://s2.loli.net/2022/10/28/9ZfvOxThctdPS6N.png" alt="image-20221028151242522"></p><p>但是只有我们的窗口才能设置布局啊，总不可能让多个窗口拼接在一起吧？实际上除了窗口可以作为容器之外，我们也可以使用其他的容器，这时，我们就需要用到面板。</p><p>类面板是最简单的容器类，它跟窗口一样，可以提供一个空间，同样可以随意添加组件到面板中，只不过面板本身也是一个组件，所以说面板是可以放到其他容器中的容器，就像：</p><p><img src="https://s2.loli.net/2022/10/28/jVGTNmd3i2ZRg5h.png" alt="image-20221028151701189"></p><p><img src="https://s2.loli.net/2022/10/28/6PGem8qMrV7NOZS.png" alt="image-20221028151845514"></p><p>面板本身也是容器，所以说也可以单独设置面板内部的布局，比如现在我们想要分两个区域，上半部分区域是流式布局，下半部分区域采用网格布局，那么我们就可以先将窗口采用网格布局，并在上下各添加一个面板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GridLayout</span> <span class="hljs-variable">layout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>();   <span class="hljs-comment">//先设置整个窗口的布局</span><br>layout.setRows(<span class="hljs-number">2</span>);     <span class="hljs-comment">//设置行数为2，一会就会分成两行了</span><br>frame.setLayout(layout);<br><br><span class="hljs-type">Panel</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();     <span class="hljs-comment">//接着我们创建一下上半部分的面板和下半部分的面板</span><br>top.setBackground(Color.PINK);   <span class="hljs-comment">//添加一个背景颜色方便区分</span><br>frame.add(top);<br><br><span class="hljs-type">Panel</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();<br>bottom.setBackground(Color.ORANGE);<br>frame.add(bottom);<br></code></pre></td></tr></table></figure><p>这样，我们的两个面板就按照网格布局，被分成了上下两部分：</p><p><img src="https://s2.loli.net/2022/10/28/agMjZkqrSGUm9Ld.png" alt="image-20221028152352861"></p><p>接着我们就可以分别在上半部分的面板和下半部分的面板中进行单独配置了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Panel</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();<br>top.setBackground(Color.PINK);<br>top.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowLayout</span>());    <span class="hljs-comment">//面板默认会采用FlowLayout，所以说这里指不指定都一样</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)    <span class="hljs-comment">//面板就像窗口一样，可以设定布局和添加组件</span><br>    top.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;流式&quot;</span>+i));<br>frame.add(top);<br><br><span class="hljs-type">Panel</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();<br>bottom.setBackground(Color.ORANGE);<br>bottom.setLayout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>());   <span class="hljs-comment">//下半部分我们采用网格布局</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    bottom.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;网格&quot;</span>+i));<br>frame.add(bottom);<br></code></pre></td></tr></table></figure><p>这里我们将上半部分面板设定为流式布局，下半部分面板设定为网格布局：</p><p><img src="https://s2.loli.net/2022/10/28/RbiFpTDCEaN5fPl.png" alt="image-20221028152617119"></p><p>利用面板，我们就可以实现各种布局的自由组合，当然，面板在后面还会有更多的用处。</p><h3 id="滚动面板和列表"><a href="#滚动面板和列表" class="headerlink" title="滚动面板和列表"></a>滚动面板和列表</h3><p>有些时候，我们的窗口大小可能并不能完全显示内部的内容，比如出现了一张很大的图片。</p><p><img src="https://s2.loli.net/2022/10/28/7mKakMLhz95VbIp.png" alt="image-20221028153201386"></p><p>此时就会出现滚动条来让我们进行拖拽，这样就可以向下滑动查看没有完全展示出来的内容了。而我们之前开发的程序都没办法做到这样的滚动，超出部分会直接无法显示。</p><p>AWT也为我们提供了滚动面板组件，滚动面板也是一个容器，但是我们无法修改它的布局，它只能容纳单个组件，比如展示一个图片、或者是列表等，我们也可以将其与Panel配合使用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScrollPane</span> <span class="hljs-variable">scrollPane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollPane</span>();   <span class="hljs-comment">//创建滚动面板</span><br>frame.add(scrollPane);<br><br><span class="hljs-type">GridLayout</span> <span class="hljs-variable">layout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GridLayout</span>();    <span class="hljs-comment">//创建滚动面板内部的要展示的面板</span><br>layout.setRows(<span class="hljs-number">20</span>);<br><span class="hljs-type">Panel</span> <span class="hljs-variable">panel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Panel</span>();<br>panel.setLayout(layout);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    panel.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;我是按钮&quot;</span>+i));   <span class="hljs-comment">//为面板添加按钮</span><br>scrollPane.add(panel);<br></code></pre></td></tr></table></figure><p>可以看到，无法显示的部分会自动变成滚动面板，我们滑动就可以展示了：</p><p><img src="https://s2.loli.net/2022/10/28/ZDa92CJVf7TbGk4.png" alt="image-20221028155050727"></p><p>这里需要特别提一下，我们看到这里的按钮大小采用的是自动生成的大小，但是如果我们希望按钮的大小按照我们喜欢的来怎么办呢？我们知道，使用布局之后，组件的大小实际上是自动决定的，只有未使用布局的情况下才能自由更改组件大小，那么我们怎么才能干预呢？我们可以为组件设定一个建议的大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>    <span class="hljs-type">Button</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;我是按钮&quot;</span> + i);<br>    button.setPreferredSize(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dimension</span>(<span class="hljs-number">100</span>, <span class="hljs-number">50</span>));   <span class="hljs-comment">//设置首选大小</span><br>    panel.add(button);<br>&#125;<br></code></pre></td></tr></table></figure><p>当布局管理器在自动调整内部组件大小时，如果不是必须要按照布局大小来展示或者是高度或宽度不确定，那么就会采用我们建议的大小展示，比如这里只能确定宽度，而高度是不确定的，那么就可以使用我们建议的大小来展示：</p><p><img src="https://s2.loli.net/2022/10/28/SQZapDy6vdLkHNx.png" alt="image-20221028155443331"></p><p>当然，首选大小可能不太好理解，还需要各位小伙伴多多尝试才能理解。</p><p>实际上滚动面板的最佳搭档就是List列表（注意这里的列表不是我们集合类里面学习的列表，而是展示出来的列表组件）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>();   <span class="hljs-comment">//注意是awt包下的List，别导错了</span><br>list.add(<span class="hljs-string">&quot;小糍粑&quot;</span>);<br>list.add(<span class="hljs-string">&quot;锅巴洋芋&quot;</span>);<br>list.add(<span class="hljs-string">&quot;手抓饼&quot;</span>);<br>list.add(<span class="hljs-string">&quot;凉面&quot;</span>);<br>list.setMultipleMode(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//是否开启多选模式</span><br></code></pre></td></tr></table></figure><p>列表组件就像是一个选择列表一样：</p><p><img src="https://s2.loli.net/2022/10/28/ieDtpQqdkBzhsKF.png" alt="image-20221028160340931"></p><p>列表会将元素依次展示出来，我们可以选择列表中的某一项：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.addItemListener(System.out::println);<br></code></pre></td></tr></table></figure><p>列表可以添加监听器，当我们选择某个物品时，就会自动触发：</p><p><img src="https://s2.loli.net/2022/10/28/LXIvYhnFVBlQTGt.png" alt="image-20221028160611113"></p><p>列表就很时候拿来做文件列表。</p><h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p>前面我们认识了各种各样的组件，我们接着来看菜单，实际上各位小伙伴会发现我们的程序上方一般都会有一排菜单：</p><p><img src="https://s2.loli.net/2022/10/28/Konar26QHWMTwqd.png" alt="image-20221028161209224"></p><p>在MacOS下是整合到状态栏中的：</p><p><img src="https://s2.loli.net/2022/10/28/G3NiRaBMkJLneVl.png" alt="image-20221028161239672"></p><p>这些菜单一般都会包含我们程序中的一些基本操作，实际上我们的程序中很多地方都会使用到下拉菜单：</p><p><img src="https://s2.loli.net/2022/10/28/hc354p1ri6NmGgA.png" alt="image-20221028161118028"></p><p>而我们编写AWT程序也可以添加这样的菜单，只需要为窗口设定一个菜单栏即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MenuBar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuBar</span>();    <span class="hljs-comment">//创建菜单栏 </span><br><span class="hljs-type">Menu</span> <span class="hljs-variable">menu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Menu</span>(<span class="hljs-string">&quot;我是1号菜单&quot;</span>);<br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;测试1&quot;</span>));<br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;测试2&quot;</span>));<br>bar.add(menu);<br>frame.setMenuBar(bar);    <span class="hljs-comment">//为窗口设定刚刚定义好的菜单栏</span><br></code></pre></td></tr></table></figure><p>设定好MenuBar之后，我们的程序就有菜单了：</p><p><img src="https://s2.loli.net/2022/10/28/wIWdRo2velTj1VS.png" alt="image-20221028161741397"></p><p>虽然有点丑，但是确实是内味，不过还是MacOS下好看：</p><p><img src="https://s2.loli.net/2022/10/28/7Dq6L1hbreYIy39.png" alt="image-20221028161910928"></p><p>我们着重来看一下MenuItem，这是我们菜单的每一个选项，我们可以为其添加监听器来监听用户是否点击：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MenuItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;测试1&quot;</span>);<br>item.addActionListener(e -&gt; System.out.println(<span class="hljs-string">&quot;一号选项被点击了！&quot;</span>));<br>menu.add(item);<br></code></pre></td></tr></table></figure><p>其实跟我们之前学习的按钮是差不多的：</p><p><img src="https://s2.loli.net/2022/10/28/KskDE9J2QdRtlvV.png" alt="image-20221028162602244"></p><p>我们还可以为菜单中的选项设定快捷键：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MenuItem</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;测试1&quot;</span>);<br>item.setShortcut(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuShortcut</span>(<span class="hljs-string">&#x27;A&#x27;</span>));   <span class="hljs-comment">//MenuShortcut就是指定快捷键组合，默认情况下是Ctrl+指定按键</span><br><span class="hljs-comment">//item.setShortcut(new MenuShortcut(&#x27;A&#x27;, true));   //第二个参数指定为true表示需要Ctrl+Shift+指定按键</span><br></code></pre></td></tr></table></figure><p>这里的效果就是Ctrl+A触发快捷键：</p><p><img src="https://s2.loli.net/2022/10/30/lwrjgRxu46UXHZk.png" alt="image-20221030173320786"></p><p>当然，除了这种普通的菜单选项之外，还有可以勾选的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckboxMenuItem</span>(<span class="hljs-string">&quot;测试2&quot;</span>));<br></code></pre></td></tr></table></figure><p>CheckboxMenuItem是可以勾选的选项，它能够对状态进行记录，我们点击选项之后会变成勾选状态：</p><p><img src="https://s2.loli.net/2022/10/28/Q1RgUn7ejZXzH5E.png" alt="image-20221028162655033"></p><p>实际上要添加这样的菜单栏还是挺简单的的，我们接着来看弹出菜单，弹出菜单其实也经常出现，比如我们要新建一个类，我们就可以右键对应的包：</p><p><img src="https://s2.loli.net/2022/10/28/IKe1NL5wm834WdP.png" alt="image-20221028214019648"></p><p>弹出一个浮在窗口之上的，并且可以进行选择的菜单，这个就是弹出菜单。</p><p>比如我们想要实现右键窗口任意位置都弹出菜单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PopupMenu</span> <span class="hljs-variable">menu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PopupMenu</span>();    <span class="hljs-comment">//创建弹出菜单</span><br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;选项1&quot;</span>));   <span class="hljs-comment">//每一个选项依然是使用MenuItem</span><br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MenuItem</span>(<span class="hljs-string">&quot;选项2&quot;</span>));<br>frame.add(menu);    <span class="hljs-comment">//注意，弹出菜单也要作为组件加入到窗口中（但是默认情况下不显示）</span><br><br>frame.addMouseListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mousePressed</span><span class="hljs-params">(MouseEvent e)</span> &#123; <br>        <span class="hljs-keyword">if</span> (e.getButton() == MouseEvent.BUTTON3) &#123;  <span class="hljs-comment">//监听鼠标右键</span><br>            menu.show(frame, e.getX(), e.getY());   <span class="hljs-comment">//要展示弹出菜单，我们只需要调用show方法即可</span><br>          <span class="hljs-comment">//注意，第一个参数必须是弹出菜单所加入的窗口或是窗口中的任意一个组件</span><br>          <span class="hljs-comment">//后面的坐标就是相对于这个窗口或是组件的原点（左上角）这个位置进行弹出</span><br>          <span class="hljs-comment">//我们这里写的就是相对于当前窗口的左上角，鼠标点击位置的x、y位置弹出窗口</span><br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们来看看实际效果吧：</p><p><img src="https://s2.loli.net/2022/10/28/tMRbdjE6ZhHuPaQ.png" alt="image-20221028215651667"></p><p>这样，我们就可以设计出更加高级的程序了。</p><h3 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h3><p>有些时候，我们点击关闭按钮之后，窗口并不会直接关闭，而是会弹出一个对话框询问我们是否要退出，比如我们使用记事本编辑完之后未保存就关闭记事本，就会提示我们：</p><p><img src="https://s2.loli.net/2022/10/28/VUshJzZXxC51gpb.png" alt="image-20221028220721666"></p><p>实际上像这样弹出的的一个对话框，在很多时候都很关键，我们也可以使用AWT为我们提供的对话框，比如我们现在希望在关闭窗口时询问我们是否真的要关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dialog</span>(frame, <span class="hljs-string">&quot;我是对话框&quot;</span>, <span class="hljs-literal">true</span>);   <br><span class="hljs-comment">//第一个参数是父窗口或是父对话框（没错，对话框也可以由对话框唤起）</span><br><span class="hljs-comment">//最后一个参数是当对话框展示时，是否让父窗口（对话框）无法点击</span><br>dialog.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">80</span>);<br><br>frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>        dialog.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>当我们点击关闭时：</p><p><img src="https://s2.loli.net/2022/10/28/VmajcUlSD6GPsrv.png" alt="image-20221028223431754"></p><p>可以看到这里确实弹出了一个对话框（这个对话框无法最小化到图标）也就是说我们只能通过操作对话框来关闭它。</p><p>只不过就单单是这样的一个对话框太过单调了，我们可以为其添加一些按钮之类的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Dialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dialog</span>(frame, <span class="hljs-string">&quot;我是对话框&quot;</span>, <span class="hljs-literal">true</span>);<br>dialog.setResizable(<span class="hljs-literal">false</span>);<br>dialog.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Label</span>(<span class="hljs-string">&quot;确定是否要退出程序？&quot;</span>), BorderLayout.NORTH);   <span class="hljs-comment">//对话框默认采用的是边界布局</span><br>dialog.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;取消&quot;</span>), BorderLayout.WEST);<br>dialog.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;不退出&quot;</span>), BorderLayout.EAST);<br>dialog.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">80</span>);<br></code></pre></td></tr></table></figure><p>这样我们退出时，就有对应的提示了：</p><p><img src="https://s2.loli.net/2022/10/28/3v7ZJio9mMnK8zk.png" alt="image-20221028224410637"></p><p>对话框就像一个特殊的窗口一样，各位小伙伴可以自由发挥。</p><p>有些时候我们在使用应用程序的时候，可能需要我们去选择电脑上的一些文件，这个时候我们就可以使用文件对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileDialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileDialog</span>(frame, <span class="hljs-string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);  <span class="hljs-comment">//选择文件对话框类型，可以是加载文件或是保存文件</span><br><br>frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>        dialog.setVisible(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>文件对话框是根据操作系统提供的文件选择器决定的：</p><p><img src="https://s2.loli.net/2022/10/28/TuHNLsmokZvMhIR.png" alt="image-20221028224815769"></p><p>我们可以通过文件对话框选择一个文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileDialog</span> <span class="hljs-variable">dialog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileDialog</span>(frame, <span class="hljs-string">&quot;请选择一个文件&quot;</span>, FileDialog.LOAD);<br><br>frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>        dialog.setVisible(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//注意，需要将对话框展示出来之后，才能进行选择</span><br>      <span class="hljs-comment">//选择完成之后getDirectory和getFile方法就可以返回结果了，否则会阻塞</span><br>        System.out.println(<span class="hljs-string">&quot;选择的文件为：&quot;</span>+dialog.getDirectory() + dialog.getFile());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>选择文件之后，我们可以通过对话框直接获取到对应的文件：</p><p><img src="https://s2.loli.net/2022/10/28/uRjWKPgFxCcGUvr.png" alt="image-20221028225343739"></p><p>是不是感觉还是挺简单的？</p><h3 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h3><p>除了使用官方提供的这些组件之外，我们也可以自己创建一些组件来使用，比如官方没有提供图片组件，我们可以自己编写一个图片组件用于在窗口中展示我们的图片。</p><p>要自己编写一个组件，需要完成下面的步骤：</p><ul><li>必须继承自Component类，表示这是一个AWT组件。</li><li>需要自己实现<code>paintComponent</code>方法，这个方法就是组件的绘制方法，最终绘制出来的结果就是展示出来的结果了。</li></ul><p>首先我们先把最简单的事情做了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;   <span class="hljs-comment">//继承自Component表示是一个组件</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageView</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;    <span class="hljs-comment">//重写paint方法，这个方法就是组件的绘制方法</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以先创建一个这个组件并放到我们的窗口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ImageView</span>()); <br></code></pre></td></tr></table></figure><p>这里用的是边界布局，默认情况下组件会被添加到中心，占满整个窗口。但是由于我们并没有编写任何绘制内容，所以说组件是空白的一片。</p><p>我们来看看这个<code>paint</code>方法该如何重写，这个方法实际上是在窗口绘制时自动调用，那么到底什么是绘制呢？实际上绘制就是需要我们进行画图操作，当窗口首次展示或是修改大小时就会调用这个方法绘制组件（使用过OpenGL的小伙伴应该能够很容易上手）</p><p>这个方法给了我们一个Graphics对象，实际上这个对象就是我们用于绘制图形的工具，比如我们这个组件需要绘制的是一个矩形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;   <span class="hljs-comment">//各位小伙伴可以将Graphics看做一只画笔，我们想让画笔做什么就做什么</span><br>    g.setColor(Color.BLACK);      <span class="hljs-comment">//我们可以先将画笔切换为黑色</span><br>    g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), getHeight());   <span class="hljs-comment">//drawRect就是绘制矩形区域，这里的x和y是相对于当前组件的位置来的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看最后会绘制成啥样：</p><p><img src="https://s2.loli.net/2022/10/28/qQweM6DprRJjCl7.png" alt="image-20221028232701565"></p><p>可以看到整个组件都被涂成了黑色，我们还可以绘制更多好玩的图形：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>    g.setColor(Color.BLACK);<br>    g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), getHeight());<br>    g.setColor(Color.RED);    <span class="hljs-comment">//画笔改成红色</span><br>  <span class="hljs-comment">//在中间画个圆角矩形边框</span><br>    g.drawRoundRect(getWidth() / <span class="hljs-number">4</span>, getHeight() / <span class="hljs-number">4</span>, getWidth() / <span class="hljs-number">2</span>, getHeight() / <span class="hljs-number">2</span>, <span class="hljs-number">30</span>, <span class="hljs-number">30</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的效果就是这样了：</p><p><img src="https://s2.loli.net/2022/10/28/xBsuijLa6beOwJy.png" alt="image-20221028233307877"></p><p>是不是感觉还挺好玩的，就像我们在玩画画游戏一样。这里列一下Graphics接口提供的所有功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Graphics</span> &#123;<br>   <span class="hljs-comment">//移动画笔原点到指定坐标，默认是(0,0)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">translate</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>    <span class="hljs-comment">//设定画笔颜色</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(Color c)</span>;<br>    <span class="hljs-comment">//设置为普通绘画模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPaintMode</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//交替颜色模式，比较高级，小伙伴自行了解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXORMode</span><span class="hljs-params">(Color c1)</span>;<br>    <span class="hljs-comment">//设置字体，绘制文本内容时就按照这个字体来绘制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFont</span><span class="hljs-params">(Font font)</span>;<br><br>    <span class="hljs-comment">//设置裁剪区域，一旦设置裁剪区域，那么裁剪区域以外的地方即使绘制，也不会生效，绘制</span><br>  <span class="hljs-comment">//只会在裁剪区域内生效（有点像图层蒙版？）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClip</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-comment">//设定自定义形状的裁剪区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setClip</span><span class="hljs-params">(Shape clip)</span>;<br><br>    <span class="hljs-comment">//拷贝指定区域的内容到另一个位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">copyArea</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                  <span class="hljs-type">int</span> dx, <span class="hljs-type">int</span> dy)</span>;<br>    <span class="hljs-comment">//绘制直线</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawLine</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span>;<br>    <span class="hljs-comment">//填充矩形区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-comment">//绘制矩形边框</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br><span class="hljs-comment">//绘制圆角矩形边框</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRoundRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                       <span class="hljs-type">int</span> arcWidth, <span class="hljs-type">int</span> arcHeight)</span>;<br>    <span class="hljs-comment">//填充圆角矩形区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillRoundRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                       <span class="hljs-type">int</span> arcWidth, <span class="hljs-type">int</span> arcHeight)</span>;<br>    <span class="hljs-comment">//绘制3D矩形边框（其实就是加了个深色和浅色边框，有一个视觉效果罢了）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw3DRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> raised)</span>;<br>    <span class="hljs-comment">//填充3D矩形区域（同上）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill3DRect</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                           <span class="hljs-type">boolean</span> raised)</span>;<br>    <span class="hljs-comment">//绘制椭圆形边框</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawOval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-comment">//填充椭圆形区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillOval</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height)</span>;<br>    <span class="hljs-comment">//绘制弧线边框</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawArc</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> startAngle, <span class="hljs-type">int</span> arcAngle)</span>;<br><span class="hljs-comment">//填充扇形区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillArc</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> startAngle, <span class="hljs-type">int</span> arcAngle)</span>;<br>    <span class="hljs-comment">//绘制折线（需要提供多个坐标）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawPolyline</span><span class="hljs-params">(<span class="hljs-type">int</span> xPoints[], <span class="hljs-type">int</span> yPoints[],</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> nPoints)</span>;<br><span class="hljs-comment">//绘制多边形边框</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawPolygon</span><span class="hljs-params">(<span class="hljs-type">int</span> xPoints[], <span class="hljs-type">int</span> yPoints[],</span><br><span class="hljs-params">                                     <span class="hljs-type">int</span> nPoints)</span>;<br>    <span class="hljs-comment">//填充多边形区域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPolygon</span><span class="hljs-params">(<span class="hljs-type">int</span> xPoints[], <span class="hljs-type">int</span> yPoints[],</span><br><span class="hljs-params">                                     <span class="hljs-type">int</span> nPoints)</span>;<br>    <span class="hljs-comment">//绘制文本</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawString</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br>   <span class="hljs-comment">//绘制图片（绘制大小为图片原本大小）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>   <span class="hljs-comment">//绘制按自定义大小缩放后的图片</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>    <span class="hljs-comment">//绘制图片时如果是透明部分则采用背景颜色填充</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,</span><br><span class="hljs-params">                                      Color bgcolor,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>    <span class="hljs-comment">//绘制按自定义大小缩放后带背景颜色的图片</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> width, <span class="hljs-type">int</span> height,</span><br><span class="hljs-params">                                      Color bgcolor,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>    <span class="hljs-comment">//对原本的图片按照起始坐标和尺寸进行裁剪后，再以给定大小绘制到给定位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> dx1, <span class="hljs-type">int</span> dy1, <span class="hljs-type">int</span> dx2, <span class="hljs-type">int</span> dy2,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> sx1, <span class="hljs-type">int</span> sy1, <span class="hljs-type">int</span> sx2, <span class="hljs-type">int</span> sy2,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>    <span class="hljs-comment">//累了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">drawImage</span><span class="hljs-params">(Image img,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> dx1, <span class="hljs-type">int</span> dy1, <span class="hljs-type">int</span> dx2, <span class="hljs-type">int</span> dy2,</span><br><span class="hljs-params">                                      <span class="hljs-type">int</span> sx1, <span class="hljs-type">int</span> sy1, <span class="hljs-type">int</span> sx2, <span class="hljs-type">int</span> sy2,</span><br><span class="hljs-params">                                      Color bgcolor,</span><br><span class="hljs-params">                                      ImageObserver observer)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里要实现的时绘制一个图片，那么我们就可以像这样编写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Component</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Image image;   <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ImageView</span><span class="hljs-params">(String filename)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(filename);<br>        image = ImageIO.read(file);   <span class="hljs-comment">//我们可以使用ImageIO类来快速将图片文件读取为Image对象</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>      <span class="hljs-comment">//绘制图片需要提供Image对象</span><br>        g.drawImage(image, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), getHeight(), <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试看效果吧：</p><p><img src="https://s2.loli.net/2022/10/28/5adDsGr2iRxywCX.png" alt="image-20221028235756338"></p><p>可以看到图片成功绘制出来了，这样，我们就提供自己编写绘制逻辑，成功完成了一个简单的自定义组件。</p><p>当然，现在我们讲了如何加载图片，顺便把设定自定义的程序图标介绍一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ImageIO.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.png&quot;</span>));<br>frame.setIconImage(image);<br></code></pre></td></tr></table></figure><p>注意，在MacOS下这样写没用，得用专用的增强包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Image</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> ImageIO.read(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.png&quot;</span>));<br>Application.getApplication().setDockIconImage(image);<br></code></pre></td></tr></table></figure><p>这样，我们的程序就会显示为我们自己定义的图标了。</p><h3 id="窗口修饰和自定义形状"><a href="#窗口修饰和自定义形状" class="headerlink" title="窗口修饰和自定义形状"></a>窗口修饰和自定义形状</h3><p>实际上我的窗口在默认情况下都是处于修饰状态，那么什么是修饰状态呢？</p><p>窗口修饰实际上就是我们窗口外面添加的边框：</p><p><img src="https://s2.loli.net/2022/10/26/fMQDFCmyqIvJeTl.png" alt="image-20221026164200924"></p><p>有些时候，可能我们并不需要系统为我们提供的窗口边框，我们希望能够自己编写窗口的边框，包括各种按钮等，此时我们就可以将窗口设定为非修饰状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>    frame.setUndecorated(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//将窗口设定为非修饰状态</span><br>    frame.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>非修饰状态下，就只有一个窗口本身了：</p><p><img src="https://s2.loli.net/2022/10/29/u9jSlmAc2GXr4VJ.png" alt="image-20221029111107959"></p><p>并且这个窗口是无法完成拖拽操作的，要实现拖拽还得我们自己编写（太原始了）可以看到，在默认情况下窗口的形状是一个方形的，我们可以将其调整为其他形状：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>    frame.setUndecorated(<span class="hljs-literal">true</span>);<br>    frame.setSize(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br>  <span class="hljs-comment">//注意，只有窗口在非修饰状态下才能设定形状</span><br>  <span class="hljs-comment">//这里我们使用圆角矩形，形状最好跟窗口大小一样</span><br>    frame.setShape(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RoundRectangle2D</span>.Double(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>));<br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们的窗口变成了这样：</p><p><img src="https://s2.loli.net/2022/10/29/areQf2g3I74mlpV.png" alt="image-20221029111439062"></p><p>变成了好看的圆角矩形（但是这个圆角处理得不太好，有点毛毛糙糙的）圆角矩形也是现代操作系统窗口的设计语言。</p><p>我们也可以自行为窗口添加标题栏，同样只需要重写一下<code>paint</code>方法自行绘制就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Frame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Frame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>) &#123;    <span class="hljs-comment">//使用匿名内部类（或者自己写个子类也行）</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g)</span> &#123;<br>        g.setColor(Color.LIGHT_GRAY);<br>        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, getWidth(), <span class="hljs-number">28</span>);   <span class="hljs-comment">//先绘制标题栏</span><br>        g.setColor(Color.BLACK); <br>        g.drawString(getTitle(), getWidth() / <span class="hljs-number">2</span>, <span class="hljs-number">20</span>);   <span class="hljs-comment">//绘制标题名称</span><br>        <span class="hljs-built_in">super</span>.paint(g);   <span class="hljs-comment">//原本的绘制别覆盖了，该怎么做还要怎么做</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来看看效果吧：</p><p><img src="https://s2.loli.net/2022/10/29/hQ2YLjSgazM9Wkd.png" alt="image-20221029112035219"></p><p>是不是感觉不依靠操作系统，我们自己也能写一个好看的窗口出来了？</p><p>只不过这个窗口还不能拖动，我们来实现一下按住标题栏就可以拖动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">frame.addMouseMotionListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MouseMotionAdapter</span>() &#123;   <span class="hljs-comment">//只需要写一个监听器就可以搞定了</span><br>    <span class="hljs-type">int</span> oldX, oldY;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseDragged</span><span class="hljs-params">(MouseEvent e)</span> &#123;   <span class="hljs-comment">//鼠标拖动时如果是标题栏，就将窗口位置修改</span><br>        <span class="hljs-keyword">if</span>(e.getY() &lt;= <span class="hljs-number">28</span>)<br>            frame.setLocation(e.getXOnScreen() - oldX, e.getYOnScreen() - oldY);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseMoved</span><span class="hljs-params">(MouseEvent e)</span> &#123;   <span class="hljs-comment">//记录上一次的鼠标位置</span><br>        oldX = e.getX();<br>        oldY = e.getY();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>至此，有关AWT相关的内容，我们就讲解到这里，相信各位小伙伴肯定已经跃跃欲试想要开发一个自己的桌面应用程序了。只不过很遗憾，Java官方并没有再对AWT相关内容进行维护，因为AWT采用的是取不同操作系统交集策略，因为有些功能只有部分操作系统才有，这就导致很多功能都被砍掉，维护起来也很困难。下节课开始，我们会继续介绍Swing相关组件。</p><hr><h2 id="Swing组件介绍"><a href="#Swing组件介绍" class="headerlink" title="Swing组件介绍"></a>Swing组件介绍</h2><p>前面我们介绍了AWT，通过Java官方为我们提供的GUI框架，我们就可以编写出自己的桌面应用程序了，现在各位小伙伴应该已经有着良好的图形化界面开发基础了。</p><p>而Swing组件才是我们要学习的重点内容，它也是一套GUI框架，但是它是基于AWT编写的上层框架。</p><blockquote><p>Swing 是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT 所能够提供的所有功能，并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充。例如说并不是所有的操作系统都提供了对树形控件的支持， Swing 利用了AWT 中所提供的基本作图方法对树形控件进行模拟。由于 Swing 控件是用100%的Java代码来实现的，因此在一个平台上设计的树形控件可以在其他平台上使用。由于在Swing 中没有使用本地方法来实现图形功能，我们通常把Swing控件称为轻量级控件。</p></blockquote><p>其实简单来说，这玩意就是AWT那一套东西的扩展，或者说是强化版，很多东西还是沿用的AWT中的。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>我们来看看如何使用Swing编写桌面程序，首先还是最重要的窗口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);   <span class="hljs-comment">//Swing中的窗口叫做JFrame，对应的就是AWT中的Frame</span><br>    <span class="hljs-comment">//它实际上就是Frame的子类，所以说我们之前怎么用的，现在怎么用就行了</span><br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉学会AWT之后再看Swing也太简单了？</p><p>当然，既然是AWT的扩展，那肯定是有更多的新增功能的，比如我们之前想要实现点击X号关闭Java程序，这里我们只需要使用一个方法就可以设定了，不需要我们自己去写监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们可以直接为窗口设定关闭操作，JFrame已经为我们预设好了一些常用的操作了</span><br>frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  <span class="hljs-comment">//EXIT_ON_CLOSE就是直接退出程序，默认是只隐藏</span><br></code></pre></td></tr></table></figure><p>Swing为我们提供了所有原本AWT中的组件的升级版，他们的名字前面都加上了J，比如按钮组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>    frame.setLayout(<span class="hljs-literal">null</span>);<br>    <span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;Link Start&quot;</span>);  <span class="hljs-comment">//Button组件对应的就是JButton了</span><br>    button.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>);<br>    frame.add(button);<br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Swing不像AWT那样，平台组件长啥样，就用什么，它的组件都是自行绘制的：</p><p><img src="https://s2.loli.net/2022/10/29/dy6R2VNuOYIJamA.png" alt="image-20221029120313940"></p><p>这样，我们在不同的平台上，看到的组件UI样式，都会是一样的，不会出现长得不一样的情况。并且我们可以为组件自由替换皮肤，我们会在后面进行介绍。</p><p>还有，Swing在没有设定布局时，组件的坐标原点并不是窗口的左上角，而是窗口标题栏下方的左上角：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>frame.setLayout(<span class="hljs-literal">null</span>);<br>frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);<br><br><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;我是按钮&quot;</span>);<br>button.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br><br>frame.add(button);<br>frame.setVisible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/RMJWl576CiSDs8b.png" alt="image-20221105171035570"></p><p>这一点确实比AWT好很多，不然咱都不知道不同平台的标题栏到底是多高。至于为什么是这样，这是因为JFrame内部实际上单独维护了一个面板来存放组件，很多操作都被重定向给了内部的面板，这里就不深入说了，知道就行。</p><p>同样的，如果我们要使用菜单，直接使用对应的类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br><span class="hljs-type">JMenuBar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuBar</span>();    <span class="hljs-comment">//JMenuBar对应的就是MenuBar</span><br><span class="hljs-type">JMenu</span> <span class="hljs-variable">menu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenu</span>(<span class="hljs-string">&quot;我是菜单&quot;</span>);<br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;选项1&quot;</span>));<br>menu.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JMenuItem</span>(<span class="hljs-string">&quot;选项2&quot;</span>));<br>bar.add(menu);<br>frame.setJMenuBar(bar);<br>frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>frame.setVisible(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>这个菜单也是Swing自己绘制的，如果是AWT的话，不同系统菜单位置还不一样，虽然这里是自己画的，但是效果看着还行：</p><p><img src="https://s2.loli.net/2022/10/29/aMGHTu8sl2Sg4vm.png" alt="image-20221029120737715"></p><p>所以，Swing相关组件在使用上其实和我们之前学习的AWT是差不多的，只要前面AWT学的没问题，这里简直So Easy。</p><p>因为Swing是沿用的AWT框架体系，所以说AWT提供的旧组件，也是可以用的，但是这里不推荐：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>    frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>    frame.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Button</span>(<span class="hljs-string">&quot;我是按钮&quot;</span>));   <span class="hljs-comment">//可以继续使用AWT组件，但是有新的咱肯定用新的啊</span><br>    frame.setVisible(<span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>有关其他组件还请各位小伙伴自行了解。</p><h3 id="新增组件介绍"><a href="#新增组件介绍" class="headerlink" title="新增组件介绍"></a>新增组件介绍</h3><p>Swing除了强化AWT提供的组件之外，还自行实现了各种各样新式的组件，我们来依次介绍一下。</p><p>首先是进度条组件：</p><p><img src="https://s2.loli.net/2022/11/05/SY8wjEkdcArvxnQ.png" alt="image-20221105163846233"></p><p>很多时候我们都会用到进度条来展示某些任务的完成进度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JProgressBar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JProgressBar</span>();<br>bar.setMaximum(<span class="hljs-number">100</span>);    <span class="hljs-comment">//设定进度条的最大值</span><br>bar.setValue(<span class="hljs-number">50</span>);    <span class="hljs-comment">//设定进度值</span><br>bar.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>我们可以利用进度条来写一个很简单的案例，比如文件的拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JProgressBar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JProgressBar</span>();   <span class="hljs-comment">//进度条显示文件拷贝进度</span><br>bar.setMaximum(<span class="hljs-number">1000</span>);<br>bar.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">300</span>, <span class="hljs-number">10</span>);<br><br><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;点击开始&quot;</span>);   <span class="hljs-comment">//点击按钮开始拷贝文件</span><br>button.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br>button.addActionListener(e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">//注意，不能直接在这个线程里面处理，因为这个线程是负责图形界面的，得单独创建一个线程处理，否则图形界面会卡死</span><br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;in.iso&quot;</span>);<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.iso&quot;</span>))&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> file.length(), current = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">while</span> ((len = in.read(bytes)) &gt; <span class="hljs-number">0</span>) &#123;<br>            current += len;<br>            bar.setValue((<span class="hljs-type">int</span>) (bar.getMaximum() * (<span class="hljs-type">double</span>)current / size));   <span class="hljs-comment">//每次拷贝都更新进度条</span><br>          bar.repaint();  <span class="hljs-comment">//因为并不是每次更新值都会使得组件重新绘制，如果视觉上比较卡，可以每次拷贝都重新绘制组件</span><br>            out.write(bytes, <span class="hljs-number">0</span>, len);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException exception) &#123;<br>        exception.printStackTrace();<br>    &#125;<br>&#125;).start());<br></code></pre></td></tr></table></figure><p>这样，我们在拷贝文件的时候，就有一个进度条实时显示当前的进度了：</p><p><img src="https://s2.loli.net/2022/11/05/qNoT6OwylH4Y8xc.png" alt="image-20221105165756172"></p><p>我们接着来看下一个组件，开关按钮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JToggleButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JToggleButton</span>(<span class="hljs-string">&quot;我是切换按钮&quot;</span>);   <span class="hljs-comment">//开关按钮有两个状态，一个是开一个是关</span><br>button.setBounds(<span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>它就像：</p><p><img src="https://s2.loli.net/2022/11/05/1fBdjMOy4SnADHu.png" alt="image-20221105170052200"></p><p>它有着两个状态，我们点击一次会使得其切换到另一种状态：</p><p><img src="https://s2.loli.net/2022/11/05/JXpw64yHb8rCRSg.png" alt="image-20221105170125623"></p><p>还有一些大型组件，比如颜色选择器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JColorChooser</span> <span class="hljs-variable">chooser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JColorChooser</span>();<br>chooser.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">600</span>, <span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p>颜色选择器的主要作用顾名思义，就是让用户选择一个颜色：</p><p><img src="https://s2.loli.net/2022/11/05/zsjxuSoYEr9lvZy.png" alt="image-20221105170623359"></p><p>这个太高级了，看着就很专业。同样的还有文件选择器JFileChooser：</p><p><img src="https://s2.loli.net/2022/11/05/T6Vld1NMB9AJfct.png" alt="image-20221105170745920"></p><p>完了，这Mac越用咋越像Windows了。</p><p>当然，Swing考虑得不止这些，甚至连工具提示都有，啥是工具提示？</p><p><img src="https://s2.loli.net/2022/11/05/mGaU6X2ILvqQT1g.png" alt="image-20221105171336948"></p><p>实际上就是当我们鼠标移动到某个组件上时，会给出一个漂浮提示，告诉我们这个组件是干嘛用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;我是按钮&quot;</span>);<br>button.setBounds(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);<br>button.setToolTipText(<span class="hljs-string">&quot;这个按钮是用来解决你毕设的！&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/izpvcCbVA3Ut81u.png" alt="image-20221105171453445"></p><p><code>setToolTipText</code>方法是<code>JComponent</code>就带有的，因此任何组件都可以设置这样的工具提示，是不是感觉很高级？</p><p>还有文件树，我们经常在窗口中看到这样的：</p><p><img src="https://s2.loli.net/2022/11/05/gcCnLterFaqPvkK.png" alt="image-20221105171728838"></p><p>我们的文件实际上在硬盘上就是以树形存储的，而Swing也为我们提供了能够显示树形关系的组件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTree</span>();<br>tree.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/IvjYykGRXiOAMtK.png" alt="image-20221105171813979"></p><p>这样，我们就可以用它来做一个文件资源管理器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里我们让JTree展示.idea目录下所有文件</span><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.idea&quot;</span>);   <span class="hljs-comment">//这里我们列出.idea目录下所有文件</span><br><span class="hljs-type">DefaultMutableTreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMutableTreeNode</span>(file.getName()); <span class="hljs-comment">//既然是树形关系，肯定有一个根结点</span><br><span class="hljs-comment">//拿到当前目录下所有文件和文件夹</span><br>File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (File f : files)<br>    root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMutableTreeNode</span>(f.getName()));    <span class="hljs-comment">//构造子结点并连接</span><br><br><span class="hljs-type">JTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTree</span>(root);    <span class="hljs-comment">//设定默认的根结点</span><br>tree.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>来看看效果吧：</p><p><img src="https://s2.loli.net/2022/11/05/YN4gKJbfstpRSCE.png" alt="image-20221105172802572"></p><p>你就说有没有内味吧。</p><h3 id="多面板和分割面板"><a href="#多面板和分割面板" class="headerlink" title="多面板和分割面板"></a>多面板和分割面板</h3><p>前面我们介绍了Swing为我们提供的丰富组件，我们接着来看多面板。</p><p><img src="https://s2.loli.net/2022/11/05/keDg2pnsJolaUZH.png" alt="image-20221105173345221"></p><p>多面板顾名思义，就是为了在一个窗口中展示多个面板，但是面板是可以自由切换的，在顶部会有一个小小的标签，我们点击之后就可以切换到对应的面板了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JTabbedPane</span> <span class="hljs-variable">pane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTabbedPane</span>();<br>pane.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>pane.addTab(<span class="hljs-string">&quot;一号&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);<br>pane.addTab(<span class="hljs-string">&quot;二号&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);<br></code></pre></td></tr></table></figure><p>JTabbedPane跟我们之前认识的Panel很像，相当于也是将我们的组件装进了内部，但是它可以同时装很多个，并且支持自由切换，所以说是很高级的。</p><p>这里我们创建两个面板，将一号面板设定为橙色，二号面板设定为粉色，分别添加到里面：</p><p><img src="https://s2.loli.net/2022/11/05/4jp1N9LnmwJGtOl.png" alt="image-20221105173821177"></p><p>这样，我们就可以布置一号面板做某些事情，二号面板做另外一些事情了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JTabbedPane</span> <span class="hljs-variable">pane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTabbedPane</span>();<br>pane.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">500</span>, <span class="hljs-number">300</span>); <br>pane.addTab(<span class="hljs-string">&quot;一号&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JColorChooser</span>());   <span class="hljs-comment">//一号面板当颜色选择器</span><br>pane.addTab(<span class="hljs-string">&quot;二号&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFileChooser</span>());    <span class="hljs-comment">//二号面板当文件选择器</span><br></code></pre></td></tr></table></figure><p>高级感一下就出来了不是：</p><p><img src="https://s2.loli.net/2022/11/05/QBPn8lk9tFd6sgH.png" alt="image-20221105174105955"></p><p>除了多面板这样的特殊面板组件之外，我们也可以使用分割面板：</p><p><img src="https://s2.loli.net/2022/11/05/2gMxOrFGkHCJ73o.png" alt="image-20221105174239436"></p><p>分割面板将一块完整的面板分割为两个部分，这样，我们就可以分别在左右两边进行操作了，而且中间的分割线是可以拖动的，实际上我们的IDEA也是这样的：</p><p><img src="https://s2.loli.net/2022/11/05/21l4GHg75fCaFzP.png" alt="image-20221105174326135"></p><p>IDEA的左边是文件管理器，右边就是编辑区域，同样支持拖动中间的分割线，这样的设计是非常人性化的。</p><p>我们来看看如何创建分割面板：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JSplitPane</span> <span class="hljs-variable">pane</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSplitPane</span>();<br>pane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);  <span class="hljs-comment">//设定为横向分割</span><br><span class="hljs-comment">//横向分割之后，我们需要指定左右两边的组件</span><br>pane.setLeftComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>()&#123;&#123;setBackground(Color.ORANGE);&#125;&#125;);<br>pane.setRightComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JPanel</span>()&#123;&#123;setBackground(Color.PINK);&#125;&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/05/3VjoCckOZG2qNIf.png" alt="image-20221105174609500"></p><p>配合我们之前的JTree组件和JTextArea组件，我们也可以写一个简单的IDEA软件出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JTextArea</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTextArea</span>();   <span class="hljs-comment">//右边就是我们需要编辑的文本域</span><br><br><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.idea&quot;</span>);<br><span class="hljs-type">DefaultMutableTreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMutableTreeNode</span>(file);<br>File[] files = Optional.ofNullable(file.listFiles()).orElseGet(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">for</span> (File f : files)<br>    root.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMutableTreeNode</span>(f.getName()));<br><span class="hljs-type">JTree</span> <span class="hljs-variable">tree</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JTree</span>(root);   <span class="hljs-comment">//左边就是我们的文件树</span><br>tree.addTreeSelectionListener(e -&gt; &#123;   <span class="hljs-comment">//点击文件之后，我们需要变换编辑窗口中的文本内容，这里加个监听器</span><br>    area.setText(<span class="hljs-string">&quot;&quot;</span>);   <span class="hljs-comment">//先清空</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;.idea/&quot;</span>+e.getPath().getLastPathComponent().toString()))&#123;<br>        <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">128</span>];   <span class="hljs-comment">//直接开始读取内容</span><br>        <span class="hljs-type">int</span> len;<br>        <span class="hljs-keyword">while</span> ((len = reader.read(chars)) &gt; <span class="hljs-number">0</span>)<br>            area.setText(area.getText() + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars, <span class="hljs-number">0</span>, len));   <span class="hljs-comment">//开始写入到编辑窗口中</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>        ex.printStackTrace();<br>    &#125;<br>&#125;);<br><br>pane.setLeftComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(tree));   <span class="hljs-comment">//文件树和编辑区域都套一个滚动面板，因为有可能会撑得很大</span><br>pane.setRightComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JScrollPane</span>(area));<br></code></pre></td></tr></table></figure><p>我们来看看我们自己写的IDEA软件怎么样吧：</p><p><img src="https://s2.loli.net/2022/11/05/rwik4EqaOeMYWfz.png" alt="image-20221105180609195"></p><p>嗯，真不错，各位小伙伴赶紧去JetBrains投简历吧！</p><h3 id="选项窗口"><a href="#选项窗口" class="headerlink" title="选项窗口"></a>选项窗口</h3><p>前面我们介绍过对话框，但是AWT提供的对话框太过原始，很多功能都需要我们自行实现，而Swing为我们提供了一套已经实现好的预设选项对话框，我们只需要直接使用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);  <span class="hljs-comment">//先将默认关闭行为设定为什么都不做</span><br>frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;   <span class="hljs-comment">//我们自己来实现窗口关闭行为</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;   <span class="hljs-comment">//这里我们可以直接展示一个预设好的确认对话框</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> JOptionPane.showConfirmDialog(frame, <span class="hljs-string">&quot;你真的要退出吗？&quot;</span>);<br>        <span class="hljs-keyword">if</span>(value == JOptionPane.OK_OPTION)    <span class="hljs-comment">//返回值就是用户的选择结果，也是预置好的，这里判断如果是OK那么就退出</span><br>            System.exit(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>我们之前要实现这样的一个功能，非常麻烦，但是现在就很简单了：</p><p><img src="https://s2.loli.net/2022/11/06/ekOZLQnUR2dMXTN.png" alt="image-20221106162732123"></p><p>官方已经给我们预设好了一个对话框，我们直接用就可以了。当然，还有各种类型的，我们可以自己定义窗口的标题、图标等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JOptionPane.showConfirmDialog(frame, <span class="hljs-string">&quot;你真的要退出吗？&quot;</span>, <span class="hljs-string">&quot;退出程序&quot;</span>, JOptionPane.YES_NO_OPTION);<br></code></pre></td></tr></table></figure><p>除了这种简单的对话框，Swing还为我们提供了一些其他类型的对话框，比如单纯的消息提示框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">JOptionPane.showMessageDialog(frame, <span class="hljs-string">&quot;我是简单的提示消息！&quot;</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/06/YH8dgDRunsG9jPv.png" alt="image-20221106165351473"></p><p>还有用户输入文本的输入对话框：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JFrame</span> <span class="hljs-variable">frame</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JFrame</span>(<span class="hljs-string">&quot;我是窗口&quot;</span>);<br>frame.setSize(<span class="hljs-number">500</span>, <span class="hljs-number">300</span>);<br>frame.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);<br>frame.addWindowListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowAdapter</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">windowClosing</span><span class="hljs-params">(WindowEvent e)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> JOptionPane.showInputDialog(<span class="hljs-string">&quot;毕业后的你，将何去何从呢？&quot;</span>);<br>        System.out.println(str);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/06/ZwGfv1HqOjikEPn.png" alt="image-20221106165324954"></p><p>通过灵活使用这些对话框，用户与我们的交互就更加亲密了。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>Swing早就考虑到了不同平台可能会出现的组件样式差异，因此推出了皮肤机制。</p><p>就像我们可以给英雄换皮肤一样，我们的组件UI也是可以换皮肤的，官方名称叫做LookAndFeel，Swing官方为我们提供了很多套皮肤，这些皮肤都是可以跨平台的，当然也有某些平台专属的限定皮肤：</p><ul><li>MetalLookAndFeel  -  官方默认皮肤</li><li>WindowsLookAndFeel  -  Windows操作系统限定皮肤，其他平台无法使用</li><li>MotifLookAndFeel   -   官方皮肤</li><li>NimbusLookAndFeel   -   官方皮肤</li><li>AquaLookAndFeel    -    MacOS操作系统限定皮肤，其他平台无法使用</li></ul><p>更换皮肤很简单，我们只需要执行一个方法就可以，它是全局生效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">UIManager.setLookAndFeel(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AquaLookAndFeel</span>());<br></code></pre></td></tr></table></figure><p>这里我们将皮肤设定为MacOS的冰雪节限定皮肤AquaLookAndFeel：</p><p><img src="https://s2.loli.net/2022/11/06/L7HyUlVpA5P9iTZ.png" alt="image-20221106170921703"></p><p>是不是感觉视觉上和之前的皮肤不太一样？我们可以多看看其他的皮肤：</p><p><img src="https://s2.loli.net/2022/11/06/EGrWzIZuRfejXN2.png" alt="image-20221106171046755"></p><p><img src="https://s2.loli.net/2022/11/06/BOtWrIe7CuklMcZ.png" alt="image-20221106171110930"></p><p>实际上Swing组件的绘制并不是由组件本身编写的，而是在各个UI实现类中编写的，所以说要修改组件样式只需要更换皮肤即可。</p><p>除了全局设定皮肤之外，我们也可以单独对某些组件设定皮肤，每个组件都有自己的<code>getUI</code>方法，这个方法就是获取当前组件使用的UI样式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(tree.getUI());<br></code></pre></td></tr></table></figure><p>这里得到的是：</p><p><img src="https://s2.loli.net/2022/11/06/2NChELXRkoqJGMQ.png" alt="image-20221106224348544"></p><p>我们可以自己编写一个UI样式来为组件进行设定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJButtonUI</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ButtonUI</span> &#123;   <span class="hljs-comment">//继承对应的UI父类</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">paint</span><span class="hljs-params">(Graphics g, JComponent c)</span> &#123;   <span class="hljs-comment">//我们只需要重写对应UI的paint方法就可以了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> c.getWidth(), height = c.getHeight();<br>        g.setColor(Color.BLACK);<br>        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<br>        g.setColor(Color.WHITE);<br>        <span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> (JButton) c;<br>        g.drawString(button.getText(), <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要使用set方法来设定即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>(<span class="hljs-string">&quot;我是按钮&quot;</span>);<br>button.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">30</span>);<br>button.setUI(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestJButtonUI</span>());   <span class="hljs-comment">//将UI设定为我们自己定义的即可</span><br></code></pre></td></tr></table></figure><p>这样就换成我们自己的皮肤了：</p><p><img src="https://s2.loli.net/2022/11/06/53kHx2zTZ7wtUfC.png" alt="image-20221106231437842"></p><p>各位小伙伴甚至可以编写一套自己的UI，并制作成一个LookAndFeel，这样我们写出来的程序就非常个性化了。</p><hr><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>前面我们已经学习了Swing的全部内容，最后我们还是来做一个小项目吧！</p><h3 id="Intellij-IDEA-Extreme"><a href="#Intellij-IDEA-Extreme" class="headerlink" title="Intellij IDEA Extreme"></a>Intellij IDEA Extreme</h3><p>我们的目标是用IDEA写一个IDEA（当然不会太复杂，只需要实现基本功能就可以了）</p><p>需求分析：</p><ul><li>支持创建项目、管理项目文件</li><li>支持对源代码文件的编辑</li><li>支持一键编译、运行</li></ul><p>做Swing项目，什么五子棋、坦克大战都弱爆了，这里我们直接手撕一个IDEA出来。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/td5tgn04nqmkrryt">https://www.itbaima.cn/zh-CN/document/td5tgn04nqmkrryt</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（七）多线程与反射</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%83%EF%BC%89%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/04/aRsN9WoS7BcC3uY.png" alt="image-20221004132312588"></p><h1 id="多线程与反射"><a href="#多线程与反射" class="headerlink" title="多线程与反射"></a>多线程与反射</h1><p>前面我们已经讲解了JavaSE的大部分核心内容，最后一章，我们还将继续学习JavaSE中提供的各种高级特性。这些高级特性对于我们之后的学习，会有着举足轻重的作用。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><strong>注意：</strong> 本章节会涉及到 <strong>操作系统</strong> 相关知识。</p><p>在了解多线程之前，让我们回顾一下<code>操作系统</code>中提到的进程概念：</p><p><img src="https://s2.loli.net/2022/10/04/GhrSTfNRsc2jFZM.jpg" alt="b040eadb-8aa1-4b2a-b587-2c0a6b4efa0b"></p><p>进程是程序执行的实体，每一个进程都是一个应用程序（比如我们运行QQ、浏览器、LOL、网易云音乐等软件），都有自己的内存空间，CPU一个核心同时只能处理一件事情，当出现多个进程需要同时运行时，CPU一般通过<code>时间片轮转调度</code>算法，来实现多个进程的同时运行。</p><p><img src="https://s2.loli.net/2022/10/04/hUkGafu7vztB4qR.png" alt="image-20221004132729868"></p><p>在早期的计算机中，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。但是，如果我希望两个任务同时进行，就必须运行两个进程，由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时，那么能否实现在一个进程中就能够执行多个任务呢？</p><p><img src="https://s2.loli.net/2022/10/04/okgq3HEKGn6jBVw.png" alt="image-20221004132700554"></p><p>后来，线程横空出世，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p><p>在之前的学习中，一直以来编写的都是单线程应用程序（运行<code>main()</code>方法的内容），也就是说只能同时执行一个任务（无论你是调用方法、还是进行计算，始终都是依次进行的，也就是同步的），而如果我们希望同时执行多个任务（两个方法<strong>同时</strong>在运行或者是两个计算同时在进行，也就是并发的），就需要用到Java多线程框架。实际上一个Java程序启动后，会创建很多辅助线程，不仅仅只运行一个主线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();<br>    <span class="hljs-type">long</span>[] ids = bean.getAllThreadIds();<br>    ThreadInfo[] infos = bean.getThreadInfo(ids);<br>    <span class="hljs-keyword">for</span> (ThreadInfo info : infos) &#123;<br>        System.out.println(info.getThreadName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于除了main线程默认以外的线程，涉及到JVM相关底层原理，在这里不做讲解，了解就行。</p><h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a>线程的创建和启动</h3><p>通过创建Thread对象来创建一个新的线程，Thread构造方法中需要传入一个Runnable接口的实现（其实就是编写要在另一个线程执行的逻辑）同时Runnable只有一个未实现方法，因此可以直接使用lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span><br><span class="hljs-comment">     * to create a thread, starting the thread causes the object&#x27;s</span><br><span class="hljs-comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span><br><span class="hljs-comment">     * thread.</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span><br><span class="hljs-comment">     * take any action whatsoever.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span>     java.lang.Thread#run()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建好后，通过调用<code>start()</code>方法来运行此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;    <span class="hljs-comment">//直接编写逻辑</span><br>        System.out.println(<span class="hljs-string">&quot;我是另一个线程！&quot;</span>);<br>    &#125;);<br>    t.start();   <span class="hljs-comment">//调用此方法来开始执行此线程</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可能上面的例子看起来和普通的单线程没两样，那我们先来看看下面这段代码的运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是线程：&quot;</span>+Thread.currentThread().getName());<br>        System.out.println(<span class="hljs-string">&quot;我正在计算 0-10000 之间所有数的和...&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">10000</span>; i++) &#123;<br>            sum += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结果：&quot;</span>+sum);<br>    &#125;);<br>    t.start();<br>    System.out.println(<span class="hljs-string">&quot;我是主线程！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，这段代码执行输出结果并不是按照从上往下的顺序了，因为他们分别位于两个线程，他们是同时进行的！如果你还是觉得很疑惑，我们接着来看下面的代码运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是一号线程：&quot;</span>+i);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是二号线程：&quot;</span>+i);<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到打印实际上是在交替进行的，也证明了他们是在同时运行！</p><p><strong>注意</strong>：我们发现还有一个run方法，也能执行线程里面定义的内容，但是run是直接在当前线程执行，并不是创建一个线程执行！</p><p><img src="https://s2.loli.net/2022/10/04/Srx4H8YyRWqXofc.png" alt="image-20221004133119997"></p><p>实际上，线程和进程差不多，也会等待获取CPU资源，一旦获取到，就开始按顺序执行我们给定的程序，当需要等待外部IO操作（比如Scanner获取输入的文本），就会暂时处于休眠状态，等待通知，或是调用<code>sleep()</code>方法来让当前线程休眠一段时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//休眠时间，以毫秒为单位，1000ms = 1s</span><br>    System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;w&quot;</span>);<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(<span class="hljs-string">&quot;nb!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用<code>stop()</code>方法来强行终止此线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> Thread.currentThread();   <span class="hljs-comment">//获取当前线程对象</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;打印:&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">20</span>) me.stop();  <span class="hljs-comment">//此方法会直接终止此线程</span><br>        &#125;<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然<code>stop()</code>方法能够终止此线程，但是并不是所推荐的做法，有关线程中断相关问题，我们会在后面继续了解。</p><p><strong>思考</strong>：猜猜以下程序输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，value最后的值并不是我们理想的结果，有关为什么会出现这种问题，在我们学习到线程锁的时候，再来探讨。</p><h3 id="线程的休眠和中断"><a href="#线程的休眠和中断" class="headerlink" title="线程的休眠和中断"></a>线程的休眠和中断</h3><p>我们前面提到，一个线程处于运行状态下，线程的下一个状态会出现以下情况：</p><ul><li>当CPU给予的运行时间结束时，会从运行状态回到就绪（可运行）状态，等待下一次获得CPU资源。</li><li>当线程进入休眠 &#x2F; 阻塞(如等待IO请求) &#x2F; 手动调用<code>wait()</code>方法时，会使得线程处于等待状态，当等待状态结束后会回到就绪状态。</li><li>当线程出现异常或错误 &#x2F; 被<code>stop()</code> 方法强行停止 &#x2F; 所有代码执行结束时，会使得线程的运行终止。</li></ul><p>而这个部分我们着重了解一下线程的休眠和中断，首先我们来了解一下如何使得线程进如休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;l&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);   <span class="hljs-comment">//sleep方法是Thread的静态方法，它只作用于当前线程（它知道当前线程是哪个）</span><br>            System.out.println(<span class="hljs-string">&quot;b&quot;</span>);    <span class="hljs-comment">//调用sleep后，线程会直接进入到等待状态，直到时间结束</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用<code>sleep()</code>方法来将当前线程进入休眠，使得线程处于等待状态一段时间。我们发现，此方法显示声明了会抛出一个InterruptedException异常，那么这个异常在什么时候会发生呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">//休眠10秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，每一个Thread对象中，都有一个<code>interrupt()</code>方法，调用此方法后，会给指定线程添加一个中断标记以告知线程需要立即停止运行或是进行其他操作，由线程来响应此中断并进行相应的处理，我们前面提到的<code>stop()</code>方法是强制终止线程，这样的做法虽然简单粗暴，但是很有可能导致资源不能完全释放，而类似这样的发送通知来告知线程需要中断，让线程自行处理后续，会更加合理一些，也是更加推荐的做法。我们来看看interrupt的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;   <span class="hljs-comment">//无限循环</span><br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//响应中断</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程被中断了！&quot;</span>);<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>isInterrupted()</code>可以判断线程是否存在中断标志，如果存在，说明外部希望当前线程立即停止，也有可能是给当前线程发送一个其他的信号，如果我们并不是希望收到中断信号就是结束程序，而是通知程序做其他事情，我们可以在收到中断信号后，复位中断标记，然后继续做我们的事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted())&#123;   <span class="hljs-comment">//判断是否存在中断标志</span><br>                System.out.println(<span class="hljs-string">&quot;发现中断信号，复位，继续运行...&quot;</span>);<br>                Thread.interrupted();  <span class="hljs-comment">//复位中断标记（返回值是当前是否有中断标记，这里不用管）</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">3000</span>);   <span class="hljs-comment">//休眠3秒，一定比线程t先醒来</span><br>        t.interrupt();   <span class="hljs-comment">//调用t的interrupt方法</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>复位中断标记后，会立即清除中断标记。在Java 21之前，我们还可以使用<code>suspend()</code>和<code>resume()</code>用于暂停和恢复线程，但是由于其存在严重弊端，这两个方法已经被移除，这里就不再介绍了，有关线程暂停和恢复最佳方案会在下面的课程中介绍。</p><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>实际上，Java程序中的每个线程并不是平均分配CPU时间的，为了使得线程资源分配更加合理，Java采用的是抢占式调度方式，优先级越高的线程，优先使用CPU资源！我们希望CPU花费更多的时间去处理更重要的任务，而不太重要的任务，则可以先让出一部分资源。线程的优先级一般分为以下三种：</p><ul><li>MIN_PRIORITY  最低优先级</li><li>MAX_PRIORITY  最高优先级</li><li>NOM_PRIORITY  常规优先级</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程开始运行！&quot;</span>);<br>    &#125;);<br>    t.setPriority(Thread.MIN_PRIORITY);  <span class="hljs-comment">//通过使用setPriority方法来设定优先级</span><br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>优先级越高的线程，获得CPU资源的概率会越大，并不是说一定优先级越高的线程越先执行！</p><h3 id="线程的礼让和加入"><a href="#线程的礼让和加入" class="headerlink" title="线程的礼让和加入"></a>线程的礼让和加入</h3><p>我们还可以在当前线程的工作不重要时，将CPU资源让位给其他线程，通过使用<code>yield()</code>方法来将当前资源让位给其他同优先级线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;让位！&quot;</span>);<br>                Thread.<span class="hljs-keyword">yield</span>();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>观察结果，我们发现，在让位之后，尽可能多的在执行线程2的内容。</p><p>当我们希望一个线程等待另一个线程执行完成后再继续进行，我们可以使用<code>join()</code>方法来实现线程的加入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程1开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;1打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，线程1加入后，线程2等待线程1待执行的内容全部执行完成之后，再继续执行的线程2内容。注意，线程的加入只是等待另一个线程的完成，并不是将另一个线程和当前线程合并！我们来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;打印：&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1结束！&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程2开始运行！&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;2打印：&quot;</span>+i);<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">10</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1加入到此线程！&quot;</span>);<br>                    t1.join();    <span class="hljs-comment">//在i==10时，让线程1加入，先完成线程1的内容，在继续当前内容</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，t2线程只是暂时处于等待状态，当t1执行结束时，t2才开始继续执行，只是在效果上看起来好像是两个线程合并为一个线程在执行而已。</p><h3 id="线程锁和线程同步"><a href="#线程锁和线程同步" class="headerlink" title="线程锁和线程同步"></a>线程锁和线程同步</h3><p>在开始讲解线程同步之前，我们需要先了解一下多线程情况下Java的内存管理：</p><p><img src="https://s2.loli.net/2022/10/04/ZvI8neF3tdGJwS4.png" alt="image-20221004203914215"></p><p>线程之间的共享变量（比如之前悬念中的value变量）存储在主内存（main memory）中，每个线程都有一个私有的工作内存（本地内存），工作内存中存储了该线程以读&#x2F;写共享变量的副本。它类似于我们在<code>计算机组成原理</code>中学习的多核心处理器高速缓存机制：</p><p><img src="https://s2.loli.net/2022/10/04/SKlbIZyvxMnauLJ.png" alt="image-20221004204209038"></p><p>高速缓存通过保存内存中数据的副本来提供更加快速的数据访问，但是如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，在写回主内存时就会发生冲突，这就是引入高速缓存引发的新问题，称之为：缓存一致性。</p><p>实际上，Java的内存模型也是这样类似设计的，当我们同时去操作一个共享变量时，如果仅仅是读取还好，但是如果同时写入内容，就会出现问题！好比说一个银行，如果我和我的朋友同时在银行取我账户里面的钱，难道取1000还可能吐2000出来吗？我们需要一种更加安全的机制来维持秩序，保证数据的安全性！</p><p>比如我们可以来看看下面这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) value++;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，当两个线程同时读取value的时候，可能会同时拿到同样的值，而进行自增操作之后，也是同样的值，再写回主内存后，本来应该进行2次自增操作，实际上只执行了一次！</p><p><img src="https://s2.loli.net/2022/10/04/T2l3xfIP17Gr5dw.png" alt="image-20221004204439553"></p><p>通过synchronized关键字来创造一个线程锁，首先我们来认识一下synchronized代码块，它需要在括号中填入一个内容，必须是一个对象或是一个类，我们在value自增操作外套上同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;  <span class="hljs-comment">//使用synchronized关键字创建同步代码块</span><br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Main.class)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，现在得到的结果就是我们想要的内容了，因为在同步代码块执行过程中，拿到了我们传入对象或类的锁（传入的如果是对象，就是对象锁，不同的对象代表不同的对象锁，如果是类，就是类锁，类锁只有一个，实际上类锁也是对象锁，是Class类实例，但是Class类实例同样的类无论怎么获取都是同一个），但是注意两个线程必须使用同一把锁！</p><p>当一个线程进入到同步代码块时，会获取到当前的锁，而这时如果其他使用同样的锁的同步代码块也想执行内容，就必须等待当前同步代码块的内容执行完毕，在执行完毕后会自动释放这把锁，而其他的线程才能拿到这把锁并开始执行同步代码块里面的内容（实际上synchronized是一种悲观锁，随时都认为有其他线程在对数据进行修改，后面在JUC篇视频教程中我们还会讲到乐观锁，如CAS算法）</p><p>那么我们来看看，如果使用的是不同对象的锁，那么还能顺利进行吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main1)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (main2)&#123;<br>                value++;<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>当对象不同时，获取到的是不同的锁，因此并不能保证自增操作的原子性，最后也得不到我们想要的结果。</p><p>synchronized关键字也可以作用于方法上，调用此方法时也会获取锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>    value++;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程1完成&quot;</span>);<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) add();<br>        System.out.println(<span class="hljs-string">&quot;线程2完成&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">//主线程停止1秒，保证两个线程执行完成</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现实际上效果是相同的，只不过这个锁不用你去给，如果是静态方法，就是使用的类锁，而如果是普通成员方法，就是使用的对象锁。通过灵活的使用synchronized就能很好地解决我们之前提到的问题了。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>其实死锁的概念在<code>操作系统</code>中也有提及，它是指两个线程相互持有对方需要的锁，但是又迟迟不释放，导致程序卡住：</p><p><img src="https://s2.loli.net/2022/10/04/Ja6TPO23wCI8pvn.png" alt="image-20221004205058223"></p><p>我们发现，线程A和线程B都需要对方的锁，但是又被对方牢牢把握，由于线程被无限期地阻塞，因此程序不可能正常终止。我们来看看以下这段代码会得到什么结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程1&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o2)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;线程2&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t1.start();<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，我们在编写程序时，一定要注意，不要出现这种死锁的情况。那么我们如何去检测死锁呢？我们可以利用jstack命令来检测死锁，首先利用jps找到我们的java进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">nagocoler@NagodeMacBook-Pro ~ % jps<br>51592 Launcher<br>51690 Jps<br>14955 <br>51693 Main<br>nagocoler@NagodeMacBook-Pro ~ % jstack 51693<br>...<br>Java stack information for the threads listed above:<br>===================================================<br>&quot;Thread-1&quot;:<br>at com.test.Main.lambda$main$1(Main.java:46)<br>- waiting to lock &lt;0x000000076ad27fc0&gt; (a java.lang.Object)<br>- locked &lt;0x000000076ad27fd0&gt; (a java.lang.Object)<br>at com.test.Main$$Lambda$2/1867750575.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br>&quot;Thread-0&quot;:<br>at com.test.Main.lambda$main$0(Main.java:34)<br>- waiting to lock &lt;0x000000076ad27fd0&gt; (a java.lang.Object)<br>- locked &lt;0x000000076ad27fc0&gt; (a java.lang.Object)<br>at com.test.Main$$Lambda$1/396873410.run(Unknown Source)<br>at java.lang.Thread.run(Thread.java:748)<br><br>Found 1 deadlock.<br></code></pre></td></tr></table></figure><p>jstack自动帮助我们找到了一个死锁，并打印出了相关线程的栈追踪信息，同样的，使用<code>jconsole</code>也可以进行监测。</p><blockquote><p> 针对于旧版本不推荐使用 <code>suspend()</code>去挂起线程的原因，是因为<code>suspend()</code>在使线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行<code>resume()</code>方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行。但是，如果<code>resume()</code>操作出现在<code>suspend()</code>之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。</p></blockquote><h3 id="wait和notify方法"><a href="#wait和notify方法" class="headerlink" title="wait和notify方法"></a>wait和notify方法</h3><p>其实我们之前可能就发现了，Object类还有三个方法我们从来没有使用过，分别是<code>wait()</code>、<code>notify()</code>以及<code>notifyAll()</code>，他们其实是需要配合synchronized来使用的（实际上锁就是依附于对象存在的，每个对象都应该有针对于锁的一些操作，所以说就这样设计了）当然，只有在同步代码块中才能使用这些方法，正常情况下会报错，我们来看看他们的作用是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始等待&quot;</span>);<br>                o1.wait();     <span class="hljs-comment">//进入等待状态并释放锁</span><br>                System.out.println(<span class="hljs-string">&quot;等待结束！&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (o1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;开始唤醒！&quot;</span>);<br>            o1.notify();     <span class="hljs-comment">//唤醒处于等待状态的线程</span><br>          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>               System.out.println(i);   <br>            &#125;<br>          <span class="hljs-comment">//唤醒后依然需要等待这里的锁释放之前等待的线程才能继续</span><br>        &#125;<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以发现，对象的<code>wait()</code>方法会暂时使得此线程进入等待状态，同时会释放当前代码块持有的锁，这时其他线程可以获取到此对象的锁，当其他线程调用对象的<code>notify()</code>方法后，会唤醒刚才变成等待状态的线程（这时并没有立即释放锁）。注意，必须是在持有锁（同步代码块内部）的情况下使用，否则会抛出异常！</p><p>notifyAll其实和notify一样，也是用于唤醒，但是前者是唤醒所有调用<code>wait()</code>后处于等待的线程，而后者是看运气随机选择一个。</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>既然每个线程都有一个自己的工作内存，那么能否只在自己的工作内存中创建变量仅供线程自己使用呢？</p><p><img src="https://s2.loli.net/2023/08/14/lNCAaZcfysW5UQ2.png" alt="img"></p><p>我们可以使用ThreadLocal类，来创建工作内存中的变量，它将我们的变量值存储在内部（只能存储一个变量），不同的线程访问到ThreadLocal对象时，都只能获取到当前线程所属的变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;变量值已设定！&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">3000</span>);    <span class="hljs-comment">//间隔三秒</span><br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子中，我们开启两个线程分别去访问ThreadLocal对象，我们发现，第一个线程存放的内容，第一个线程可以获取，但是第二个线程无法获取，我们再来看看第一个线程存入后，第二个线程也存放，是否会覆盖第一个线程存放的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();  <span class="hljs-comment">//注意这是一个泛型类，存储类型为我们要存放的变量类型</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程1变量值已设定！&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);    <span class="hljs-comment">//间隔2秒</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程1读取变量值：&quot;</span>);<br>        System.out.println(local.get());   <span class="hljs-comment">//尝试获取ThreadLocal中存放的变量</span><br>    &#125;);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        local.set(<span class="hljs-string">&quot;yyds&quot;</span>);   <span class="hljs-comment">//将变量的值给予ThreadLocal</span><br>        System.out.println(<span class="hljs-string">&quot;线程2变量值已设定！&quot;</span>);<br>    &#125;);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">1000</span>);    <span class="hljs-comment">//间隔1秒</span><br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，即使线程2重新设定了值，也没有影响到线程1存放的值，所以说，不同线程向ThreadLocal存放数据，只会存放在线程自己的工作空间中，而不会直接存放到主内存中，因此各个线程直接存放的内容互不干扰。</p><p>我们发现在线程中创建的子线程，无法获得父线程工作内存中的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(local.get());<br>        &#125;).start();<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用InheritableThreadLocal来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ThreadLocal&lt;String&gt; local = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>       local.set(<span class="hljs-string">&quot;lbwnb&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(local.get());<br>        &#125;).start();<br>    &#125;);<br>    t.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>在InheritableThreadLocal存放的内容，会自动向子线程传递。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>我们有时候会有这样的需求，我希望定时执行任务，比如3秒后执行，其实我们可以通过使用<code>Thread.sleep()</code>来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerTask</span>&#123;<br>    Runnable task;<br>    <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span>&#123;<br>        <span class="hljs-built_in">this</span>.task = runnable;<br>        <span class="hljs-built_in">this</span>.time = time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(time);<br>                task.run();   <span class="hljs-comment">//休眠后再运行</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过自行封装一个TimerTask类，并在启动时，先休眠3秒钟，再执行我们传入的内容。那么现在我们希望，能否循环执行一个任务呢？比如我希望每隔1秒钟执行一次代码，这样该怎么做呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerLoopTask</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;我是定时任务！&quot;</span>), <span class="hljs-number">3000</span>).start();   <span class="hljs-comment">//创建并启动此定时任务</span><br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerLoopTask</span>&#123;<br>    Runnable task;<br>    <span class="hljs-type">long</span> loopTime;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TimerLoopTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> loopTime)</span>&#123;<br>        <span class="hljs-built_in">this</span>.task = runnable;<br>        <span class="hljs-built_in">this</span>.loopTime = loopTime;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;   <span class="hljs-comment">//无限循环执行</span><br>                    Thread.sleep(loopTime);<br>                    task.run();   <span class="hljs-comment">//休眠后再运行</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们将单次执行放入到一个无限循环中，这样就能一直执行了，并且按照我们的间隔时间进行。</p><p>但是终究是我们自己实现，可能很多方面还没考虑到，Java也为我们提供了一套自己的框架用于处理定时任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();    <span class="hljs-comment">//创建定时器对象</span><br>    timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;   <span class="hljs-comment">//注意这个是一个抽象类，不是接口，无法使用lambda表达式简化，只能使用匿名内部类</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(Thread.currentThread().getName());    <span class="hljs-comment">//打印当前线程名称</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);    <span class="hljs-comment">//执行一个延时任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过创建一个Timer类来让它进行定时任务调度，我们可以通过此对象来创建任意类型的定时任务，包延时任务、循环定时任务等。我们发现，虽然任务执行完成了，但是我们的程序并没有停止，这是因为Timer内存维护了一个任务队列和一个工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer task queue.  This data structure is shared with the timer</span><br><span class="hljs-comment">     * thread.  The timer produces tasks, via its various schedule calls,</span><br><span class="hljs-comment">     * and the timer thread consumes, executing timer tasks as appropriate,</span><br><span class="hljs-comment">     * and removing them from the queue when they&#x27;re obsolete.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskQueue</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The timer thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TimerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerThread</span>(queue);<br>  <br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>TimerThread继承自Thread，是一个新创建的线程，在构造时自动启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Timer</span><span class="hljs-params">(String name)</span> &#123;<br>    thread.setName(name);<br>    thread.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>而它的run方法会循环地读取队列中是否还有任务，如果有任务依次执行，没有的话就暂时处于休眠状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mainLoop();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Someone killed this Thread, behave as if Timer cancelled</span><br>        <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>            newTasksMayBeScheduled = <span class="hljs-literal">false</span>;<br>            queue.clear();  <span class="hljs-comment">// Eliminate obsolete references</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The main timer loop.  (See class comment.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mainLoop</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>       TimerTask task;<br>       <span class="hljs-type">boolean</span> taskFired;<br>       <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>         <span class="hljs-comment">// Wait for queue to become non-empty</span><br>          <span class="hljs-keyword">while</span> (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled)   <span class="hljs-comment">//当队列为空同时没有被关闭时，会调用wait()方法暂时处于等待状态，当有新的任务时，会被唤醒。</span><br>                queue.wait();<br>          <span class="hljs-keyword">if</span> (queue.isEmpty())<br>             <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当被唤醒后都没有任务时，就会结束循环，也就是结束工作线程</span><br>                      ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>newTasksMayBeScheduled</code>实际上就是标记当前定时器是否关闭，当它为false时，表示已经不会再有新的任务到来，也就是关闭，我们可以通过调用<code>cancel()</code>方法来关闭它的工作线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>(queue) &#123;<br>        thread.newTasksMayBeScheduled = <span class="hljs-literal">false</span>;<br>        queue.clear();<br>        queue.notify();  <span class="hljs-comment">//唤醒wait使得工作线程结束</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们可以在使用完成后，调用Timer的<code>cancel()</code>方法以正常退出我们的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>    timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(Thread.currentThread().getName());<br>            timer.cancel();  <span class="hljs-comment">//结束</span><br>        &#125;<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>注意：</strong> 不要把操作系统中的守护进程和守护线程相提并论。</p><p>操作系统中的守护进程在后台运行，不需要和用户交互，本质和普通进程类似。而守护线程就不一样了，当其他所有的非守护线程结束之后，守护线程自动结束，也就是说，Java中所有的线程都执行完毕后，守护线程自动停止，因此守护线程不适合进行IO操作，只适合打打杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    t.setDaemon(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在守护线程中产生的新线程也是守护的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException&#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;程序正常运行中...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        it.start();<br>    &#125;);<br>    t.setDaemon(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//设置为守护线程（必须在开始之前，中途是不允许转换的）</span><br>    t.start();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="再谈集合类"><a href="#再谈集合类" class="headerlink" title="再谈集合类"></a>再谈集合类</h3><p>因为多线程的加入，我们之前认识的集合类都废掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            list.add(i);   <span class="hljs-comment">//两个线程同时操作集合类进行插入操作</span><br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>    &#125;).start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    System.out.println(list.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，有些时候运气不好，得到的结果并不是2000个元素，而是：</p><p><img src="https://s2.loli.net/2022/10/04/m1nZfG4wPCOQx8V.png" alt="image-20221004212332535"></p><p>因为之前的集合类，并没有考虑到多线程运行的情况，如果两个线程同时执行，那么有可能两个线程同一时间都执行同一个方法，这种情况下就很容易出问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 当数组容量更好还差一个满的时候，这个时候两个线程同时走到了这里，因为都判断为没满，所以说没有进行扩容，但是实际上两个线程都要插入一个元素进来</span><br>    elementData[size++] = e;   <span class="hljs-comment">//当两个线程同时在这里插入元素，直接导致越界访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，在Java早期的时候，还有一些老的集合类，这些集合类都是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Vector&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();   <span class="hljs-comment">//我们可以使用Vector代替List使用</span><br>  <span class="hljs-comment">//Hashtable&lt;Integer, String&gt;   也可以使用Hashtable来代替Map</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>; i &lt; <span class="hljs-number">2000</span>; i++) &#123;<br>            list.add(i);<br>        &#125;<br>    &#125;).start();<br><br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    System.out.println(list.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>因为这些集合类中的每一个方法都加了锁，所以说不会出现多线程问题，但是这些老的集合类现在已经不再使用了，我们会在JUC篇视频教程中介绍专用于并发编程的集合类。</p><p>通过对Java多线程的了解，我们就具备了利用多线程解决问题的思维！</p><h3 id="Java-8-并行流"><a href="#Java-8-并行流" class="headerlink" title="(Java 8) 并行流"></a>(Java 8) 并行流</h3><p>集合类中有一个东西是Java8新增的Spliterator接口，翻译过来就是：可拆分迭代器（Splitable Iterator）和Iterator一样，Spliterator也用于遍历数据源中的元素，但它是为了并行执行而设计的。Java 8已经为集合框架中包含的所有数据结构提供了一个默认的Spliterator实现。在集合跟接口Collection中提供了一个<code>spliterator()</code>方法用于获取可拆分迭代器。</p><p>其实我们之前在讲解集合类的根接口时，就发现有这样一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>); <span class="hljs-comment">//parallelStream就是利用了可拆分迭代器进行多线程操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并行流，其实就是一个多线程执行的流，它通过默认的ForkJoinPool实现（这里不讲解原理），它可以提高你的多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEach(i -&gt; System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; -&gt; &quot;</span>+i));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，forEach操作的顺序，并不是我们实际List中的顺序，同时每次打印也是不同的线程在执行！我们可以通过调用<code>forEachOrdered()</code>方法来使用单线程维持原本的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>));<br>    list<br>            .parallelStream()    <span class="hljs-comment">//获得并行流</span><br>            .forEachOrdered(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们之前还发现，在Arrays数组工具类中，也包含大量的并行方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSort(arr);   <span class="hljs-comment">//使用多线程进行并行排序，效率更高</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>更多地使用并行方法，可以更加充分地发挥现代计算机多核心的优势，但是同时需要注意多线程产生的异步问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>&#125;;<br>    Arrays.parallelSetAll(arr, i -&gt; &#123;<br>        System.out.println(Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> arr[i];<br>    &#125;);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实战：生产者与消费者"><a href="#实战：生产者与消费者" class="headerlink" title="实战：生产者与消费者"></a>实战：生产者与消费者</h3><p>所谓的生产者消费者模型，是通过一个容器来解决生产者和消费者的强耦合问题。通俗的讲，就是生产者在不断的生产，消费者也在不断的消费，可是消费者消费的产品是生产者生产的，这就必然存在一个中间容器，我们可以把这个容器想象成是一个货架，当货架空的时候，生产者要生产产品，此时消费者在等待生产者往货架上生产产品，而当货架有货物的时候，消费者可以从货架上拿走商品，生产者此时等待货架出现空位，进而补货，这样不断的循环。</p><p>通过多线程编程，来模拟一个餐厅的2个厨师和3个顾客，假设厨师炒出一个菜的时间为3秒，顾客吃掉菜品的时间为4秒。</p><h3 id="Java-21-线程生成器"><a href="#Java-21-线程生成器" class="headerlink" title="(Java 21) 线程生成器"></a>(Java 21) 线程生成器</h3><p>Java 21为我们新增了一个<code>ofPlatform()</code>方法，它可以快速生成一个创建平台线程（就是我们上面介绍的线程，下面还会介绍虚拟线程）的线程生成器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.ofPlatform()<br>        .name(<span class="hljs-string">&quot;线程01&quot;</span>)   <span class="hljs-comment">//直接调用方法设置线程的相关属性</span><br>        .daemon(<span class="hljs-literal">true</span>)   <span class="hljs-comment">//是否为守护线程</span><br>        .priority(Thread.MAX_PRIORITY)  <span class="hljs-comment">//设置优先级</span><br>        .inheritInheritableThreadLocals(<span class="hljs-literal">false</span>)  <span class="hljs-comment">//是否允许InheritableThreadLocal继承数据</span><br>        .start(() -&gt; &#123;    <span class="hljs-comment">//配置好后一键启动</span><br>            System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>使用此线程生成器帮我们创建线程来的更快更直接一点。</p><p>对于线程内发生的异常，我们还可以为其指定异常处理器，通过调用<code>uncaughtExceptionHandler</code>方法来指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.ofPlatform()<br>        .uncaughtExceptionHandler((t, exception) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;检测到线程执行中出现异常: &quot;</span> + exception);<br>        &#125;)<br>        .start(() -&gt; &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;我出事了！&quot;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><p>此外，我们还可以为线程设定其堆栈大小。这个堆栈是什么意思呢，由于现在各位小伙伴还没有学习JVM底层原理，这里就简单给大家解释一下。假设现在我们执行这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test1();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>    test2();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是最里面&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们在<code>main</code>方法内调用<code>test1</code>方法，然后<code>test1</code>内又调用<code>test2</code>方法，在方法的调用过程中，实际上有一个专门的栈结构，在储存方法的调用和其参数。我们每向下调用一次方法，那么方法信息以及其携带的参数就会进栈，像这样的东西我们一般称为”栈帧”，然后等待位于最顶上的方法执行完毕：</p><p><img src="https://s2.loli.net/2025/07/09/ZGIktoeiC1gPFNd.png" alt="image-20250709174657728"></p><p>当最顶上的方法结束之后，栈中的对应的栈帧便会离开，从而继续执行下一个位于栈顶的方法：</p><p><img src="https://s2.loli.net/2025/07/09/1pflz2dUjiL76KI.png" alt="image-20250709175203003"></p><p>大致原理就是这样，程序的执行需要用到栈来维护秩序。不过栈的深度是有限制的，就像我们之前使用递归的形式调用方法，如果不加以限制，那么栈中将无限制插入栈帧，这肯定会出现问题。默认情况下，栈的深度由JVM自动设定，我们也可以手动干预每个线程的最大栈深度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Thread.ofPlatform()<br>            .start(Main::test1);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">//写个递归无限往下</span><br>    System.out.println(i++);  <span class="hljs-comment">//打印i来查看调用深度</span><br>    test1();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/Yt1u4mpZ6IoTMxH.png" alt="image-20250709180135817"></p><p>默认情况下，在深度达到30000左右时出现了爆栈的情况（不同的系统可能结果不一样）我们可以通过配置<code>stackSize</code>来建议此线程使用多大的栈空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Thread.ofPlatform()<br>            .stackSize(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>)  <span class="hljs-comment">//空间大小，单位为Byte，这里给了10MB</span><br>            .start(Main::test1);<br>&#125;<br></code></pre></td></tr></table></figure><p>重新执行后，可以看到，调用深度比刚刚大了不少：</p><p><img src="https://s2.loli.net/2025/07/09/PKJjm5yblLGx8WD.png" alt="image-20250709180451994"></p><p>不过这个参数只是建议，如果给的过大或者过小都会强制使用预设的最大最小值。</p><h3 id="Java-21-虚拟线程"><a href="#Java-21-虚拟线程" class="headerlink" title="(Java 21) 虚拟线程"></a>(Java 21) 虚拟线程</h3><p>虚拟线程（Virtual Threads）是Java在JDK 19中引入的一项新特性，旨在简化并发编程模型，提升高并发应用的性能和可扩展性，此功能最终在Java 21版本实装上线。</p><p>虚拟线程是Java中的一种轻量级线程，由Java虚拟机（JVM）管理，与我们之前介绍的传统的操作系统级线程（Platform Threads）相比，它免去了平台线程的CPU的上下文切换，而是由程序在线程内自行控制，消耗的资源更少，启动和切换速度更快，进而可以在同一物理线程上并发执行大量虚拟线程。其核心优势为：</p><ul><li><strong>高并发能力</strong>：数以万计的虚拟线程可以在少量的操作系统线程上并发执行，极大提升应用的并发能力。</li><li><strong>简化编程模型</strong>：开发者可以使用同步的阻塞式代码编写异步或高并发逻辑，无需手动管理复杂的回调或异步框架。</li><li><strong>资源效率</strong>：虚拟线程内存占用较少，启动速度快，有助于构建高性能的服务器和微服务。</li></ul><p>综上，虚拟线程实际上是在单个线程内进一步细分的产物：</p><p><img src="https://s2.loli.net/2025/07/09/A3ugTDX4GI27bHz.png" alt="image-20250709155427062"></p><p>线程在Java中分为两种：</p><ul><li><strong>平台线程：</strong> 就是我们上面讲解的线程，由操作系统进行调度。</li><li><strong>虚拟线程：</strong> 本节介绍的由JVM在线程内部调度的线程。</li></ul><p>创建虚拟线程非常简单，直接使用<code>startVirtualThread</code>方法即可，它和线程的用法是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.startVirtualThread(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是虚拟线程&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>注意，虚拟线程和平台线程不一样，它默认就是守护线程且不能修改，也就是说主线程结束它也会跟着结束，所以上面的代码我们执行之后不会出现任何内容。我们需要使用<code>join</code>在主线程等待其完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.startVirtualThread(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;我是虚拟线程&quot;</span>);<br>&#125;).join();<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/J8sNqAhSbY2gjyP.png" alt="image-20250709181308353"></p><p>除此之外，我们也可以使用生成器创建虚拟线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.ofVirtual()<br>        .name(<span class="hljs-string">&quot;虚拟线程 01&quot;</span>)<br>        .start(() -&gt; System.out.println(<span class="hljs-string">&quot;我真的是虚拟线程&quot;</span>));<br></code></pre></td></tr></table></figure><p>注意，虚拟线程不支持使用<code>stop</code>结束线程，调用会报错。有关虚拟线程的实现原理和更多用法，我们会在JUC篇和Java学习路线的后续课程中逐步介绍。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p><strong>注意：</strong> 本章节涉及到JVM相关底层原理，难度会有一些大。</p><p>反射就是把Java类中的各个成分映射成一个个的Java对象。即在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，对于任意一个对象，都能调用它的任意一个方法和属性。这种动态获取信息及动态调用对象方法的功能叫Java的反射机制。</p><p>简而言之，我们可以通过反射机制，获取到类的一些属性，包括类里面有哪些字段，有哪些方法，继承自哪个类，甚至还能获取到泛型！它的权限非常高，慎重使用！</p><h3 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h3><p>在学习Java的反射机制之前，我们需要先了解一下类的加载机制，一个类是如何被加载和使用的：</p><p><img src="https://s2.loli.net/2022/10/04/vZ4onhuJWcALHNP.png" alt="image-20221004213335479"></p><p>在Java程序启动时，JVM会将一部分类（class文件）先加载（并不是所有的类都会在一开始加载），通过ClassLoader将类加载，在加载过程中，会将类的信息提取出来（存放在元空间中，JDK1.8之前存放在永久代），同时也会生成一个Class对象存放在内存（堆内存），注意此Class对象只会存在一个，与加载的类唯一对应！</p><p>为了方便各位小伙伴理解，你们就直接理解为默认情况下（仅使用默认类加载器）每个类都有且只有一个唯一的Class对象存放在JVM中，我们无论通过什么方式访问，都是始终是那一个对象。Class对象中包含我们类的一些信息，包括类里面有哪些方法、哪些变量等等。</p><h3 id="Class类获取"><a href="#Class类获取" class="headerlink" title="Class类获取"></a>Class类获取</h3><p>通过前面，我们了解了类的加载，同时会提取一个类的信息生成Class对象存放在内存中，而反射机制其实就是利用这些存放的类信息，来获取类的信息和操作类。那么如何获取到每个类对应的Class对象呢，我们可以通过以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>    Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>    Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;cpdd&quot;</span>).getClass();  <span class="hljs-comment">//通过实例对象获取</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意Class类也是一个泛型类，只有第一种方法，能够直接获取到对应类型的Class对象，而以下两种方法使用了<code>?</code>通配符作为返回值，但是实际上都和第一个返回的是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;String&gt; clazz = String.class;   <span class="hljs-comment">//使用class关键字，通过类名获取</span><br>Class&lt;?&gt; clazz2 = Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);   <span class="hljs-comment">//使用Class类静态方法forName()，通过包名.类名获取，注意返回值是Class&lt;?&gt;</span><br>Class&lt;?&gt; clazz3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;cpdd&quot;</span>).getClass();<br><br>System.out.println(clazz == clazz2);<br>System.out.println(clazz == clazz3);<br></code></pre></td></tr></table></figure><p>通过比较，验证了我们一开始的结论，在JVM中每个类始终只存在一个Class对象，无论通过什么方法获取，都是一样的。现在我们再来看看这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-type">int</span>.class;   <span class="hljs-comment">//基本数据类型有Class对象吗？</span><br>    System.out.println(clazz);<br>&#125;<br></code></pre></td></tr></table></figure><p>迷了，不是每个类才有Class对象吗，基本数据类型又不是类，这也行吗？实际上，基本数据类型也有对应的Class对象（反射操作可能需要用到），而且我们不仅可以通过class关键字获取，其实本质上是定义在对应的包装类中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &#123;<span class="hljs-doctag">@code</span> Class&#125; instance representing the primitive type</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> int&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="hljs-string">&quot;int&quot;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Return the Virtual Machine&#x27;s Class object for the named</span><br><span class="hljs-comment"> * primitive type</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getPrimitiveClass(String name);   <span class="hljs-comment">//C++实现，并非Java定义</span><br></code></pre></td></tr></table></figure><p>每个包装类中（包括Void），都有一个获取原始类型Class方法，注意，getPrimitiveClass获取的是原始类型，并不是包装类型，只是可以使用包装类来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-type">int</span>.class;<br>    System.out.println(Integer.TYPE == <span class="hljs-type">int</span>.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对比，我们发现实际上包装类型都有一个TYPE，其实也就是基本类型的Class，那么包装类的Class和基本类的Class一样吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Integer.TYPE == Integer.class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，包装类型的Class对象并不是基本类型Class对象。</p><p>数组类型也是一种类型，只是编程不可见，因此我们可以直接获取数组的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;String[]&gt; clazz = String[].class;<br>    System.out.println(clazz.getName());  <span class="hljs-comment">//获取类名称（得到的是包名+类名的完整名称）</span><br>    System.out.println(clazz.getSimpleName());<br>    System.out.println(clazz.getTypeName());<br>    System.out.println(clazz.getClassLoader());   <span class="hljs-comment">//获取它的类加载器</span><br>    System.out.println(clazz.cast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;10&quot;</span>)));   <span class="hljs-comment">//强制类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下节课，我们将开始对Class对象的使用进行讲解。</p><h3 id="Class对象与多态"><a href="#Class对象与多态" class="headerlink" title="Class对象与多态"></a>Class对象与多态</h3><p>正常情况下，我们使用instanceof进行类型比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str <span class="hljs-keyword">instanceof</span> String);<br>&#125;<br></code></pre></td></tr></table></figure><p>它可以判断一个对象是否为此接口的实现或是类的子类，而现在我们有了更多的方式去判断类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    System.out.println(str.getClass() == String.class);   <span class="hljs-comment">//直接判断是否为这个类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要判断是否为子类或是接口&#x2F;抽象类的实现，我们可以使用<code>asSubClass()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    i.getClass().asSubclass(Number.class);   <span class="hljs-comment">//当Integer不是Number的子类时，会产生异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>getSuperclass()</code>方法，我们可以获取到父类的Class对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.out.println(i.getClass().getSuperclass());<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以通过<code>getGenericSuperclass()</code>获取父类的原始类型的Type：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">Type</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> i.getClass().getGenericSuperclass();<br>    System.out.println(type);<br>    System.out.println(type <span class="hljs-keyword">instanceof</span> Class);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现Type实际上是Class类的父接口，但是获取到的Type的实现并不一定是Class。</p><p>同理，我们也可以像上面这样获取父接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : i.getClass().getInterfaces()) &#123;<br>        System.out.println(anInterface.getName());<br>    &#125;<br>  <br>  <span class="hljs-keyword">for</span> (Type genericInterface : i.getClass().getGenericInterfaces()) &#123;<br>        System.out.println(genericInterface.getTypeName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉反射功能很强大？几乎类的所有信息都可以通过反射获得。</p><h3 id="创建类对象"><a href="#创建类对象" class="headerlink" title="创建类对象"></a>创建类对象</h3><p>既然我们拿到了类的定义，那么是否可以通过Class对象来创建对象、调用方法、修改变量呢？当然是可以的，那我们首先来探讨一下如何创建一个类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用<code>newInstance()</code>方法来创建对应类型的实例，返回泛型T，注意它会抛出InstantiationException和IllegalAccessException异常，那么什么情况下会出现异常呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String text)</span>&#123;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当类默认的构造方法被带参构造覆盖时，会出现InstantiationException异常，因为<code>newInstance()</code>只适用于默认无参构造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当默认无参构造的权限不是<code>public</code>时，会出现IllegalAccessException异常，表示我们无权去调用默认构造方法。在JDK9之后，不再推荐使用<code>newInstance()</code>方法了，而是使用我们接下来要介绍到的，通过获取构造器，来实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test(); <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String str)</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过获取类的构造方法（构造器）来创建对象实例，会更加合理，我们可以使用<code>getConstructor()</code>方法来获取类的构造方法，同时我们需要向其中填入参数，也就是构造方法需要的类型，当然我们这里只演示了。那么，当访问权限不是public的时候呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> clazz.getConstructor(String.class).newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>    student.test();<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String str)</span>&#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，当访问权限不足时，会无法找到此构造方法，那么如何找到非public的构造方法呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Student&gt; clazz = Student.class;<br>Constructor&lt;Student&gt; constructor = clazz.getDeclaredConstructor(String.class);<br>constructor.setAccessible(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//修改访问权限</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> constructor.newInstance(<span class="hljs-string">&quot;what&#x27;s up&quot;</span>);<br>student.test();<br></code></pre></td></tr></table></figure><p>使用<code>getDeclaredConstructor()</code>方法可以找到类中的非public构造方法，但是在使用之前，我们需要先修改访问权限，在修改访问权限之后，就可以使用非public方法了（这意味着，反射可以无视权限修饰符访问类的内容）</p><h3 id="调用类方法"><a href="#调用类方法" class="headerlink" title="调用类方法"></a>调用类方法</h3><p>我们可以通过反射来调用类的方法（本质上还是类的实例进行调用）只是利用反射机制实现了方法的调用，我们在包下创建一个新的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;萨日朗&quot;</span>+str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这次我们通过<code>forName(String)</code>来找到这个类并创建一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用<code>getMethod()</code>方法，我们可以获取到类中所有声明为public的方法，得到一个Method对象，我们可以通过Method对象的<code>invoke()</code>方法（返回值就是方法的返回值，因为这里是void，返回值为null）来调用已经获取到的方法，注意传参。</p><p>我们发现，利用反射之后，在一个对象从构造到方法调用，没有任何一处需要引用到对象的实际类型，我们也没有导入Student类，整个过程都是反射在代替进行操作，使得整个过程被模糊了，过多的使用反射，会极大地降低后期维护性。</p><p>同构造方法一样，当出现非public方法时，我们可以通过反射来无视权限修饰符，获取非public方法并调用，现在我们将<code>test()</code>方法的权限修饰符改为private：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.newInstance();   <span class="hljs-comment">//创建出学生对象</span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    method.setAccessible(<span class="hljs-literal">true</span>);<br><br>    method.invoke(instance, <span class="hljs-string">&quot;what&#x27;s up&quot;</span>);   <span class="hljs-comment">//通过Method对象的invoke方法来调用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Method和Constructor都和Class一样，他们存储了方法的信息，包括方法的形式参数列表，返回值，方法的名称等内容，我们可以直接通过Method对象来获取这些信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//通过方法名和形参类型获取类中的方法</span><br>    <br>    System.out.println(method.getName());   <span class="hljs-comment">//获取方法名称</span><br>    System.out.println(method.getReturnType());   <span class="hljs-comment">//获取返回值类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当方法的参数为可变参数时，我们该如何获取方法呢？实际上，我们在之前就已经提到过，可变参数实际上就是一个数组，因此我们可以直接使用数组的class对象表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;test&quot;</span>, String[].class);<br></code></pre></td></tr></table></figure><p>反射非常强大，尤其是我们提到的越权访问，但是请一定谨慎使用，别人将某个方法设置为private一定有他的理由，如果实在是需要使用别人定义为private的方法，就必须确保这样做是安全的，在没有了解别人代码的整个过程就强行越权访问，可能会出现无法预知的错误。</p><h3 id="修改类的属性"><a href="#修改类的属性" class="headerlink" title="修改类的属性"></a>修改类的属性</h3><p>我们还可以通过反射访问一个类中定义的成员字段也可以修改一个类的对象中的成员字段值，通过<code>getField()</code>方法来获取一个类定义的指定字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>    method.invoke(instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>在得到Field之后，我们就可以直接通过<code>set()</code>方法为某个对象，设定此属性的值，比如上面，我们就为instance对象设定值为100，当访问private字段时，同样可以按照上面的操作进行越权访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.test.Student&quot;</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> clazz.newInstance();<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;i&quot;</span>);   <span class="hljs-comment">//获取类的成员字段i</span><br>    field.setAccessible(<span class="hljs-literal">true</span>);<br>    field.set(instance, <span class="hljs-number">100</span>);   <span class="hljs-comment">//将类实例instance的成员字段i设置为100</span><br><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>);<br>    method.invoke(instance);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们已经知道，反射几乎可以把一个类的老底都给扒出来，任何属性，任何内容，都可以被反射修改，无论权限修饰符是什么，那么，如果我的字段被标记为final呢？现在在字段<code>i</code>前面添加<code>final</code>关键字，我们再来看看效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>我们可以发现，反射非常暴力，就连被定义为final字段的值都能强行修改，几乎能够无视一切阻拦。</p><p>我们来试试看修改一些其他的类型，比如JDK的官方类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ReflectiveOperationException &#123;<br>    List&lt;String&gt; i = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ArrayList.class.getDeclaredField(<span class="hljs-string">&quot;size&quot;</span>);<br>    field.setAccessible(<span class="hljs-literal">true</span>);<br>    field.set(i, <span class="hljs-number">10</span>);<br><br>    i.add(<span class="hljs-string">&quot;测试&quot;</span>);   <span class="hljs-comment">//只添加一个元素</span><br>    <span class="hljs-comment">//得到数组越界异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在Java 9之后，需要修改启动参数才能对官方类的私有属性的访问权限进行修改，打开IDEA，添加启动参数：<code>--add-opens java.base/java.util=ALL-UNNAMED</code>，这里的<code>java.util=ALL-UNNAMED</code>需要修改为对应的包名。</p><p>实际上，整个ArrayList体系由于我们的反射操作，导致被破坏，因此它已经无法正常工作了，同样的，我们甚至能直接通过反射修改String的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>Class&lt;String&gt; stringClass = String.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> stringClass.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>value.setAccessible(<span class="hljs-literal">true</span>);<br>value.set(str, <span class="hljs-string">&quot;World&quot;</span>.getBytes());<br>System.out.println(str);<br></code></pre></td></tr></table></figure><p>可以看到，我们通过反射强行修改了String内部的<code>value</code>字段（存储字符串内容的数组）打破了String为不可变字符串的约束，轻松破坏了Java世界的规则。再次强调，在进行反射操作时，必须注意是否安全，虽然拥有了创世主的能力，但是我们不能滥用，非特殊情况请不用使用反射API。</p><h3 id="Java-9-模块化机制"><a href="#Java-9-模块化机制" class="headerlink" title="(Java 9) 模块化机制"></a>(Java 9) 模块化机制</h3><p>在Java 9之前，Java程序主要是以 “包 (package)” 的方式组织代码，但是所有的代码都在一个整体中运行，没有明确的边界。Java 9引入<strong>模块（Module）</strong>的概念，帮助开发者更好地组织、封装和管理大型应用程序。模块化带来的优点：</p><ul><li><strong>更好的封装</strong>：只暴露需要对外使用的接口，其余内部实现细节隐藏起来。</li><li><strong>依赖管理</strong>：明确模块之间的依赖关系，避免“依赖地狱”。</li><li><strong>更快的启动和更小的内存占用</strong>：只加载需要的模块。</li><li><strong>更易维护和扩展</strong>：大型项目变得更有条理。</li></ul><p>可见，模块化机制实际上是为大型项目准备的，而我们目前阶段仅仅还在初学状态，这里可以为大家简单介绍一下项目如何进行模块化开发。我们可以将项目分为多个子模块，不同模块开发不同的内容，然后相互作为依赖使用。</p><p><img src="https://s2.loli.net/2025/07/25/LldWpCgbqr3YjHa.png" alt="image-20250725233619547"></p><p>比如我们可以在<code>app</code>模块中将<code>utils</code>作为依赖导入：</p><p><img src="https://s2.loli.net/2025/07/25/4iNoEJMnfcVhW1L.png" alt="image-20250725233919608"></p><p>此时我们就可以在<code>app</code>中直接使用<code>utils</code>里面定义的类和方法了，同样可以进行包的导入，就像使用JDK官方提供的类那样。当然，在JavaWeb阶段我们还会学习Maven，它相比我们这里的简单模块化来说，是一个更加强大的依赖管理和模块化工具，使用Maven来引入我们自己的模块或是别人的框架模块会更加简单和方便，现代化企业级项目基本都是基于Maven或Gradle进行开发。不过，无论通过哪种方式引入，实际上都适用于Java9的模块化机制。</p><p>项目现在是模块化的了，那么到底如何才能使用Java9的模块化机制呢？模块具有四种类型，我们首先介绍一下<strong>应用程序模块</strong>，在我们自己的项目中，我们可以在某个模块下的源代码根路径下新建一个叫做<code>module-info.java</code>的文件，它用于配置模块化信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.utils &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用<code>module</code>关键字（此关键字仅在模块化声明文件中生效）声明模块的名称，后面需要跟随一个花括号。</p><p>声明模块后，我们会发现项目中某些类无法正常使用了：</p><p><img src="https://s2.loli.net/2025/07/25/CHJB5ND7ASWvLch.png" alt="image-20250725235627947"></p><p>这是因为我们现在使用了模块机制，我们如果需要使用其他模块，需要手动进行导入，默认情况下，包中如果没有创建<code>module-info.java</code>文件，那么会按照<strong>未命名模块</strong>进行处理，未命名模块同样可以访问所有其他模块提供的类，这样我们之前写的Java 8代码才能正常地在Java 9以及之后的版本下运行。要在模块化的子模块中导入其他未命名模块，我们只需要使用其他模块的默认名称即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.app &#123;<br>    <span class="hljs-keyword">requires</span> utils;   <span class="hljs-comment">//其他模块的名称，默认是IDEA中的子模块名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>requires</code>关键字来导入模块，此时我们就成功引入了一个未命名模块，其中的类型就可以正常使用了。除此之外，我们也可以让这些模块同样包含一个<code>module-info.java</code>文件，并且为其手动指定模块名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.utils &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们就可以使用文件中定义的模块名称进行导入了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.app &#123;<br>    <span class="hljs-keyword">requires</span> hello.utils;  <span class="hljs-comment">//输入模块名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过此时依然会出现模块中类无法使用的问题，这是因为模块化之后，我们还需要手动指定哪些包可以供其他模块导入使用才可以，由于我们之前没有使用Java 9的模块新特性，<strong>未命名模块</strong>只能默认暴露给其他未命名的模块和自动模块，应用程序模块无法访问这些类（实际上就是传统Java 8以下的编程模式，因为没有模块只需要导入依赖就能直接用）现在模块化之后 ，我们需要使用<code>export</code>关键字来手动暴露哪些运行其他模块访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> hello.utils &#123;<br>    <span class="hljs-keyword">exports</span> com.test.utils;  <span class="hljs-comment">//输入你想要允许其他模块访问的包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加之后，这个包下的所有内容就可以在外部使用了，但是项目中未暴露的包依然是无法被外部模块去使用的。</p><ul><li>除了我们这里介绍的两种模块之外，还有一个叫做 <strong>系统模块</strong> 它是来自JDK和JRE的模块（官方提供的模块，比如我们之前使用的所有类都算），我们也可以直接使用<code>java --list-modules</code>命令来列出所有的模块，不同的模块会导出不同的包供我们使用。其中<code>java.base</code>模块包含我们之前使用的核心类如<code>java.lang</code>、<code>java.util</code>等，这个模块不需要我们手动进行导入，会自动包含。</li><li>当然，针对于一些可能并不是Java 9以上的模块项目，这种时候就需要做兼容了，默认情况下是直接导出所有的包，可以访问所有其他模块提供的类，不然之前版本的库就用不了了，这种类型的模块我们称为<strong>自动模块</strong>。</li></ul><p>我们最后来回顾一下前面讲解的反射机制，我们发现如果我们现在虽然可以依赖了一个模块，但是是没办法直接进行越级反射操作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;Utils&gt; utilsClass = Utils.class;<br><span class="hljs-type">Method</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> utilsClass.getDeclaredMethod(<span class="hljs-string">&quot;hello&quot;</span>);<br>hello.setAccessible(<span class="hljs-literal">true</span>);<br>hello.invoke( <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/26/f1KOc5gPSAh4opr.png" alt="image-20250726001257644"></p><p>这个错误实际上在我们前面的JDK类中进行反射操作也出现了，要允许其他模块使用越级反射操作，我们可以在模块的前面添加<code>open</code>关键字来允许其他模块的越级访问操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">open <span class="hljs-keyword">module</span> hello.utils &#123;<br>    <span class="hljs-keyword">exports</span> com.test.utils;<br>    <span class="hljs-comment">//open也可以单独指定某个包</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们再去使用反射修改权限就没有问题了。而前面修改JDK类遇到的问题也是一样的原因，因为默认情况下JDK的官方模块并未向我们open访问权限，所以无法直接进行越级反射操作。除此之外，模块还支持单独标明接口和模块对于接口的实现，用到<code>provide</code>和<code>uses</code>关键字，有关具体内容我们会在JavaWeb阶段进一步补充。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>我们接着来介绍一下类加载器，实际上类加载器就是用于加载一个类的，但是类加载器并不是只有一个。我们来研究一下Java9之后的类加载机制（Java8之前流程请看旧版课程）</p><blockquote><p>ClassLoader（类加载器）是Java中的一个重要组件，负责在运行时将类的字节码加载到JVM中。</p></blockquote><p>Java中所有的类都是依靠类加载器进行加载并生成对应的Class对象，类加载器不止一个而是有多个，不同的类加载器的职责也不一样，类加载器默认有以下三种：</p><ul><li><strong>BootClassLoader</strong>：启动类加载器，用于加载JDK核心模块，如<code>java.base</code>、<code>java.desktop</code>、<code>java.logging </code>等。</li><li><strong>PlatformClassLoader</strong>：平台类加载器，用于加载一些平台相关模块，也就是一些扩展类，如<code>java.compiler</code>、<code>java.sql</code>等。</li><li><strong>AppClassLoader</strong>：应用类加载器，主要用于加载我们自己编写的类，以及其他JDK中没有被上述两个类加载器加载的模块和类。</li></ul><p>对于采用模块化的项目来说，在程序启动后，根据不同的模块划分，不同类会在一开始直接分配给对应的ClassLoader进行加载：</p><p><img src="https://s2.loli.net/2025/07/26/FDLJfg74QN6jxcC.png" alt="image-20250726155642491"></p><p>对于传统非模块化项目来说，在程序启动后，会按照Java8之前的双亲委派机制进行类的加载：</p><p><img src="https://s2.loli.net/2025/07/26/rQg5JciKZxpePUf.png" alt="image-20250726160510070"></p><p>当类需要进行加载时，默认会由最下层的AppClassLoader接手，但并不会立即加载类，而是向上传递询问其父类加载器PlatformClassLoader能否进行加载，同样的PlatformClassLoader也不会立即加载，而是继续向上传递到顶层BootClassLoader进行判断，如果顶层可以直接加载这些类（比如JDK核心类就可以直接加载）那么会直接在BootClassLoader中完成类加载，并直接得到对应的Class对象，如果顶层不行，再继续向下让PlatformClassLoader进行加载，如果还是无法加载，最后才会让AppClassLoader尝试加载，比如我们自己编写的类就是由AppClassLoader完成加载的，这样的类加载机制我们也叫<strong>双亲委派机制</strong>。</p><p>我们可以来观察下不同类的类加载器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Main.class.getClassLoader());   <span class="hljs-comment">//查看当前类的类加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent());  <span class="hljs-comment">//父加载器</span><br>        System.out.println(Main.class.getClassLoader().getParent().getParent());  <span class="hljs-comment">//爷爷加载器</span><br>        System.out.println(String.class.getClassLoader());   <span class="hljs-comment">//JDK中String类的加载器</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于早期BootClassLoader是由C++编写的（叫做BootstarpClassLoader），因此在之前无法获取到对应的对象，Java9之后虽然已经变成Java类，但是为了保持统一就依然保持返回<code>null</code>作为结果。</p><p>通过前面的了解，既然通过ClassLoader就可以用来加载类，那么我们可以自己手动将class文件加载到JVM中吗？先写好我们定义的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> String text;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>        System.out.println(text+<span class="hljs-string">&quot; &gt; 我是测试方法！&quot;</span>+str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过javac命令，手动编译一个.class文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">nagocoler<span class="hljs-meta">@NagodeMacBook</span>-Pro HelloWorld % javac src/main/java/com/test/Test.java<br></code></pre></td></tr></table></figure><p>编译后，得到一个class文件，我们把它放到根目录下。因为上面提到的这三种ClassLoader都无法直接加载class文件，因此我们需要编写一个自定义的类加载器来让它支持读取byte数据加载类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自己定义一个ClassLoader</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name, String file) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)) &#123;  <span class="hljs-comment">//读取磁盘类文件</span><br>            <span class="hljs-type">byte</span>[] bytes = stream.readAllBytes();<br>            <span class="hljs-keyword">return</span> defineClass(name, bytes, <span class="hljs-number">0</span>, bytes.length);  <span class="hljs-comment">//使用父类提供的defineClass通过byte数据加载类</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-type">TestClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestClassLoader</span>();<br>    System.out.println(classLoader.getParent());<br>    Class&lt;?&gt; clazz = classLoader.loadClass(<span class="hljs-string">&quot;com.test.Test&quot;</span>, <span class="hljs-string">&quot;Test.class&quot;</span>);<br>    System.out.println(clazz);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们就将此class文件读取并解析为Class了，并且我们自己创建的类加载器，会将AppClassLoader作为父类加载，现在我们就可以对此类进行操作了（注意，我们无法在代码中直接使用此类型，因为它是我们直接加载的，只能通过反射来操作），我们来试试看创建一个此类的对象并调用其方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试看修改成员字段之后，再来调用此方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>    <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> clazz.getField(<span class="hljs-string">&quot;text&quot;</span>);   <span class="hljs-comment">//获取成员变量 String text;</span><br>    field.set(obj, <span class="hljs-string">&quot;华强&quot;</span>);<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>, String.class);   <span class="hljs-comment">//获取我们定义的test(String str)方法</span><br>    method.invoke(obj, <span class="hljs-string">&quot;哥们这瓜多少钱一斤？&quot;</span>);<br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们就可以实现外部加载甚至是网络加载一个类，只需要把类文件传递即可，这样就无需再将代码写在本地，而是动态进行传递，不仅可以一定程度上防止源代码被反编译（只是一定程度上，想破解你代码有的是方法），而且在更多情况下，我们还可以对byte[]进行加密，保证在传输过程中的安全性。</p><hr><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><strong>注意：</strong> 注解跟我们之前讲解的注释完全不是一个概念，不要搞混了。</p><p>其实我们在之前就接触到注解了，比如<code>@Override</code>表示重写父类方法（当然不加效果也是一样的，此注解在编译时会被自动丢弃）注解本质上也是一个类，只不过它的用法比较特殊。</p><p>注解可以被标注在任意地方，包括方法上、类名上、参数上、成员属性上、注解定义上等，就像注释一样，它相当于我们对某样东西的一个标记。而与注释不同的是，注解可以通过反射在运行时获取，注解也可以选择是否保留到运行时。</p><h3 id="预设注解"><a href="#预设注解" class="headerlink" title="预设注解"></a>预设注解</h3><p>JDK预设了以下注解，作用于代码：</p><ul><li><a href="">@Override </a>- 检查（仅仅是检查，不保留到运行时）该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 </li><li><a href="">@Deprecated </a>- 标记过时方法。如果使用该方法，会报编译警告。 </li><li><a href="">@SuppressWarnings </a>- 指示编译器去忽略注解中声明的警告（仅仅编译器阶段，不保留到运行时） </li><li><a href="">@FunctionalInterface </a>- Java 8 开始支持，标识一个匿名函数或函数式接口。 </li><li><a href="">@SafeVarargs </a>- Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是作用于注解上的注解，用于我们编写自定义的注解：</p><ul><li><a href="">@Retention </a>- 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 </li><li><a href="">@Documented </a>- 标记这些注解是否包含在用户文档中。 </li><li><a href="">@Target </a>- 标记这个注解应该是哪种 Java 成员。 </li><li><a href="">@Inherited </a>- 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) </li><li><a href="">@Repeatable </a>- Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><p>看了这么多预设的注解，你们肯定眼花缭乱了，那我们来看看<code>@Override</code>是如何定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>该注解由<code>@Target</code>限定为只能作用于方法上，ElementType是一个枚举类型，用于表示此枚举的作用域，一个注解可以有很多个作用域。<code>@Retention</code>表示此注解的保留策略，包括三种策略，在上述中有写到，而这里定义为只在代码中。一般情况下，自定义的注解需要定义1个<code>@Retention</code>和1-n个<code>@Target</code>。</p><p>既然了解了元注解的使用和注解的定义方式，我们就来尝试定义一个自己的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们定义一个Test注解，并将其保留到运行时，同时此注解可以作用于方法或是类上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个最简单的注解就被我们创建了。</p><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>我们还可以在注解中定义一些属性，注解的属性也叫做成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认只有一个属性时，我们可以将其名字设定为value，否则，我们需要在使用时手动指定注解的属性名称，使用value则无需填入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-meta">@Test(test = &quot;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用default关键字来为这些属性指定默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;都看到这里了，给个三连吧！&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当属性存在默认值时，使用注解的时候可以不用传入属性值。当属性为数组时呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    String[] value();<br>&#125;<br></code></pre></td></tr></table></figure><p>当属性为数组，我们在使用注解传参时，如果数组里面只有一个内容，我们可以直接传入一个值，而不是创建一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test(&quot;关注点了吗&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-meta">@Test(&#123;&quot;value1&quot;, &quot;value2&quot;&#125;)</span>   <span class="hljs-comment">//多个值时就使用花括号括起来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反射获取注解"><a href="#反射获取注解" class="headerlink" title="反射获取注解"></a>反射获取注解</h3><p>既然我们的注解可以保留到运行时，那么我们来看看，如何获取我们编写的注解，我们需要用到反射机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过反射机制，我们可以快速获取到我们标记的注解，同时还能获取到注解中填入的值，那么我们来看看，方法上的标记是不是也可以通过这种方式获取注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br>    Class&lt;Student&gt; clazz = Student.class;<br>    <span class="hljs-keyword">for</span> (Annotation annotation : clazz.getMethod(<span class="hljs-string">&quot;test&quot;</span>).getAnnotations()) &#123;<br>        System.out.println(annotation.annotationType());   <span class="hljs-comment">//获取类型</span><br>        System.out.println(annotation <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//直接判断是否为Test</span><br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (Test) annotation;<br>        System.out.println(test.value());   <span class="hljs-comment">//获取我们在注解中写入的内容</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是方法、类、还是字段，都可以使用<code>getAnnotations()</code>方法（还有几个同名的）来快速获取我们标记的注解。</p><p>所以说呢，这玩意学来有啥用？丝毫get不到这玩意的用处。其实不是，现阶段作为初学者，还体会不到注解带来的快乐，在接触到Spring和SpringBoot等大型框架后，相信各位就能感受到注解带来的魅力了。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/qrd0xfttsz32gpqg">https://www.itbaima.cn/zh-CN/document/qrd0xfttsz32gpqg</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（六）集合类与IO</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8EIO/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E9%9B%86%E5%90%88%E7%B1%BB%E4%B8%8EIO/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/10/04/SkAn9RQpqC4tVW5.png" alt="image-20221004131436371"></p><h1 id="集合类与IO"><a href="#集合类与IO" class="headerlink" title="集合类与IO"></a>集合类与IO</h1><p>前面我们已经把基础介绍完了，从这节课开始，我们就正式进入到集合类的讲解中。</p><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>集合类是Java中非常重要的存在，使用频率极高。集合其实与我们数学中的集合是差不多的概念，集合表示一组对象，每一个对象我们都可以称其为元素。不同的集合有着不同的性质，比如一些集合允许重复的元素，而另一些则不允许，一些集合是有序的，而其他则是无序的。</p><p><img src="https://s2.loli.net/2022/09/30/ZWxPduaYGgRzmNO.png" alt="image-20220930233059528"></p><p>集合类其实就是为了更好地组织、管理和操作我们的数据而存在的，包括列表、集合、队列、映射等数据结构。从这一块开始，我们会从源码角度给大家讲解（先从接口定义对于集合需要实现哪些功能开始说起，包括这些集合类的底层机制是如何运作的）不仅仅是教会大家如何去使用。</p><p>集合跟数组一样，可以表示同样的一组元素，但是他们的相同和不同之处在于：</p><ol><li>它们都是容器，都能够容纳一组元素。</li></ol><p>不同之处：</p><ol><li>数组的大小是固定的，集合的大小是可变的。</li><li>数组可以存放基本数据类型，但集合只能存放对象。</li><li>数组存放的类型只能是一种，但集合可以有不同种类的元素。</li></ol><h3 id="集合根接口"><a href="#集合根接口" class="headerlink" title="集合根接口"></a>集合根接口</h3><p>Java中已经帮我们将常用的集合类型都实现好了，我们只需要直接拿来用就行了，比如我们之前学习的顺序表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;   <span class="hljs-comment">//集合类基本都是在java.util包下定义的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;树脂666&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们会在这一部分中认识大部分Java为我们提供的集合类。所有的集合类最终都是实现自集合根接口的，比如我们下面就会讲到的ArrayList类，它的祖先就是Collection接口：</p><p><img src="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png" alt="image-20250708234355615"></p><p>这个接口定义了集合类的一些基本操作，我们来看看有哪些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//-------这些是查询相关的操作----------</span><br><br>   <span class="hljs-comment">//获取当前集合中的元素数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看当前集合是否为空</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查询当前集合中是否包含某个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//返回当前集合的迭代器，我们会在后面介绍</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将集合转换为数组的形式</span><br>    Object[] toArray();<br><br>    <span class="hljs-comment">//支持泛型的数组转换，同上</span><br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//-------这些是修改相关的操作----------</span><br><br>    <span class="hljs-comment">//向集合中添加元素，不同的集合类具体实现可能会对插入的元素有要求，</span><br>  <span class="hljs-comment">//这个操作并不是一定会添加成功，所以添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//从集合中移除某个元素，同样的，移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">//-------这些是批量执行的操作----------</span><br><br>    <span class="hljs-comment">//查询当前集合是否包含给定集合中所有的元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是看给定集合是不是当前集合的子集</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//添加给定集合中所有的元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是将当前集合变成当前集合与给定集合的并集</span><br>  <span class="hljs-comment">//添加成功返回true，否则返回false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br><br>    <span class="hljs-comment">//移除给定集合中出现的所有元素，如果某个元素在当前集合中不存在，那么忽略这个元素</span><br>  <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的差集</span><br>  <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//Java8新增方法，根据给定的Predicate条件进行元素移除操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();   <span class="hljs-comment">//这里用到了迭代器，我们会在后面进行介绍</span><br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br><br>    <span class="hljs-comment">//只保留当前集合中在给定集合中出现的元素，其他元素一律移除</span><br>  <span class="hljs-comment">//从数学角度来说，就是求当前集合与给定集合的交集</span><br>  <span class="hljs-comment">//移除成功返回true，否则false</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//清空整个集合，删除所有元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">//-------这些是比较以及哈希计算相关的操作----------</span><br><br>    <span class="hljs-comment">//判断两个集合是否相等</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//计算当前整个集合对象的哈希值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//与迭代器作用相同，但是是并行执行的，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的流，我们会在后面进行讲解</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//生成当前集合的并行流，我们会在下一章多线程部分中进行介绍</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在这个接口中对于集合相关的操作，还是比较齐全的，那么我们接着就来看看它的实现类。</p><h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><p>首先我们需要介绍的是List列表（线性表），线性表支持随机访问，相比之前的Collection接口定义，功能还会更多一些。首先介绍ArrayList，我们已经知道，它的底层是用数组实现的，内部维护的是一个可动态进行扩容的数组，也就是我们之前所说的顺序表，跟我们之前自己写的ArrayList相比，它更加的规范，并且功能更加强大，同时实现自List接口。</p><p><img src="https://s2.loli.net/2025/07/08/6tHdU5Fcawh3juN.png" alt="image-20250708234355615"></p><p>List是集合类型的一个分支，它的主要特性有：</p><ul><li>是一个有序的集合，插入元素默认是插入到尾部，按顺序从前往后存放，每个元素都有一个自己的下标位置</li><li>列表中允许存在重复元素</li></ul><p>在List接口中，定义了列表类型需要支持的全部操作，List继承自SequencedCollection接口，此接口是Java 21新增接口，此前List接口直接继承自Collection接口（老版图片放在迭代器部分）此接口额外定义了获取第一个元素、最后一个元素，生成反向集合视图等功能，统一了所有有序集合的操作定义，这些内容我们会放在后面进行介绍。</p><p>可以看到在List接口中，很多地方重新定义了一次Collection和SequencedCollection接口中定义的方法，虽然没有任何修改，但是这样做是为了更加明确方法的具体功能，当然，为了直观，我们这里就省略掉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//List是一个有序的集合类，每个元素都有一个自己的下标位置</span><br><span class="hljs-comment">//List中可插入重复元素</span><br><span class="hljs-comment">//针对于这些特性，扩展了Collection接口中一些额外的操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    ...<br>   <br>    <span class="hljs-comment">//将给定集合中所有元素插入到当前结合的给定位置上（后面的元素就被挤到后面去了，跟我们之前顺序表的插入是一样的）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span>;<br><br>    ...<br><br>   <span class="hljs-comment">//Java 8新增方法，可以对列表中每个元素都进行处理，并将元素替换为处理之后的结果</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> &#123;<br>        Objects.requireNonNull(operator);<br>        <span class="hljs-keyword">final</span> ListIterator&lt;E&gt; li = <span class="hljs-built_in">this</span>.listIterator();  <span class="hljs-comment">//这里同样用到了迭代器</span><br>        <span class="hljs-keyword">while</span> (li.hasNext()) &#123;<br>            li.set(operator.apply(li.next()));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//对当前集合按照给定的规则进行排序操作，这里同样只需要一个Comparator就行了</span><br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span> &#123;<br>        Object[] a = <span class="hljs-built_in">this</span>.toArray();<br>        Arrays.sort(a, (Comparator) c);<br>        ListIterator&lt;E&gt; i = <span class="hljs-built_in">this</span>.listIterator();<br>        <span class="hljs-keyword">for</span> (Object e : a) &#123;<br>            i.next();<br>            i.set((E) e);<br>        &#125;<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-comment">//-------- 这些是List中独特的位置直接访问操作 --------</span><br><br>   <span class="hljs-comment">//获取对应下标位置上的元素</span><br>    E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    <span class="hljs-comment">//直接将对应位置上的元素替换为给定元素</span><br>    E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    <span class="hljs-comment">//在指定位置上插入元素，就跟我们之前的顺序表插入是一样的</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>;<br><br>    <span class="hljs-comment">//移除指定位置上的元素</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List中独特的搜索操作 -------</span><br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的第一次出现的下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//查询某个元素在当前列表中的最后一次出现的下标位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">lastIndexOf</span><span class="hljs-params">(Object o)</span>;<br><br><br>    <span class="hljs-comment">//------- 这些是List的专用迭代器 -------</span><br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//迭代器我们会在下一个部分讲解</span><br>    ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br><br>    <span class="hljs-comment">//------- 这些是List的特殊转换 -------</span><br><br>    <span class="hljs-comment">//返回当前集合在指定范围内的子集</span><br>    List&lt;E&gt; <span class="hljs-title function_">subList</span><span class="hljs-params">(<span class="hljs-type">int</span> fromIndex, <span class="hljs-type">int</span> toIndex)</span>;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在List接口中，扩展了大量列表支持的操作，其中最突出的就是直接根据下标位置进行的增删改查操作。而在ArrayList中，底层就是采用数组实现的，跟我们之前的顺序表思路差不多（如果需要学习老版本请观看22年旧版JavaSE视频课程）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br>&#123;<br><br>    <span class="hljs-comment">//默认的数组容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    ...<br><br>    <span class="hljs-comment">//存放数据的底层数组，这里的transient关键字我们会在后面I/O中介绍用途</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br><br>    <span class="hljs-comment">//记录当前数组元素数的</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>   <span class="hljs-comment">//这是ArrayList的其中一个构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];   <span class="hljs-comment">//根据初始化大小，创建当前列表</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                               initialCapacity);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">//这是ArrayList的无参构造方法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>    &#125;<br>  <br>  ...<br>      <br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        modCount++;   <span class="hljs-comment">//用于后期判断是否出现并发异常，比如遍历时修改或是多线程操作（暂时忽略）</span><br>        add(e, elementData, size);  <span class="hljs-comment">//调用内部私有辅助方法实现插入操作，因为是尾插，index直接写size就行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//直接返回真插入成功</span><br>    &#125;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-type">int</span> s)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s == elementData.length)   <span class="hljs-comment">//首先判断长度是否超出当前内部数组容量</span><br>            elementData = grow();   <span class="hljs-comment">//超出那么就得扩容，扩容会对类的elementData进行重新赋值，下面介绍</span><br>        elementData[s] = e;   <span class="hljs-comment">//接着正常插入元素即可</span><br>        size = s + <span class="hljs-number">1</span>;  <span class="hljs-comment">//让size自增</span><br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>        rangeCheckForAdd(index);   <span class="hljs-comment">//先判断插入位置是否超出范围</span><br>        modCount++;   <span class="hljs-comment">//同上</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> s;<br>        Object[] elementData;<br>      <span class="hljs-comment">//看着有点绕，但实际上就是让s等于size，elementData等于类的elementData</span><br>        <span class="hljs-comment">//然后再比较长度是否已经一样，一样就扩容，跟上面思路是差不多的</span><br>        <span class="hljs-keyword">if</span> ((s = size) == (elementData = <span class="hljs-built_in">this</span>.elementData).length)<br>            elementData = grow();<br>        System.arraycopy(elementData, index,<br>                         elementData, index + <span class="hljs-number">1</span>,<br>                         s - index);  <span class="hljs-comment">//因为是中间插入，这里调用C++实现的数组移动操作，把位置让出来</span><br>        elementData[index] = element;  <span class="hljs-comment">//位置让出来之后，设置新元素</span><br>        size = s + <span class="hljs-number">1</span>;  <span class="hljs-comment">//让size自增</span><br>    &#125;<br>  <br>  ...<br>  <br>    <span class="hljs-keyword">private</span> Object[] grow() &#123;<br>        <span class="hljs-keyword">return</span> grow(size + <span class="hljs-number">1</span>);   <span class="hljs-comment">//调用内部其他方法实现，并制定扩容最小值为当前容量+1</span><br>    &#125;<br>  <br>  <span class="hljs-keyword">private</span> Object[] grow(<span class="hljs-type">int</span> minCapacity) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;   <span class="hljs-comment">//首先保存下现在的容量</span><br>        <span class="hljs-keyword">if</span> (oldCapacity &gt; <span class="hljs-number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>            <span class="hljs-comment">//判断当前容量是否不为0（因为初始就是0，不为0一定被扩容过）</span><br>            <span class="hljs-comment">//然后计算新的容量，这里传入当前长度、最小扩容长度和推荐扩容长度三个参数，通过辅助方法衡量该如何扩容</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> ArraysSupport.newLength(oldCapacity,<br>                    minCapacity - oldCapacity, <span class="hljs-comment">/* 最小扩容长度 */</span><br>                    oldCapacity &gt;&gt; <span class="hljs-number">1</span>           <span class="hljs-comment">/* 推荐扩容长度 */</span>);<br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> Arrays.copyOf(elementData, newCapacity);  <span class="hljs-comment">//得到最终扩容大小，创建新数组</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//这里相当于现在容量为0，也就是初始状态，此时会直接创建一个容量为10的新数组</span><br>            <span class="hljs-comment">//注意这里需要取minCapacity和默认容量的最大值，因为grow不仅仅在单个插入时会调用，批量插入的时候也会调用，有可能出现批量插入20个的情况，那么初始容量就装不下了</span><br>            <span class="hljs-type">return</span> <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中具体的ArrayList扩容辅助类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//默认的列表最大长度为Integer.MAX_VALUE - 8</span><br>  <span class="hljs-comment">//因为在部分JVM的C++实现中，在数组的对象头中有一个_length字段，用于记录数组的长度</span><br>  <span class="hljs-comment">//所以这个8（保守估计，不一定是）就是存了数组_length字段（这个只做了解就行）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newLength</span><span class="hljs-params">(<span class="hljs-type">int</span> oldLength, <span class="hljs-type">int</span> minGrowth, <span class="hljs-type">int</span> prefGrowth)</span> &#123;<br>      <span class="hljs-comment">//计算新的长度，因为minGrowth和prefGrowth谁更大不确定，需要进行比较，然后得到新的长度</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">prefLength</span> <span class="hljs-operator">=</span> oldLength + Math.max(minGrowth, prefGrowth);<br>      <span class="hljs-comment">//接着比较新的长度是否已经超出数组允许的最大长度了</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;<br>          <span class="hljs-keyword">return</span> prefLength;  <span class="hljs-comment">//没有直接返回</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果超出最大长度，需要进一步处理</span><br>          <span class="hljs-keyword">return</span> hugeLength(oldLength, minGrowth);<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeLength</span><span class="hljs-params">(<span class="hljs-type">int</span> oldLength, <span class="hljs-type">int</span> minGrowth)</span> &#123;<br>      <span class="hljs-comment">//先看看现在需要的最小长度，因为走到这里有可能是因为prefLength过长，但并不代表就真的需要这么长，因为prefLength有可能加的是prefGrowth，不一定是最小值</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">minLength</span> <span class="hljs-operator">=</span> oldLength + minGrowth;  <br>      <span class="hljs-keyword">if</span> (minLength &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果加出来最小长度已经小于0了，那包是超过int最大值了（前面二进制章节有介绍为什么）</span><br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>(   <span class="hljs-comment">//直接无情抛异常</span><br>              <span class="hljs-string">&quot;Required array length &quot;</span> + oldLength + <span class="hljs-string">&quot; + &quot;</span> + minGrowth + <span class="hljs-string">&quot; is too large&quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;  <span class="hljs-comment">//如果在最大长度允许范围内</span><br>          <span class="hljs-keyword">return</span> SOFT_MAX_ARRAY_LENGTH;   <span class="hljs-comment">//直接给最大的</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> minLength;  <br>          <span class="hljs-comment">//这种情况相当于在SOFT_MAX_ARRAY_LENGTH和int最大值之间，没法了，只能直接返回</span><br>          <span class="hljs-comment">//虽然有些JVM会可能直接抛出异常，但是可以抱着试试的心态搞一下</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>所以Java为我们提供的ArrayList，默认情况下内部就是一个空的数组，需要使用时候会变成初始值10（或初始批量插入的长度）后续在单个插入时，如果容量不够，会自动按照1.5倍进行扩容，直到最大限制。如果是后续批量插入，则根据情况而定。</p><p>一般的，如果我们要使用一个集合类，我们会使用接口的引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();   <span class="hljs-comment">//使用接口的引用来操作具体的集合类实现，是为了方便日后如果我们想要更换不同的集合类实现，而且接口中本身就已经定义了主要的方法，所以说没必要直接用实现类</span><br>    list.add(<span class="hljs-string">&quot;科技与狠活&quot;</span>);   <span class="hljs-comment">//使用add添加元素</span><br>  list.add(<span class="hljs-string">&quot;上头啊&quot;</span>);<br>    System.out.println(list);   <span class="hljs-comment">//打印集合类，可以得到一个非常规范的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，打印集合类的效果，跟我们使用Arrays工具类是一样的：</p><p><img src="https://s2.loli.net/2022/10/01/v3uzfnhamXV5St8.png" alt="image-20221001002151164"></p><p>集合的各种功能我们都可以来测试一下，特别注意一下，我们在使用Integer时，要注意传参问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//添加Integer的值10</span><br>    list.remove((Integer) <span class="hljs-number">10</span>);   <span class="hljs-comment">//注意，不能直接用10，默认情况下会认为传入的是int类型值，删除的是下标为10的元素，我们这里要删除的是刚刚传入的值为10的Integer对象</span><br>    System.out.println(list);   <span class="hljs-comment">//可以看到，此时元素成功被移除</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那要是这样写呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">//添加的是一个对象</span><br>    list.remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>));   <span class="hljs-comment">//删除的是另一个对象</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，结果依然是删除成功，这是因为集合类在删除元素时，只会调用<code>equals</code>方法进行判断是否为指定元素，而不是进行等号判断，所以说一定要注意，如果两个对象使用<code>equals</code>方法相等，那么集合中就是相同的两个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ArrayList源码部分</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        ...<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;   <span class="hljs-comment">//这里只是对两个对象进行equals判断</span><br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">//只要判断成功，直接认为就是要删除的对象，删除就完事</span><br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>列表中允许存在相同元素，所以说我们可以添加两个一模一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哟唉嘛干你&quot;</span>;<br>    list.add(str);<br>    list.add(str);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/01/paeKLsGntNVfHPT.png" alt="image-20221001231509926"></p><p>那要是此时我们删除对象呢，是一起删除还是只删除一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;哟唉嘛干你&quot;</span>;<br>    list.add(str);<br>    list.add(str);<br>    list.remove(str);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/01/5HdFh74wlqbMoj6.png" alt="image-20221001231619391"></p><p>可以看到，这种情况下，只会删除排在前面的第一个元素。</p><p>集合类是支持嵌套使用的，一个集合中可以存放多个集合，套娃嘛，谁不会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;List&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;());   <span class="hljs-comment">//集合中的每一个元素就是一个集合，这个套娃是可以一直套下去的</span><br>    System.out.println(list.get(<span class="hljs-number">0</span>).isEmpty());<br>&#125;<br></code></pre></td></tr></table></figure><p>在Arrays工具类中，我们可以快速生成一个只读的List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);   <span class="hljs-comment">//非常方便</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个生成的List是只读的，不能进行修改操作，只能使用获取内容相关的方法，否则抛出 UnsupportedOperationException 异常。要生成正常使用的，我们可以将这个只读的列表作为参数传入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也可以利用类中的代码块实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;   <span class="hljs-comment">//使用匿名内部类（匿名内部类在Java8无法使用钻石运算符，但是之后的版本可以）</span><br>            add(<span class="hljs-string">&quot;A&quot;</span>);<br>            add(<span class="hljs-string">&quot;B&quot;</span>);<br>            add(<span class="hljs-string">&quot;C&quot;</span>);<br>    &#125;&#125;;<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们接着介绍另一个列表实现类，LinkedList同样是List的实现类，只不过它是采用的链式实现，也就是我们之前讲解的链表，只不过它是一个双向链表，也就是同时保存两个方向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//引用首结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br>    <span class="hljs-comment">//引用尾结点</span><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-comment">//构造方法，很简单，直接创建就行了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>  <br>  ...<br>      <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;   <span class="hljs-comment">//内部使用的结点类</span><br>        E item;<br>        Node&lt;E&gt; next;   <span class="hljs-comment">//不仅保存指向下一个结点的引用，还保存指向上一个结点的引用</span><br>        Node&lt;E&gt; prev;<br><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.item = element;<br>            <span class="hljs-built_in">this</span>.next = next;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        linkLast(e);   <span class="hljs-comment">//调用内部方法进行尾部连接</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  <br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;   <span class="hljs-comment">//拿到当前尾结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);  <span class="hljs-comment">//创建新结点</span><br>        last = newNode;   <span class="hljs-comment">//更新尾结点</span><br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)  <br>            first = newNode;  <span class="hljs-comment">//如果当前尾结点为空说明是个空集合，将此结点同时作为首结点</span><br>        <span class="hljs-keyword">else</span><br>            l.next = newNode;  <span class="hljs-comment">//否则更新当前尾结点的next引用，把新的结点串起来</span><br>        size++;   <span class="hljs-comment">//让size自增</span><br>        modCount++;<br>    &#125;<br>  <br>    E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;  <span class="hljs-comment">//拿到当前的待删除结点元素</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;   <span class="hljs-comment">//拿到前后结点</span><br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            first = next;   <span class="hljs-comment">//如果前驱结点为空，说明这个结点就是就是第一个，直接让first等于next就行了</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = next;  <span class="hljs-comment">//否则让前驱结点直接去连接下一个</span><br>            x.prev = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//取消当前结点对于前驱结点的引用，便于JVM自动垃圾回收</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//同上，处于后驱结点，操作差不多</span><br>            last = prev;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.prev = prev;<br>            x.next = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        x.item = <span class="hljs-literal">null</span>;   <span class="hljs-comment">//前后处理干净，然后把待删除结点对于元素的引用取消，彻底废弃掉此结点</span><br>        size--;   <span class="hljs-comment">//让size自减</span><br>        modCount++;<br>        <span class="hljs-keyword">return</span> element;  <span class="hljs-comment">//返回被删元素</span><br>    &#125;<br>  <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedList的使用和ArrayList的使用几乎相同，各项操作的结果也是一样的，在什么使用使用ArrayList和LinkedList，我们需要结合具体的场景来决定，尽可能的扬长避短。</p><ul><li><strong>ArrayList：</strong> 更适合随机访问，因为可以直接读取某个下标的元素。插入则性能较差，因为需要移动一组元素，让出空间。</li><li><strong>LinkedList：</strong> 不适合随机访问，因为无法直接获取某个元素，只能遍历查找。插入性能较好，因为可以直接改变链表中结点的指向。</li></ul><p>如果更多的是对数据进行插入，选择LinkedList，如果更多是对于数据的查询，选择ArrayList。</p><p>只不过LinkedList不仅可以当做List来使用，也可以当做双端队列使用，我们会在后面进行详细介绍。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>我们接着来介绍迭代器，实际上我们的集合类都是支持使用<code>foreach</code>语法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;   <span class="hljs-comment">//集合类同样支持这种语法</span><br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于仅仅是语法糖，实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> list.iterator();   <span class="hljs-comment">//这里使用的是List的迭代器在进行遍历操作</span><br><br>    <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String)var2.next();<br>        System.out.println(s);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>那么这个迭代器是一个什么东西呢？我们来研究一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>  <span class="hljs-comment">//通过调用iterator方法快速获取当前集合的迭代器</span><br>  <span class="hljs-comment">//Iterator迭代器本身也是一个接口，由具体的集合实现类来根据情况实现</span><br>    Iterator&lt;String&gt; iterator = list.iterator();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用迭代器，我们就可以实现对集合中的元素的进行遍历，就像我们遍历数组那样，它的运作机制大概是：</p><p><img src="https://s2.loli.net/2022/10/02/8KS5jbTv7LoAVOs.png" alt="image-20221002150914323"></p><p>一个新的迭代器就像上面这样，默认有一个指向集合中第一个元素的指针：</p><p><img src="https://s2.loli.net/2022/10/02/HxjfipVB9TlEbz5.png" alt="image-20221002151110991"></p><p>每一次<code>next</code>操作，都会将指针后移一位，直到完成每一个元素的遍历，此时再调用<code>next</code>将不能再得到下一个元素。至于为什么要这样设计，是因为集合类的实现方案有很多，可能是链式存储，也有可能是数组存储，不同的实现有着不同的遍历方式，而迭代器则可以将多种多样不同的集合类遍历方式进行统一，只需要各个集合类根据自己的情况进行对应实现就行了。</p><p>我们来看看这个接口的源码定义了哪些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//看看是否还有下一个元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//遍历当前元素，并将下一个元素作为待遍历元素</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//移除上一个被遍历的元素（某些集合不支持这种操作）</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//对剩下的元素进行自定义遍历操作</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">while</span> (hasNext())<br>            action.accept(next());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在ArrayList和LinkedList中，迭代器的实现也不同，比如ArrayList就是直接按下标访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    cursor = i + <span class="hljs-number">1</span>;   <span class="hljs-comment">//移动指针</span><br>    <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];  <span class="hljs-comment">//直接返回指针所指元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>LinkedList就是不断向后寻找结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    next = next.next;   <span class="hljs-comment">//向后继续寻找结点</span><br>    nextIndex++;<br>    <span class="hljs-keyword">return</span> lastReturned.item;  <span class="hljs-comment">//返回结点内部存放的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这两种列表的实现不同，遍历方式也不同，但是都是按照迭代器的标准进行了实现，所以说，我们想要遍历一个集合中所有的元素，那么就可以直接使用迭代器来完成，而不需要关心集合类是如何实现，我们该怎么去遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;    <span class="hljs-comment">//每次循环一定要判断是否还有元素剩余</span><br>        System.out.println(iterator.next());  <span class="hljs-comment">//如果有就可以继续获取到下一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，迭代器的使用是一次性的，用了之后就不能用了，如果需要再次进行遍历操作，那么需要重新生成一个迭代器对象。为了简便，我们可以直接使用<code>foreach</code>语法来快速遍历集合类，效果是完全一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String s : list) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java8提供了一个支持Lambda表达式的forEach方法，这个方法接受一个Consumer，也就是对遍历的每一个元素进行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    list.forEach(System.out::println);<br>    <span class="hljs-comment">//这里有一个常见误区，lambda里面禁止修改外部的非final变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个效果跟上面的写法是完全一样的，因为forEach方法内部本质上也是迭代器在处理，这个方法是在Iterable接口中定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>    Objects.requireNonNull(action);<br>    <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;   <span class="hljs-comment">//foreach语法遍历每一个元素</span><br>        action.accept(t);   <span class="hljs-comment">//调用Consumer的accept来对每一个元素进行消费</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们来看一下，Iterable这个接口又是是什么东西？</p><p><img src="https://s2.loli.net/2022/10/02/4ShtiO6kdIcwZ85.png" alt="image-20221002152713622"></p><p>我们来看看定义了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这个接口是集合接口的父接口，不要跟之前的迭代器接口搞混了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterable</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//生成当前集合的迭代器，在Collection接口中重复定义了一次</span><br>    Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//Java8新增方法，因为是在顶层接口中定义的，因此所有的集合类都有这个方法</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>        <span class="hljs-keyword">for</span> (T t : <span class="hljs-built_in">this</span>) &#123;<br>            action.accept(t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//这个方法会在多线程部分中进行介绍，暂时不做讲解</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;T&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得益于Iterable提供的迭代器生成方法，实际上只要是实现了迭代器接口的类（我们自己写的都行），都可以使用<code>foreach</code>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;String&gt;&#123;   <span class="hljs-comment">//这里我们随便写一个类，让其实现Iterable接口</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;String&gt;() &#123;   <span class="hljs-comment">//生成一个匿名的Iterator对象</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//这里随便写的，直接返回true，这将会导致无限循环</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//每次就直接返回一个字符串吧</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;测试&quot;</span>;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，直接就支持这种语法了，虽然我们这个是自己写的，并不是集合类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    <span class="hljs-keyword">for</span> (String s : test) &#123;<br>        System.out.println(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/KejcFB8TChE5z4o.png" alt="image-20221002154018319"></p><p>是不是感觉集合类的设计非常巧妙？</p><p>我们这里再来介绍一下ListIterator，这个迭代器是针对于List的强化版本，增加了更多方便的操作，因为List是有序集合，所以它支持两种方向的遍历操作，不仅能从前向后，也可以从后向前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看前面是否有已经遍历的元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//跟next相反，这里是倒着往回遍历</span><br>    E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回下一个待遍历元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回上一个已遍历元素的下标</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">previousIndex</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//原本就有的</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//将上一个已遍历元素修改为新的元素</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在遍历过程中，插入新的元素到当前待遍历元素之前</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>    ListIterator&lt;String&gt; iterator = list.listIterator();<br>    iterator.next();   <span class="hljs-comment">//此时得到A</span><br>    iterator.set(<span class="hljs-string">&quot;X&quot;</span>);  <span class="hljs-comment">//将A原本位置的上的元素设定为成新的</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/C3xNDTEWGaPLfO6.png" alt="image-20221002154844743"></p><p>这种迭代器因为能够双向遍历，所以说可以反复使用。</p><h3 id="Queue和Deque"><a href="#Queue和Deque" class="headerlink" title="Queue和Deque"></a>Queue和Deque</h3><p>通过前面的学习，我们已经了解了List的使用，其中LinkedList除了可以直接当做列表使用之外，还可以当做其他的数据结构使用，可以看到它不仅仅实现了List接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br></code></pre></td></tr></table></figure><p>这个Deque接口是干嘛的呢？我们先来看看它的继承结构：</p><p><img src="https://s2.loli.net/2022/10/02/sCMgv9rl5b743BE.png" alt="image-20221002162108279"></p><p>我们先来看看队列接口，它扩展了大量队列相关操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//队列的添加操作，是在队尾进行插入（只不过List也是一样的，默认都是尾插）</span><br>  <span class="hljs-comment">//如果插入失败，会直接抛出异常</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//同样是添加操作，但是插入失败不会抛出异常</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//移除队首元素，但是如果队列已经为空，那么会抛出异常</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">//同样是移除队首元素，但是如果队列为空，会返回null</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//仅获取队首元素，不进行出队操作，但是如果队列已经为空，那么会抛出异常</span><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//同样是仅获取队首元素，但是如果队列为空，会返回null</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以直接将一个LinkedList当做一个队列来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();   <span class="hljs-comment">//当做队列使用，还是很方便的</span><br>    queue.offer(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    queue.offer(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/veHxlUkKyVYErgm.png" alt="image-20221002163512442"></p><p>我们接着来看双端队列，实际上双端队列就是队列的升级版，我们一个普通的队列就是：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>普通队列中从队尾入队，队首出队，而双端队列允许在队列的两端进行入队和出队操作：</p><p><img src="https://s2.loli.net/2022/10/02/gn8i3teclAKbhQS.png" alt="image-20221002164302507"></p><p><img src="https://s2.loli.net/2022/10/02/in8IX3QkwtsLgWN.png" alt="image-20221002164431746"></p><p>利用这种特性，双端队列既可以当做普通队列使用，也可以当做栈来使用，我们来看看Java中是如何定义的Deque双端队列接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//在双端队列中，所有的操作都有分别对应队首和队尾的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deque</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//在队首进行插入操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在队尾进行插入操作</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span>;<br><br>  <span class="hljs-comment">//不用多说了吧？</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//在队首进行移除操作</span><br>    E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//在队尾进行移除操作</span><br>    E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//不用多说了吧？</span><br>    E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//获取队首元素</span><br>    E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//获取队尾元素</span><br>    E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//不用多说了吧？</span><br>    E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span>;<br>    E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//从队列中删除第一个出现的指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">//从队列中删除最后一个出现的指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-comment">// *** 队列中继承下来的方法操作是一样的，这里就不列出了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">// *** 栈相关操作已经帮助我们定义好了 ***</span><br><br>    <span class="hljs-comment">//将元素推向栈顶</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//将元素从栈顶出栈</span><br>    E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">// *** 集合类中继承的方法这里也不多种介绍了 ***</span><br><br>    ...<br><br>    <span class="hljs-comment">//生成反向迭代器，这个迭代器也是单向的，但是是next方法是从后往前进行遍历的</span><br>    Iterator&lt;E&gt; <span class="hljs-title function_">descendingIterator</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以来测试一下，比如我们可以直接当做栈来进行使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    deque.push(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    deque.push(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(deque.pop());<br>    System.out.println(deque.pop());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/02/92woGL5MiBsTcKe.png" alt="image-20221002165618791"></p><p>可以看到，得到的顺序和插入顺序是完全相反的，其实只要各位理解了前面讲解的数据结构，就很简单了。我们来测试一下反向迭代器和正向迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    deque.addLast(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    deque.addLast(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    <br>    Iterator&lt;String&gt; descendingIterator = deque.descendingIterator();<br>    System.out.println(descendingIterator.next());<br><br>    Iterator&lt;String&gt; iterator = deque.iterator();<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，正向迭代器和反向迭代器的方向是完全相反的。</p><p>当然，除了LinkedList实现了队列接口之外，还有其他的实现类，但是并不是很常用，这里做了解就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Deque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();   <span class="hljs-comment">//数组实现的栈和队列</span><br>    Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();  <span class="hljs-comment">//优先级队列</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要介绍一下优先级队列，优先级队列可以根据每一个元素的优先级，对出队顺序进行调整，默认情况按照自然顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/bmEP9fgCS1Ksaqw.png" alt="image-20221003210253093"></p><p>可以看到，我们的插入顺序虽然是10&#x2F;4&#x2F;5，但是出队顺序是按照优先级来的，类似于VIP用户可以优先结束排队。我们也可以自定义比较规则，同样需要给一个Comparator的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);   <span class="hljs-comment">//按照从大到小顺序出队</span><br>    queue.offer(<span class="hljs-number">10</span>);<br>    queue.offer(<span class="hljs-number">4</span>);<br>    queue.offer(<span class="hljs-number">5</span>);<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>    System.out.println(queue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/G5SZgKxvUJyPABD.png" alt="image-20221003210436684"></p><p>只不过需要注意的是，优先级队列并不是队列中所有的元素都是按照优先级排放的，优先级队列<strong>只能保证出队顺序是按照优先级</strong>进行的，我们可以打印一下：</p><p><img src="https://s2.loli.net/2022/10/03/9dSheG4xqFoXB5i.png" alt="image-20221003210545678"></p><p>想要了解优先级队列的具体实现原理，可以在《数据结构与算法》篇视频教程中学习大顶堆和小顶堆。</p><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><p>前面我们已经介绍了列表，我们接着来看Set集合，这种集合类型比较特殊，我们先来看看Set的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Set</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// Set集合中基本都是从Collection直接继承过来的方法，只不过对这些方法有更加特殊的定义</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>;<br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>    Object[] toArray();<br>    &lt;T&gt; T[] toArray(T[] a);<br><br>    <span class="hljs-comment">//添加元素只有在当前Set集合中不存在此元素时才会成功，如果插入重复元素，那么会失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br><br>    <span class="hljs-comment">//这个同样是删除指定元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br><br>    <span class="hljs-comment">//同样是只能插入那些不重复的元素</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span>;<br>  <br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">retainAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//这个方法我们同样会放到多线程中进行介绍</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">default</span> Spliterator&lt;E&gt; <span class="hljs-title function_">spliterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Spliterators.spliterator(<span class="hljs-built_in">this</span>, Spliterator.DISTINCT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现接口中定义的方法都是Collection中直接继承的，因此，Set支持的功能其实也就和Collection中定义的差不多，只不过：</p><ul><li>不允许出现重复元素</li><li>不支持随机访问（不允许通过下标访问）</li></ul><p>首先认识一下HashSet，它的底层就是采用哈希表实现的（我们在这里先不去探讨实现原理，因为底层实质上是借用的一个HashMap在实现，这个需要我们学习了Map之后再来讨论）我们可以非常高效的从HashSet中存取元素，我们先来测试一下它的特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));   <span class="hljs-comment">//这里我们连续插入两个同样的字符串</span><br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set);   <span class="hljs-comment">//可以看到，最后实际上只有一个成功插入了</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/y5AoUG1iuWzhOSj.png" alt="image-20221003211330129"></p><p>在Set接口中并没有定义支持指定下标位置访问的添加和删除操作，我们只能简单的删除Set中的某个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    System.out.println(set.add(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set.remove(<span class="hljs-string">&quot;AAA&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于底层采用哈希表实现，所以说无法维持插入元素的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/OekDqMlpVbxImsK.png" alt="image-20221003211635759"></p><p>那要是我们就是想要使用维持顺序的Set集合呢？我们可以使用LinkedHashSet，LinkedHashSet底层维护的不再是一个HashMap，而是LinkedHashMap，它能够在插入数据时利用链表自动维护顺序，因此这样就能够保证我们插入顺序和最后的迭代顺序一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>    set.addAll(Arrays.asList(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>));<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/TpczL2Zi1OkaHWI.png" alt="image-20221003212147700"></p><p>还有一种Set叫做TreeSet，它会在元素插入时进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/3VwDQzRxUTGrOZb.png" alt="image-20221003212233263"></p><p>可以看到最后得到的结果并不是我们插入顺序，而是按照数字的大小进行排列。当然，我们也可以自定义排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; b - a);  <span class="hljs-comment">//同样是一个Comparator</span><br>    set.add(<span class="hljs-number">1</span>);<br>    set.add(<span class="hljs-number">3</span>);<br>    set.add(<span class="hljs-number">2</span>);<br>    System.out.println(set);<br>&#125;<br></code></pre></td></tr></table></figure><p>目前，Set集合只是粗略的进行了讲解，但是学习Map之后，我们还会回来看我们Set的底层实现，所以说最重要的还是Map。本节只需要记住Set的性质、使用即可。</p><h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>什么是映射？我们在高中阶段其实已经学习过映射（Mapping）了，映射指两个元素的之间相互“对应”的关系，也就是说，我们的元素之间是两两对应的，是以键值对的形式存在。</p><p><img src="https://s2.loli.net/2022/10/03/QSxqJLwiNM1nZlO.jpg" alt="39e19f3e-04e8-4c43-8fb5-6d5288a7cdf8"></p><p>而Map就是为了实现这种数据结构而存在的，我们通过保存键值对的形式来存储映射关系，就可以轻松地通过键找到对应的映射值，比如现在我们要保存很多学生的信息，而这些学生都有自己的ID，我们可以将其以映射的形式保存，将ID作为键，学生详细信息作为值，这样我们就可以通过学生的ID快速找到对应学生的信息了。</p><p><img src="https://s2.loli.net/2022/10/03/i2x6m3hzFC5GIAd.png" alt="image-20221003213157956"></p><p>在Map中，这些映射关系被存储为键值对，我们先来看看Map接口中定义了哪些操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Map并不是Collection体系下的接口，而是单独的一个体系，因为操作特殊</span><br><span class="hljs-comment">//这里需要填写两个泛型参数，其中K就是键的类型，V就是值的类型，比如上面的学生信息，ID一般是int，那么键就是Integer类型的，而值就是学生信息，所以说值是学生对象类型的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt; &#123;<br>    <span class="hljs-comment">//-------- 查询相关操作 --------</span><br>  <br>  <span class="hljs-comment">//获取当前存储的键值对数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//是否为空</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的键</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsKey</span><span class="hljs-params">(Object key)</span>;<br><br>    <span class="hljs-comment">//查看Map中是否包含指定的值</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsValue</span><span class="hljs-params">(Object value)</span>;<br><br>    <span class="hljs-comment">//通过给定的键，返回其映射的值</span><br>    V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span>;<br><br>    <span class="hljs-comment">//-------- 修改相关操作 --------</span><br><br>    <span class="hljs-comment">//向Map中添加新的映射关系，也就是新的键值对</span><br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br><br>    <span class="hljs-comment">//根据给定的键，移除其映射关系，也就是移除对应的键值对</span><br>    V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span>;<br><br><br>    <span class="hljs-comment">//-------- 批量操作 --------</span><br><br>    <span class="hljs-comment">//将另一个Map中的所有键值对添加到当前Map中</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span>;<br><br>    <span class="hljs-comment">//清空整个Map</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>;<br><br><br>    <span class="hljs-comment">//-------- 其他视图操作 --------</span><br><br>    <span class="hljs-comment">//返回Map中存放的所有键，以Set形式返回</span><br>    Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回Map中存放的所有值</span><br>    Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//返回所有的键值对，这里用的是内部类Entry在表示</span><br>    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br><br>    <span class="hljs-comment">//这个是内部接口Entry，表示一个键值对</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; &#123;<br>        <span class="hljs-comment">//获取键值对的键</span><br>        K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">//获取键值对的值</span><br>        V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-comment">//修改键值对的值</span><br>        V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V value)</span>;<br><br>        <span class="hljs-comment">//判断两个键值对是否相等</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span>;<br><br>        <span class="hljs-comment">//返回当前键值对的哈希值</span><br>        <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Map中定义了非常多的方法，尤其是在Java 8之后新增的大量方法，我们会在后面逐步介绍的。</p><p>我们可以来尝试使用一下Map，实际上非常简单，这里我们使用最常见的HashMap，它的底层采用哈希表实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//使用put方法添加键值对，返回值我们会在后面讨论</span><br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;小红&quot;</span>);<br>    System.out.println(map.get(<span class="hljs-number">2</span>)); <span class="hljs-comment">//使用get方法根据键获取对应的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>注意，Map中无法添加相同的键，同样的键只能存在一个，即使值不同。如果出现键相同的情况，那么会覆盖掉之前的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小红&quot;</span>);   <span class="hljs-comment">//这里的键跟之前的是一样的，这样会导致将之前的键值对覆盖掉</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/8Fl6YizINQP9dmX.png" alt="image-20221003214807048"></p><p>为了防止意外将之前的键值对覆盖掉，我们可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    map.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小红&quot;</span>);   <span class="hljs-comment">//Java8新增操作，只有在不存在相同键的键值对时才会存放</span><br>    System.out.println(map.get(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>还有，我们在获取一个不存在的映射时，默认会返回null作为结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);   <span class="hljs-comment">//Map中只有键为1的映射</span><br>    System.out.println(map.get(<span class="hljs-number">3</span>));  <span class="hljs-comment">//此时获取键为3的值，那肯定是没有的，所以说返回null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以为这种情况添加一个预备方案，当Map中不存在时，可以返回一个备选的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>    System.out.println(map.getOrDefault(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;备胎&quot;</span>));   <span class="hljs-comment">//Java8新增操作，当不存在对应的键值对时，返回备选方案</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，因为HashMap底层采用哈希表实现，所以不维护顺序，我们在获取所有键和所有值时，可能会是乱序的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;牌&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;你能秒我&quot;</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/DNXqwk3UOPnMmlc.png" alt="image-20221003220156062"></p><p>如果需要维护顺序，我们同样可以使用LinkedHashMap，它的内部对插入顺序进行了维护：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;牌&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;P&quot;</span>, <span class="hljs-string">&quot;你能秒我&quot;</span>);<br>    System.out.println(map);<br>    System.out.println(map.keySet());<br>    System.out.println(map.values());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/QHkWZsFvzASpxqL.png" alt="image-20221003220458539"></p><p>实际上Map的使用还是挺简单的，我们接着来看看Map的底层是如何实现的，首先是最简单的HashMap，我们前面已经说过了，它的底层采用的是哈希表，首先回顾我们之前学习的哈希表，我们当时说了，哈希表可能会出现哈希冲突，这样保存的元素数量就会存在限制，而我们可以通过链地址法解决这种问题，最后哈希表就长这样了：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>实际上这个表就是一个存放头结点的数组+若干结点，而HashMap也是差不多的实现，我们来看看这里面是怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>  <br>  ...<br>    <br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;   <span class="hljs-comment">//内部使用结点，实际上就是存放的映射关系</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;   <span class="hljs-comment">//跟我们之前不一样，我们之前一个结点只有键，而这里的结点既存放键也存放值，当然计算哈希还是使用键</span><br>        V value;<br>        Node&lt;K,V&gt; next;<br>...<br>    &#125;<br>  <br>  ...<br>  <br>  <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;   <span class="hljs-comment">//这个就是哈希表本体了，可以看到跟我们之前的写法是一样的，也是结点数组，只不过HashMap中没有设计头结点（相当于没有头结点的链表）</span><br>  <br>  <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;   <span class="hljs-comment">//负载因子，这个东西决定了HashMap的扩容效果</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">//当我们创建对象时，会使用默认的负载因子，值为0.75</span><br>    &#125;<br>  <br>  ...     <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，实际上底层大致结构跟我们之前学习的差不多，只不过多了一些特殊的东西：</p><ul><li>HashMap支持自动扩容，哈希表的大小并不是一直不变的，否则太过死板</li><li>HashMap并不是只使用简单的链地址法，当链表长度到达一定限制时，会转变为效率更高的红黑树结构</li></ul><p>我们来研究一下它的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>  <span class="hljs-comment">//这里计算完键的哈希值之后，调用的另一个方法进行映射关系存放</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">               <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)  <span class="hljs-comment">//如果底层哈希表没初始化，先初始化</span><br>        n = (tab = resize()).length;   <span class="hljs-comment">//通过resize方法初始化底层哈希表，初始容量为16，后续会根据情况扩容，底层哈希表的长度永远是2的n次方</span><br>  <span class="hljs-comment">//因为传入的哈希值可能会很大，这里同样是进行取余操作</span><br>  <span class="hljs-comment">//这里做了个优化 (n - 1) &amp; hash 等价于 hash % n （仅限n为2的幂可以这样做）这里的i就是最终得到的下标位置了</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>        tab[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(hash, key, value, <span class="hljs-literal">null</span>);   <span class="hljs-comment">//如果这个位置上什么都没有，那就直接放一个新的结点</span><br>    <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//这种情况就是哈希冲突了</span><br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;   <span class="hljs-comment">//如果上来第一个结点的键的哈希值跟当前插入的键的哈希值相同，键也相同，说明已经存放了相同键的键值对了，那就执行覆盖操作</span><br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))  <span class="hljs-comment">//依然是equals判断</span><br>            e = p;   <span class="hljs-comment">//这里直接将待插入结点等于原本冲突的结点，一会直接覆盖</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)   <span class="hljs-comment">//如果第一个结点是TreeNode类型的，说明这个链表已经升级为红黑树了</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);  <span class="hljs-comment">//在红黑树中插入新的结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;  <span class="hljs-comment">//普通链表就直接在链表尾部插入</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">//e每次都更新为p.next</span><br>                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);  <span class="hljs-comment">//找到尾部，直接创建新的结点连在后面</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">//如果当前链表的长度已经很长了，达到了阈值</span><br>                        treeifyBin(tab, hash);<span class="hljs-comment">//那么就转换为红黑树来存放</span><br>                    <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//直接结束</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))  <span class="hljs-comment">//同样的，如果在向下找的过程中发现已经存在相同键的键值对了，直接结束</span><br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果e不为空，只有可能是前面出现了相同键的情况，其他情况e都是null，所以直接覆盖就行</span><br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                e.value = value;  <span class="hljs-comment">//覆盖原本存储的值</span><br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;   <span class="hljs-comment">//覆盖之后，会返回原本的被覆盖值</span><br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)   <span class="hljs-comment">//键值对size计数自增，如果超过阈值，会对底层哈希表数组进行扩容</span><br>        resize();   <span class="hljs-comment">//调用resize进行扩容</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">//正常插入键值对返回值为null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉只要前面的数据结构听懂了，这里简直太简单。根据上面的推导，我们在正常插入一个键值对时，会得到null返回值，而冲突时会得到一个被覆盖的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;String , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    System.out.println(map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;十七张&quot;</span>));<br>    System.out.println(map.put(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;慈善家&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/A2rXocbU9StlDOC.png" alt="image-20221003224137177"></p><p>现在我们知道，当HashMap的一个链表长度过大时，会自动转换为红黑树：</p><p><img src="https://s2.loli.net/2022/10/03/E7GnIVjPAwf8Fol.jpg" alt="710c1c38-95a8-493d-8645-067b991af908"></p><p>但是这样始终治标不治本，受限制的始终是底层哈希表的长度，我们还需要进一步对底层的这个哈希表进行扩容才可以从根本上解决问题，我们来看看<code>resize()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;   <span class="hljs-comment">//先把下面这几个旧的东西保存一下</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;  <span class="hljs-comment">//这些是新的容量和扩容阈值</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//如果旧容量大于0，那么就开始扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  <span class="hljs-comment">//如果旧的容量已经大于最大限制了，那么直接给到 Integer.MAX_VALUE</span><br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;  <span class="hljs-comment">//这种情况不用扩了</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)   <span class="hljs-comment">//新的容量等于旧容量的2倍，同样不能超过最大值</span><br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">//新的阈值也提升到原来的两倍</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 旧容量不大于0只可能是还没初始化，这个时候如果阈值大于0，直接将新的容量变成旧的阈值</span><br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// 默认情况下阈值也是0，也就是我们刚刚无参new出来的时候</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;   <span class="hljs-comment">//新的容量直接等于默认容量16</span><br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="hljs-comment">//阈值为负载因子乘以默认容量，负载因子默认为0.75，也就是说只要整个哈希表用了75%的容量，那么就进行扩容，至于为什么默认是0.75，原因很多，这里就不解释了，反正作为新手，这些都是大佬写出来的，我们用就完事。</span><br>    &#125;<br>    ...<br>    threshold = newThr;<br>    <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;   <span class="hljs-comment">//将底层数组变成新的扩容之后的数组</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//如果旧的数组不为空，那么还需要将旧的数组中所有元素全部搬到新的里面去</span><br>      ...   <span class="hljs-comment">//详细过程就不介绍了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉自己有点了解HashMap的运作机制了，其实并不是想象中的那么难，因为这些东西再怎么都是人写的。</p><blockquote><p> HashMap初始容量为0，第一次put的时候，会立即进行一次resize，第一次resize会直接生成一个数组作为哈希表，容量为16，阈值为16 * 0.75，当后续插入键值对超过阈值时，会进行第二次resize，第二次resize会将容量和阈值都变为原来的2倍，第三次以此类推。</p></blockquote><p>而LinkedHashMap是直接继承自HashMap，具有HashMap的全部性质，同时得益于每一个节点都是一个双向链表，在插入键值对时，同时保存了插入顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;   <span class="hljs-comment">//LinkedHashMap中的结点实现</span><br>    Entry&lt;K,V&gt; before, after;   <span class="hljs-comment">//这里多了一个指向前一个结点和后一个结点的引用</span><br>    Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-built_in">super</span>(hash, key, value, next);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们在遍历LinkedHashMap时，顺序就同我们的插入顺序一致。</p><p>当然还有一种比较特殊的Map叫做TreeMap，就像它的名字一样，就是一个Tree，它的内部直接维护了一个红黑树（没有使用哈希表）因为它会将我们插入的结点按照规则进行排序，所以说直接采用红黑树会更好，我们在创建时，只需给予一个比较规则即可，跟之前的TreeSet是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; b - a);<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;一个六&quot;</span>);<br>    map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;**&quot;</span>);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/03/2oJXBui5aD8q1Gh.png" alt="image-20221003231135805"></p><p>现在我们倒回来看之前讲解的HashSet集合，实际上它的底层很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;   <span class="hljs-comment">//对，你没看错，底层直接用map来做事</span><br><br>    <span class="hljs-comment">// 因为Set只需要存储Key就行了，所以说这个对象当做每一个键值对的共享Value</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">//直接构造一个默认大小为16负载因子0.75的HashMap</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>        map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br><br>  ...<br>      <br>    <span class="hljs-comment">//你会发现所有的方法全是替身攻击</span><br>    <span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.keySet().iterator();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.size();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> map.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察HashSet的源码发现，HashSet几乎都在操作内部维护的一个HashMap，也就是说，HashSet只是一个表壳，而内部维护的HashMap才是灵魂！就像你进了公司，在外面花钱请别人帮你写公司的业务，你只需要坐着等别人写好然后你自己拿去交差就行了。所以说，HashSet利用了HashMap内部的数据结构，轻松地就实现了Set定义的全部功能！</p><p>再来看TreeSet，实际上用的就是我们的TreeMap：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable<br>&#123;<br>    <span class="hljs-comment">//底层需要一个NavigableMap，就是自动排序的Map</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,Object&gt; m;<br><br>    <span class="hljs-comment">//不用我说了吧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    ...<br><br>    <span class="hljs-comment">//直接使用TreeMap解决问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());<br>    &#125;<br><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，这里就不多做阐述了。</p><p>我们接着来看看Map中定义的哪些杂七杂八的方法，首先来看看<code>compute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.compute(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//compute会将指定Key的值进行重新计算，若Key不存在，v会返回null</span><br>        <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>  map.computeIfPresent(<span class="hljs-number">1</span>, (k, v) -&gt; &#123;   <span class="hljs-comment">//当Key存在时存在则计算并赋予新的值</span><br>      <span class="hljs-keyword">return</span> v+<span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回原来的value+M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用<code>computeIfAbsent</code>，当不存在Key时，计算并将键值对放入Map中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>    map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>    map.computeIfAbsent(<span class="hljs-number">0</span>, (k) -&gt; &#123;   <span class="hljs-comment">//若不存在则计算并插入新的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;M&quot;</span>;     <span class="hljs-comment">//这里返回M</span><br>    &#125;);<br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>merge方法用于处理数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Student&gt; students = Arrays.asList(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">80</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">98</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;yoni&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">95</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">50</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">72</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;taohai.wang&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">41</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;English&quot;</span>, <span class="hljs-number">88</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Chiness&quot;</span>, <span class="hljs-number">89</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;Seely&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>, <span class="hljs-number">92</span>)<br>    );<br>    Map&lt;String, Integer&gt; scoreMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-comment">//merge方法可以对重复键的值进行特殊操作，比如我们想计算某个学生的所有科目分数之后，那么就可以像这样：</span><br>    students.forEach(student -&gt; scoreMap.merge(student.getName(), student.getScore(), Integer::sum));<br>    scoreMap.forEach((k, v) -&gt; System.out.println(<span class="hljs-string">&quot;key:&quot;</span> + k + <span class="hljs-string">&quot;总分&quot;</span> + <span class="hljs-string">&quot;value:&quot;</span> + v));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> score;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, String type, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.type = type;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>replace</code>方法可以快速替换某个映射的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;&gt;&gt;&gt;&quot;</span>);   <span class="hljs-comment">//直接替换为新的</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以精准匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.replace(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;巴卡&quot;</span>, <span class="hljs-string">&quot;玛卡&quot;</span>);   <span class="hljs-comment">//只有键和值都匹配时，才进行替换</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>包括remove方法，也支持键值同时匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Map&lt;Integer , String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);<br>    map.remove(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;单走&quot;</span>);  <span class="hljs-comment">//只有同时匹配时才移除</span><br>    System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉学习了Map之后，涨了不少姿势？</p><h3 id="比较相关接口"><a href="#比较相关接口" class="headerlink" title="比较相关接口"></a>比较相关接口</h3><p>在前面的学习中，我们发现很多的类中都存在一个<code>compareTo</code>方法，这实际上是因为这个类实现了<code>Comparable</code>接口获得的方法，我们常见的一些JDK提供的类型，如String、基本类型包装类、Date、LocalDate等，其实都实现了此接口，从而自带对于其类型对象之间的比较操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AAA&quot;</span>, s2 = <span class="hljs-string">&quot;BBB&quot;</span>;<br>System.out.println(s1.compareTo(s2));  <span class="hljs-comment">//按字典顺序比较两个字符串,比较基于字符串中每个字符的 Unicode 值。</span><br></code></pre></td></tr></table></figure><p>这与我们前面提到过的<code>Comparator</code>类似，当返回值大于0说明前者大于后者，小于0则是后者大于前者，如果等于0则表示这两者相等。但是注意<code>Comparator</code>是用于直接手动创建比较规则，而<code>Comparable</code>则是直接让类自行定义内部比较规则，包括这两者的使用的地方也不一样。</p><p>比如我们前面介绍的<code>Arrays</code>工具类，其中就包含<code>sort</code>方法进行排序，我们可以直接传入一个数组让其自动完成排序操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123; <span class="hljs-string">&quot;DDD&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span> &#125;;<br>Arrays.sort(arr);<br>System.out.println(Arrays.toString(arr));<br></code></pre></td></tr></table></figure><p>但是注意，我们进行排序的类型必须是一个实现了<code>Comparable</code>接口的类型，否则无法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Student[] arr = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#125;;<br>    Arrays.sort(arr);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/22/vC7VGpdl268LWAk.png" alt="image-20250722143249240"></p><p>我们可以为我们自己定义的类实现<code>Comparable</code>接口，实现一个自己的比较操作即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Student[] arr = &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">19</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">18</span>) &#125;;<br>    Arrays.sort(arr);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Student&gt; &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Student o)</span> &#123;<br>        <span class="hljs-keyword">return</span> age - o.age;   <span class="hljs-comment">//直接比较年龄</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>               <span class="hljs-string">&quot;age=&quot;</span> + age +<br>               <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们之前介绍的<code>TreeSet</code>和<code>TreeMap</code>，在我们不指定任何排序规则的情况下，默认也是采用类中Comparable的实现进行排序的，如果我们直接使用一个为实现<code>Comparable</code>接口的类型，同样会出现报错：</p><p><img src="https://s2.loli.net/2025/07/22/o4xXJcsAh7DUinL.png" alt="image-20250722145029512"></p><p>不过，除了让类本身实现<code>Comparable</code>接口之外，对于一些第三方提供的类型我们无法进行修改的，此时也可以手动指定比较规则，也就是通过传入一个<code>Comparator</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeSet&lt;Student&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;((s1, s2) -&gt; s1.age - s2.age);  <span class="hljs-comment">//手动指定一个比较规则也可以</span><br>    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">19</span>));<br>    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">18</span>));<br>    System.out.println(set);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，数组也有类似的<code>sort</code>方法，这里就不列出了。接下来我们就着重介绍一下<code>Comparator</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparator</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//我们需要实现的比较方法</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(T o1, T o2)</span>;<br><br>    <span class="hljs-comment">//从Object继承下来的方法，这里进行了重新定义，</span><br>    <span class="hljs-comment">//除了比较两个元素相等之外，它还额外要求两个元素compare得到的结果为0</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span>;<br><br>    <span class="hljs-comment">//根据当前实现的compare操作，生成一个相反的比较Comparator</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//在原有比较基础上，附加次级比较条件（也就是说如果比较出来两个对象相等，就继续按照次级条件比较得到谁前谁后）</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> compare(c1, c2);<br>            <span class="hljs-keyword">return</span> (res != <span class="hljs-number">0</span>) ? res : other.compare(c1, c2);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//上面的进阶版，可以自定义类中属性(作为key)的获取规则，并对此属性进行比较</span><br>    <span class="hljs-keyword">default</span> &lt;U&gt; Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor,</span><br><span class="hljs-params">            Comparator&lt;? <span class="hljs-built_in">super</span> U&gt; keyComparator)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparing(keyExtractor, keyComparator));<br>    &#125;<br><br>    <span class="hljs-comment">//上面的简化版，只有类中属性(作为key)的获取规则，比较规则使用key默认的实现（Key必须是Comparable的实现类）</span><br>    <span class="hljs-keyword">default</span> &lt;U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">thenComparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparing(keyExtractor));<br>    &#125;<br><br>    <span class="hljs-comment">//针对于特定内置类型的提取并比较，同上，后续同理</span><br>    <span class="hljs-keyword">default</span> Comparator&lt;T&gt; <span class="hljs-title function_">thenComparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-built_in">super</span> T&gt; keyExtractor)</span> &#123;<br>        <span class="hljs-keyword">return</span> thenComparing(comparingInt(keyExtractor));<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-comment">//------以下是所有的静态方法，可以直接生成一个新的Comparator对象</span><br>      <br>    <span class="hljs-comment">//生成一个指定类型（需要实现Comparable）的反向比较器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">reverseOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Collections.reverseOrder();<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型（需要实现Comparable）的正向比较器</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">naturalOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型的正向比较器，且针对于null值，会优先排到前面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">nullsFirst</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.NullComparator&lt;&gt;(<span class="hljs-literal">true</span>, comparator);<br>    &#125;<br><br>    <span class="hljs-comment">//生成一个指定类型的正向比较器，且针对于null值，会直接排到后面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">nullsLast</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; comparator)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparators</span>.NullComparator&lt;&gt;(<span class="hljs-literal">false</span>, comparator);<br>    &#125;<br><br>    <span class="hljs-comment">//传入一个指定类型用于比较的Key的获取方式，然后再传入Key的比较操作实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor,</span><br><span class="hljs-params">            Comparator&lt;? <span class="hljs-built_in">super</span> U&gt; keyComparator)</span><br>    &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        Objects.requireNonNull(keyComparator);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; keyComparator.compare(keyExtractor.apply(c1),<br>                                              keyExtractor.apply(c2));<br>    &#125;<br><br>    <span class="hljs-comment">//传入一个指定类型用于比较的Key（需要实现Comparable）的获取方式，然后自动进行比较</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> U&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparing</span><span class="hljs-params">(</span><br><span class="hljs-params">            Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; keyExtractor)</span><br>    &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));<br>    &#125;<br><br>    <span class="hljs-comment">//针对于内置类型的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">comparingInt</span><span class="hljs-params">(ToIntFunction&lt;? <span class="hljs-built_in">super</span> T&gt; keyExtractor)</span> &#123;<br>        Objects.requireNonNull(keyExtractor);<br>        <span class="hljs-keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)<br>            (c1, c2) -&gt; Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，有关两个比较相关的接口就介绍完成了。</p><h3 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h3><p>我们在前面介绍了Arrays，它是一个用于操作数组的工具类，它给我们提供了大量的工具方法。</p><p>既然数组操作都这么方便了，集合操作能不能也安排点高级的玩法呢？那必须的，JDK为我们准备的Collocations类就是专用于集合的工具类，比如我们想快速求得List中的最大值和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Collections.max(list);<br>    Collections.min(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们可以对一个集合进行二分搜索（注意，集合的具体类型，必须是实现Comparable接口的类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>);<br>    System.out.println(Collections.binarySearch(list, <span class="hljs-number">8</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以对集合的元素进行快速填充，注意这个填充是对集合中已有的元素进行覆盖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    Collections.fill(list, <span class="hljs-number">6</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果集合中本身没有元素，那么<code>fill</code>操作不会生效。</p><p>有些时候我们可能需要生成一个空的集合类返回，那么我们可以使用<code>emptyXXX</code>来快速生成一个只读的空集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Collections.emptyList();<br>  <span class="hljs-comment">//Collections.singletonList() 会生成一个只有一个元素的List</span><br>    list.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以将一个可修改的集合变成只读的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    List&lt;Integer&gt; newList = Collections.unmodifiableList(list);<br>    newList.add(<span class="hljs-number">10</span>);   <span class="hljs-comment">//不支持，会直接抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以寻找子集合的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    System.out.println(Collections.indexOfSubList(list, Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><p>得益于泛型的类型擦除机制，实际上最后只要是Object的实现类都可以保存到集合类中，那么就会出现这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//使用原始类型接收一个Integer类型的ArrayList</span><br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list.add(<span class="hljs-string">&quot;aaa&quot;</span>);   <span class="hljs-comment">//我们惊奇地发现，这玩意居然能存字符串进去</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/04/FP5z3X8SEMkGYtT.png" alt="image-20221004001007854"></p><p>没错，由于泛型机制上的一些漏洞，实际上对应类型的集合类有可能会存放其他类型的值，泛型的类型检查只存在于编译阶段，只要我们绕过这个阶段，在实际运行时，并不会真的进行类型检查，要解决这种问题很简单，就是在运行时进行类型检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));<br>    list = Collections.checkedList(list, Integer.class);   <span class="hljs-comment">//这里的.class关键字我们会在后面反射中介绍，表示Integer这个类型</span><br>  list.add(<span class="hljs-string">&quot;aaa&quot;</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>checkedXXX</code>可以将给定集合类进行包装，在运行时同样会进行类型检查，如果通过上面的漏洞插入一个本不应该是当前类型集合支持的类型，那么会直接抛出类型转换异常：</p><p><img src="https://s2.loli.net/2022/10/04/5BHq1u9JU3bhdI6.png" alt="image-20221004001409799"></p><p>是不是感觉这个工具类好像还挺好用的？实际上在我们的开发中，这个工具类也经常被使用到。</p><h3 id="Java-9-集合工厂方法"><a href="#Java-9-集合工厂方法" class="headerlink" title="(Java 9) 集合工厂方法"></a>(Java 9) 集合工厂方法</h3><p>有些时候我们可能需要创建一个携带默认数据的集合对象，比如一个水果清单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruit = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>fruit.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>fruit.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>fruit.add(<span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>像这样一个一个添加实在是太累了，我们前面学习了<code>Arrays</code>工具类，它可以快速用于创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruit = Arrays.asList(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>不过这种操作实际上更像是官方为数组设计的工具。在Java9之后，官方为我们提供了更加方便的工厂方法进行快速创建，不仅仅是List、包括Map、Set都被添加了若干个名字为<code>of</code>的静态方法：</p><p><img src="https://s2.loli.net/2025/07/07/YytpnaFwL5XACiM.png" alt="image-20250707205131728"></p><p>通过这种方式就能像这样编写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; fruits = List.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br>Set&lt;String&gt; fruitSet = Set.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>通过这种方式得到的集合对象同样是只读的，不可对其内容进行修改。其中<code>Set</code>和<code>List</code>的使用方法与之前提到的<code>Arrays</code>类似，直接依次填写即可。注意这里的Set集合默认使用的是类似HashSet的实现，元素没有特定顺序。</p><p>对于Map来说，我们需要把key和value交替进行编写，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; fruitMap = Map.of(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;orange&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中前者为Key，后者为Value，使用方式与上面是差不多的。除了直接传入键值对，也可以传入Entry对象进行构建：</p><p><img src="https://s2.loli.net/2025/07/07/ol4TyBChMN6R1ut.png" alt="image-20250707205406929"></p><h3 id="Java-21-有序集合功能规范"><a href="#Java-21-有序集合功能规范" class="headerlink" title="(Java 21) 有序集合功能规范"></a>(Java 21) 有序集合功能规范</h3><p>前面我们提到过，针对于有序集合类，Java 21新增了一系列<code>SequencedCollection</code>、<code>SequencedSet</code>和<code>SequencedMap</code>接口，这些接口扩展和规范了所有有序集合的功能，我们先来看比较简单的，我们以List列表为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(list.get(<span class="hljs-number">0</span>));   <span class="hljs-comment">//Java21之前获取首个元素</span><br>System.out.println(list.getFirst());  <span class="hljs-comment">//现在可以直接使用getFirst拿第一个了</span><br><br>System.out.println(list.get(list.size() - <span class="hljs-number">1</span>));  <span class="hljs-comment">//Java21之前获取最后一个元素，还得先拿到总长度</span><br>System.out.println(list.getLast());   <span class="hljs-comment">//现在直接能拿了，堪称史诗级更新</span><br></code></pre></td></tr></table></figure><p>原本只有LinkedList才有的列表首尾操作功能，现在所有有序列表都可以使用了，算是真正统一了列表的使用方式。包括原本LinkedList作为栈和队列才有的首尾插入操作，现在对于所有有序列表都能使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.addFirst(<span class="hljs-string">&quot;A&quot;</span>);<br>list.addFirst(<span class="hljs-string">&quot;B&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中比较重要的功能是我们可以直接生成对应列表的反转列表了，只需调用<code>reversed</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>System.out.println(list.reversed());<br></code></pre></td></tr></table></figure><p>但是注意它并不是直接对原列表进行修改，而是直接返回了一个新的列表对象，其具体实现为<code>ReverseOrderListView</code>倒序列表视图，为什么叫这样一个名字呢？首先大家需要理解视图的概念，视图相当于是对原来的数据换了一种方式进行展示，他可以像普通的列表一样进行查询，也可以像普通的列表那样去修改，但是其并不存储任何数据，所有对于视图的修改最终会作用到原列表上。</p><p>这样就很好理解了，我们可以通过下面的例子来解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>List&lt;String&gt; rlist = list.reversed();<br>System.out.println(rlist);<br><br>list.addLast(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//向原本列表的尾部插入元素D</span><br>System.out.println(rlist);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/nLO1SorCPdhWefH.png" alt="image-20250709003608414"></p><p>可以看到，在修改原本列表之后，其反转之后的列表视图打印的结果也跟着发生了变化。同样的，我们也可以直接对视图进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>));<br>List&lt;String&gt; rlist = list.reversed();<br>System.out.println(list);<br><br>rlist.addLast(<span class="hljs-string">&quot;D&quot;</span>);   <span class="hljs-comment">//向反转列表的尾部插入元素D，相当于在原列表首部插入元素D</span><br>System.out.println(list);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/A16JM4doHsXKtEv.png" alt="image-20250709003954386"></p><p>可以看到，我们向视图中进行的插入操作，最终作用到原本的列表上了，并且作用的效果也是相反的。因此，如果你只是单纯希望对列表内部元素进行倒序排序，可以考虑使用我们下面会讲解的<code>Collections</code>工具类，其中包含大量处理集合的操作。</p><p>而<code>SequencedSet</code>，它是对于<code>Set</code>的扩展，同样添加了头插尾插的操作，但是只有一部分Set集合类实现了此接口。</p><p>其中<code>SequencedMap</code>相关方法与上述内容类似，这里就不重复讲解了。</p><h3 id="Java-8-Stream流"><a href="#Java-8-Stream流" class="headerlink" title="(Java 8) Stream流"></a>(Java 8) Stream流</h3><p>Java 8 API添加了一个新的操作，我们称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><p><img src="https://s2.loli.net/2022/10/03/r4AtmVRZ51y7uxd.png" alt="image-20221003232832897"></p><p>它看起来就像一个工厂的流水线一样，每一步都会对数据进行处理，乍一看好像没区别啊。我们来看看普通的处理和使用Stream处理有什么不一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//这是普通的处理</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>  <br>  <span class="hljs-comment">//移除为B的元素</span><br>  Iterator&lt;String&gt; iterator = list.iterator();<br>    <span class="hljs-keyword">while</span> (iterator.hasNext())&#123;<br>        <span class="hljs-keyword">if</span>(iterator.next().equals(<span class="hljs-string">&quot;B&quot;</span>)) iterator.remove();<br>    &#125;<br>  <br>  <span class="hljs-comment">//这是通过Stream的处理</span><br>    list = list     <span class="hljs-comment">//链式调用</span><br>            .stream()    <span class="hljs-comment">//获取流</span><br>            .filter(e -&gt; !e.equals(<span class="hljs-string">&quot;B&quot;</span>))   <span class="hljs-comment">//只允许所有不是B的元素通过流水线</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//将流水线中的元素重新收集起来，变回List</span><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>看完这个例子之后，好像感觉除了写法高级了点之外，也没什么区别啊？这有啥用啊。虽然看起来是一样的，但是实际上它们的执行过程存在一定的差别。</p><p>同样是一批数据，直接编写操作对数据处理相当于吧这一批数据处理完之后，又开始下一个步骤继续处理这一批数据，每一步需要等到上一步结束之后，拿到上一批数据才能开始下一步，每一个流程依次进行：</p><p><img src="https://s2.loli.net/2025/07/07/QRBxXyA9OlC7sFf.png" alt="image-20250707230607130"></p><p>而Stream则是提前编排好流程，每一个元素依次独立走完流水线，无需按批次完成：</p><p><img src="https://s2.loli.net/2025/07/07/7oh9XCp5cK6vJlL.png" alt="image-20250707230814486"></p><p>前者需要在不同工厂之间传递整批数据，而后者则是直接把所有工厂揉在一起，形成流水线。</p><p>我们再通过一个例子来感受一下这种过程，下面的例子包含三个操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; x)  <span class="hljs-comment">//map可以对实现接受一种类型的数据，转为同类型或另一类型的数据</span><br>        .map(x -&gt; x)  <span class="hljs-comment">//这里为了简单好理解，就不做任何处理原样返回</span><br>        .forEach(System.out::println);  <span class="hljs-comment">//最后一步是打印</span><br></code></pre></td></tr></table></figure><p>现在我们在每一步操作上都添加一个打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第一步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)  <span class="hljs-comment">//map可以对实现接受一种类型的数据，转为同类型或另一类型的数据</span><br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第二步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>得到的结果为：</p><p><img src="https://s2.loli.net/2025/07/07/RxgFLaSyft8Il6B.png" alt="image-20250707232051022"></p><p>乍一看好像有点看不懂啊，这顺序怎么好像是乱的呢，实则不然，还记得我们上面说的每个元素依次走流水线吗？我们可以来看前三步，首先是1号元素进入到第一步，接着进入到第二步，最后在第三步打印时结束。此时1号元素结束，紧接着又是2号元素在进行同样的流水线流程，这下就很清晰了，确实是依次按照流水线执行。</p><p>实际上，在我们调用Stream的各种方法时，并不是像我们之前那样直接对数据进行处理，而是在进行编排，直到我们调用最后一步<code>forEach</code>或是<code>collect</code>这种收尾的方法时，整个流水线才开始运作（不相信可以试试看去掉最后的收尾操作，不会有任何操作执行）这也是Stream的一种惰性的体现。</p><p><strong>注意：</strong> 后续我们学习多线程之后，Stream甚至还能利用多线程，同时开展N条流水线进行处理，大大提升数据处理效率。</p><p>我们再来看一个例子，这个例子包含四个流水线操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>list.stream()<br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第一步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)  <span class="hljs-comment">//过滤掉所有奇数</span><br>        .map(x -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是第三步: &quot;</span> + x);<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/07/1reHCPgmLAMs7cX.png" alt="image-20250707232933301"></p><p>其中，由于第二步中进行了过滤操作，很多元素在进入到第三步之前就被提前丢弃了。这在处理大量数据的时候非常有效，一次性处理全部数据会占用非常多的内存，而通过流水线一步一步进行，依次进行数据处理会省去很多内存开销。</p><p>同时，利用流中提供的预设操作，我们无需自己编写繁琐的操作流程代码，只需要调用几个方法进行编排即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><br>    list = list<br>            .stream()<br>      .distinct()   <span class="hljs-comment">//去重（使用equals判断）</span><br>            .sorted((a, b) -&gt; b - a)    <span class="hljs-comment">//进行倒序排列</span><br>            .map(e -&gt; e+<span class="hljs-number">1</span>)    <span class="hljs-comment">//每个元素都要执行+1操作</span><br>            .limit(<span class="hljs-number">2</span>)    <span class="hljs-comment">//只放行前两个元素</span><br>            .collect(Collectors.toList());<br><br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p>当遇到大量的复杂操作时，我们可以使用Stream来快速编写，这样不仅代码量大幅度减少，而且逻辑也更加清晰明了。</p><p>接下来，我们用一堆随机数来进行更多流操作的演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <span class="hljs-comment">//没想到吧，Random支持直接生成随机数的流</span><br>    random<br>            .ints(-<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)   <span class="hljs-comment">//生成-100~100之间的，随机int型数字（本质上是一个IntStream）</span><br>            .limit(<span class="hljs-number">10</span>)   <span class="hljs-comment">//只获取前10个数字（这是一个无限制的流，如果不加以限制，将会无限进行下去！）</span><br>            .filter(i -&gt; i &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">//只保留小于0的数字</span><br>            .sorted()    <span class="hljs-comment">//默认从小到大排序</span><br>            .forEach(System.out::println);   <span class="hljs-comment">//依次打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，由于Stream是惰性的，每次只会让Random生成一个新的数据，直到达到<code>limit()</code>阈值，Random则不会再继续生产新的数据了。</p><p>利用StreamAPI提供的快捷操作，我们可以创建一个<code>IntSummaryStatistics</code>统计实例对象来帮助我们快速进行统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();  <span class="hljs-comment">//Random是一个随机数工具类</span><br>    <span class="hljs-type">IntSummaryStatistics</span> <span class="hljs-variable">statistics</span> <span class="hljs-operator">=</span> random<br>            .ints(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>            .limit(<span class="hljs-number">100</span>)<br>            .summaryStatistics();    <span class="hljs-comment">//获取语法统计实例</span><br>    System.out.println(statistics.getMax());  <span class="hljs-comment">//快速获取最大值</span><br>    System.out.println(statistics.getCount());  <span class="hljs-comment">//获取数量</span><br>    System.out.println(statistics.getAverage());   <span class="hljs-comment">//获取平均值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>普通的List只需要一个方法就可以直接转换到方便好用的IntStream了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>);<br>    list.stream()<br>            .mapToInt(i -&gt; i.length())    <span class="hljs-comment">//将每一个元素映射为Integer类型</span><br>            .summaryStatistics();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以通过<code>flatMap</code>来对整个流进行进一步细分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-string">&quot;A,B&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;C,D&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;E,F&quot;</span>);   <span class="hljs-comment">//我们想让每一个元素通过,进行分割，变成独立的6个元素</span><br>    list = list<br>            .stream()    <span class="hljs-comment">//生成流</span><br>            .flatMap(e -&gt; Arrays.stream(e.split(<span class="hljs-string">&quot;,&quot;</span>)))    <span class="hljs-comment">//分割字符串并生成新的流</span><br>            .collect(Collectors.toList());   <span class="hljs-comment">//汇成新的List</span><br>    System.out.println(list);   <span class="hljs-comment">//得到结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以只通过Stream来完成所有数字的和，使用<code>reduce</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">1</span>);<br>    list.add(<span class="hljs-number">2</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list<br>            .stream()<br>            .reduce((a, b) -&gt; a + b)   <span class="hljs-comment">//计算规则为：a是上一次计算的值，b是当前要计算的参数，这里是求和</span><br>            .get();    <span class="hljs-comment">//我们发现得到的是一个Optional类实例，通过get方法返回得到的值</span><br>    System.out.println(sum);<br>&#125;<br></code></pre></td></tr></table></figure><p>可能，作为新手来说，一次性无法接受这么多内容，但是在各位以后的开发中，就会慢慢使用到这些东西了。</p><h3 id="Java-9-11-16-Stream增强方法"><a href="#Java-9-11-16-Stream增强方法" class="headerlink" title="(Java 9&#x2F;11&#x2F;16) Stream增强方法"></a>(Java 9&#x2F;11&#x2F;16) Stream增强方法</h3><p>由于Java 8推出的Stream获得了不错的反响，于是在Java 9中为其添加了更多方便实用的方法。集合类可以很轻松地转换为Stream：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>List&lt;String&gt; list = Arrays.asList(strings);  <span class="hljs-comment">//还得先转List</span><br>list.stream();<br></code></pre></td></tr></table></figure><p>同样的，Java 8为我们提供了<code>of</code>方法用于快速将数组或单个元素包装为Steam对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>Stream.of(strings).forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>在Java 9之后，对于可能为<code>null</code>的元素，我们也可以使用<code>ofNullable</code>方法来包装，如果发现传入的为<code>null</code>则返回一个空的Stream。</p><p>当然也新增了一些比较方便的操作，我们先来看<code>takeWhile</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>);<br>list.stream()<br>        .takeWhile(s -&gt; s.length() &lt;= <span class="hljs-number">3</span>)   <span class="hljs-comment">//不断获取直到不满足条件为止，与filter类似，但是会提前终止</span><br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>与之相反的还有<code>dropWhile</code>会尝试不断丢弃，直到第一个不满足条件的出现，才开始依次把元素往下一个流水线输送。</p><p>针对于String类型，我们也可以使用流的形式处理其中的每一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">str.chars()  <span class="hljs-comment">//使用chars得到一个包含每个字符代码的IntStream</span><br>        .filter(c -&gt; c == <span class="hljs-string">&#x27;l&#x27;</span>)<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><blockquote><p>与其相似的还有一个codePoints方法，它可以按照按完整Unicode代码点处理，确保字符完整性和正确性，用于字符串中存在一些特殊字符的情况。</p></blockquote><p>还有一个就是Java 11新增的<code>lines()</code>方法，它会自动对字符串按行分割，返回每一行的子串流。</p><p>在Java 16中，Stream中的操作被进一步强化，其中最有用的是常用的<code>List</code>收集被直接整合为了一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;AA&quot;</span>&#125;;<br>Stream.of(strings)<br>        .filter(s -&gt; s.length() &gt; <span class="hljs-number">2</span>)<br>        .toList();   <span class="hljs-comment">//Java 16之后可以直接使用toList而不是collect</span><br></code></pre></td></tr></table></figure><p>除此之外，还有<code>mapMulti</code>以及其衍生方法，不过这个方法效果与<code>flatMap</code>相似，用法传参相对比较复杂，在一些特殊情况下使用，这里就不进行介绍了，感兴趣可以自行了解。</p><h3 id="Java-24-流聚集器"><a href="#Java-24-流聚集器" class="headerlink" title="(Java 24) 流聚集器"></a>(Java 24) 流聚集器</h3><p>传统Stream操作是无状态的，每个元素处理的流程单独进行，而Gatherers可以在处理过程中的同时维护状态，让前面元素的处理结果影响后续元素的处理方式，这里我们来尝试一下官方预设的一些操作。</p><p>现在给你一个需求，我们现在需要将包含<code>[A, B, C, D]</code>的流进行两两分组，得到<code>[[A, B],[C, D]]</code>然后再处理成每个分组内两个字符串合并的字符串，最后得到<code>[AB, CD]</code>，现在你该怎么做？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        <span class="hljs-comment">//需要使用Collectors的groupingBy工具进行分组，得到Map</span><br>        .collect(Collectors.groupingBy(s -&gt; list.indexOf(s) / <span class="hljs-number">2</span>))<br>  <span class="hljs-comment">//把Map的值全部取出来，在转为stream</span><br>        .values()<br>        .stream()<br>        .map(group -&gt; group.get(<span class="hljs-number">0</span>) + group.get(<span class="hljs-number">1</span>))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>可以看到，在之前要对数据进行动态处理，实在是太累了，又有了Gatherers之后，我们可以像这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        .gather(Gatherers.windowFixed(<span class="hljs-number">2</span>))  <span class="hljs-comment">//使用Gatherers的windowFixed创建固定窗口，元素将按照窗口大小自动进行分组</span><br>        .map(item -&gt; item.getFirst() + item.getLast())<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>其中<code>windowFixed</code>就实现了对元素的有状态操作，它不断接受到来的元素，并将其暂存，达到窗口大小之后作为一个新的元素打包返回。</p><p>我们也可以自行编写一个聚集器来感受这种带状态的流操作，同样是实现上面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; tempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();   <span class="hljs-comment">//临时使用一个外部的数组保存临时结果</span><br>list.stream()<br>        .gather(Gatherer.of((_, item, downstream) -&gt; &#123;  <span class="hljs-comment">//要求传入Integrator函数式接口，它用于依次处理流中每个元素</span><br>            tempList.add(item);   <span class="hljs-comment">//其中item就是当前元素，downstream代表下游，用于继续向下游发送元素</span><br>            <span class="hljs-keyword">if</span>(tempList.size() &lt; <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">//如果临时列表元素不足2个，则继续缓存</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//返回true表示就行处理下一个，false就终止</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                downstream.push(List.copyOf(tempList));  <span class="hljs-comment">//当元素存满2个时，向下游发送打包好的分组结果</span><br>                tempList.clear();   <span class="hljs-comment">//清理，给后面来的接着用</span><br>                <span class="hljs-keyword">return</span> downstream.isRejecting();  <span class="hljs-comment">//这里需要判断下游是否还愿意继续接受新元素，因为有可能下游存在limit之类的操作，不需要再继续发送元素了，所以要返回判断结果</span><br>            &#125;<br>        &#125;))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>当然，这里只是简单演示Gatherer的功能，<code>Gatherer.of</code>还包含更多参数选项。</p><p>此外，官方还为我们提供了一些其他的预设的工具，比如<code>fold</code>，它是一个多对一的有状态收集器，有点类似于<code>reduce</code>的感觉，比如我们想实现列表去重功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>list.stream()    <span class="hljs-comment">//让HashSet作为初始状态存储工具</span><br>        .gather(Gatherers.fold(HashSet::<span class="hljs-keyword">new</span>, (set, item) -&gt; &#123;<br>            set.add(item);   <span class="hljs-comment">//向Set中添加元素</span><br>            <span class="hljs-keyword">return</span> set;   <span class="hljs-comment">//操作完成后需要返回set用于下一轮</span><br>        &#125;))<br>        .flatMap(Collection::stream)  <span class="hljs-comment">//对得到的Set集合展平</span><br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p>接着是<code>scan</code>，它会依次扫描流中每个元素，并会在下一轮中给出上一轮被扫描过的元素，这很适合那些需要用到上一轮计算结果的操作。比如我想让列表<code>[A, B, C, D]</code>变成<code>[A, AB, ABC, ABCD]</code>这种金字塔状，就可以使用这种操作完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>);<br>list.stream()<br>        .gather(Gatherers.scan(() -&gt; <span class="hljs-string">&quot;0&quot;</span>, (current, item) -&gt; current + item))<br>        .forEach(System.out::println);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/An9adO416pRmLEc.png" alt="image-20250709221429476"></p><p>最后还有一个<code>mapConcurrent</code>方法，它可以并发实现对元素的映射，相当于是多线程版本的<code>map</code>操作，有关多线程的内容，我们会放在后面的章节讲解。</p><hr><h2 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a>Java I&#x2F;O</h2><p><strong>注意：</strong> 这块会涉及到<strong>操作系统</strong>和<strong>计算机组成原理</strong>相关内容。</p><p>I&#x2F;O简而言之，就是输入输出，那么为什么会有I&#x2F;O呢？其实I&#x2F;O无时无刻都在我们的身边，比如读取硬盘上的文件，网络文件传输，鼠标键盘输入，也可以是接受单片机发回的数据，而能够支持这些操作的设备就是I&#x2F;O设备。</p><p>我们可以大致看一下整个计算机的总线结构：</p><p><img src="https://s2.loli.net/2022/10/04/Q8JGeMprkgHsnPY.png" alt="image-20221004002405375"></p><p>常见的I&#x2F;O设备一般是鼠标、键盘这类通过USB进行传输的外设或者是通过Sata接口或是M.2连接的硬盘。一般情况下，这些设备是由CPU发出指令通过南桥芯片间接进行控制，而不是由CPU直接操作。</p><p>而我们在程序中，想要读取这些外部连接的I&#x2F;O设备中的内容，就需要将数据传输到内存中。而需要实现这样的操作，单单凭借一个小的程序是无法做到的，而操作系统（如：Windows&#x2F;Linux&#x2F;MacOS）就是专门用于控制和管理计算机硬件和软件资源的软件，我们需要读取一个IO设备的内容时，就可以向操作系统发出请求，由操作系统帮助我们来和底层的硬件交互以完成我们的读取&#x2F;写入请求。</p><p>从读取硬盘文件的角度来说，不同的操作系统有着不同的文件系统（也就是文件在硬盘中的存储排列方式，如Windows就是NTFS、MacOS就是APFS），硬盘只能存储一个个0和1这样的二进制数据，至于0和1如何排列，各自又代表什么意思，就是由操作系统的文件系统来决定的。从网络通信角度来说，网络信号通过网卡等设备翻译为二进制信号，再交给系统进行读取，最后再由操作系统来给到程序。</p><p><img src="https://s2.loli.net/2022/10/04/13h7yTekm2FfnRw.png" alt="image-20221004002733950"></p><p>（传统的SATA硬盘就是通过SATA线与电脑主板相连，这样才可以读取到数据）</p><p>JDK提供了一套用于IO操作的框架，为了方便我们开发者使用，就定义了一个像水流一样，根据流的传输方向和读取单位，分为字节流InputStream和OutputStream以及字符流Reader和Writer的IO框架，当然，这里的Stream并不是前面集合框架认识的Stream，这里的流指的是数据流，通过流，我们就可以一直从流中读取数据，直到读取到尽头，或是不断向其中写入数据，直到我们写入完成，而这类IO就是我们所说的BIO，</p><p>字节流一次读取一个字节，也就是一个<code>byte</code>的大小，而字符流顾名思义，就是一次读取一个字符，也就是一个<code>char</code>的大小（在读取纯文本文件的时候更加适合），有关这两种流，会在后面详细介绍，这个章节我们需要学习16个关键的流。</p><h3 id="文件字节流"><a href="#文件字节流" class="headerlink" title="文件字节流"></a>文件字节流</h3><p>要学习和使用IO，首先就要从最易于理解的读取文件开始说起。</p><p>首先介绍一下FileInputStream，我们可以通过它来获取文件的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">//注意，IO相关操作会有很多影响因素，有可能出现异常，所以需要明确进行处理</span><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>);<br>        <span class="hljs-comment">//路径支持相对路径和绝对路径</span><br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>相对路径是在当前运行目录（就是你在哪个目录运行java命令启动Java程序的）的路径下寻找文件，而绝对路径，是从根目录开始寻找。路径分割符支持使用<code>/</code>或是<code>\\</code>，但是不能写为<code>\</code>因为它是转义字符！比如在Windows下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">C://User/lbw/nb    这个就是一个绝对路径，因为是从盘符开始的<br><span class="hljs-built_in">test</span>/test          这个就是一个相对路径，因为并不是从盘符开始的，而是一个直接的路径<br></code></pre></td></tr></table></figure><p>在Linux和MacOS下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/root/tmp       这个就是一个绝对路径，绝对路径以/开头<br><span class="hljs-built_in">test</span>/test       这个就是一个相对路径，不是以/开头的<br></code></pre></td></tr></table></figure><p>当然，这个其实还是很好理解的，我们在使用时注意一下就行了。</p><p>在使用完成一个流之后，必须关闭这个流来完成对资源的释放，否则资源会被一直占用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-comment">//定义可以先放在try外部</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        inputStream = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//建议在finally中进行，因为关闭流是任何情况都必须要执行的！</span><br>            <span class="hljs-keyword">if</span>(inputStream != <span class="hljs-literal">null</span>) inputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这样的写法才是最保险的，但是显得过于繁琐了，尤其是finally中再次嵌套了一个try-catch块，因此在JDK1.7新增了try-with-resource语法，用于简化这样的写法（本质上还是和这样的操作一致，只是换了个写法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-comment">//注意，这种语法只支持实现了AutoCloseable接口的类！</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;路径&quot;</span>)) &#123;   <span class="hljs-comment">//直接在try()中定义要在完成之后释放的资源</span><br><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;   <span class="hljs-comment">//这里变成IOException是因为调用close()可能会出现，而FileNotFoundException是继承自IOException的</span><br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-comment">//无需再编写finally语句块，因为在最后自动帮我们调用了close()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后为了方便，我们都使用此语法进行教学。</p><p>现在我们拿到了文件的输入流，那么怎么才能读取文件里面的内容呢？我们可以使用<code>read</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：a</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//使用read()方法进行字符读取</span><br>        System.out.println((<span class="hljs-type">char</span>) inputStream.read());  <span class="hljs-comment">//读取一个字节的数据（英文字母只占1字节，中文占2字节）</span><br>        System.out.println(inputStream.read());   <span class="hljs-comment">//唯一一个字节的内容已经读完了，再次读取返回-1表示没有内容了</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用read可以直接读取一个字节的数据，注意，流的内容是有限的，读取一个少一个。我们如果想一次性全部读取的话，可以直接使用一个while循环来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read()) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//通过while循环来一次性读完内容</span><br>            System.out.println((<span class="hljs-type">char</span>)tmp);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>available</code>方法能查看当前可读的剩余字节数量（注意：并不一定真实的数据量就是这么多，尤其是在网络I&#x2F;O操作时，这个方法只能进行一个预估也可以说是暂时能一次性可以读取的数量，当然在磁盘IO下，一般情况都是真实的数据量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>    System.out.println(inputStream.available());  <span class="hljs-comment">//查看剩余数量</span><br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，一个一个读取效率太低了，那能否一次性全部读取呢？我们可以预置一个合适容量的byte[]数组来存放：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];   <span class="hljs-comment">//我们可以提前准备好合适容量的byte数组来存放</span><br>        System.out.println(inputStream.read(bytes));   <span class="hljs-comment">//一次性读取全部内容（返回值是读取的字节数）</span><br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));   <span class="hljs-comment">//通过String(byte[])构造方法得到字符串</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以控制要读取数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(inputStream.read(bytes, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>));   <span class="hljs-comment">//第二个参数是从给定数组的哪个位置开始放入内容，第三个参数是读取流中的字节数</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一次性读取同单个读取一样，当没有任何数据可读时，依然会返回-1</p><p>通过<code>skip()</code>方法可以跳过指定数量的字节，返回值为实际跳过的字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//test.txt：abcd</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;<br>        System.out.println(inputStream.skip(<span class="hljs-number">1</span>));<br>        System.out.println((<span class="hljs-type">char</span>) inputStream.read());   <span class="hljs-comment">//跳过了一个字节</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：FileInputStream是不支持<code>reset()</code>的，虽然有这个方法，但是这里先不提及。</p><p>既然有输入流，那么文件输出流也是必不可少的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//输出流也需要在最后调用close()方法，并且同样支持try-with-resource</span><br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        <span class="hljs-comment">//注意：若此文件不存在，会直接创建这个文件！</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出流没有<code>read()</code>操作而是<code>write()</code>操作，使用方法同输入流一样，只不过现在的方向变为我们向文件里写入内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)) &#123;<br>        outputStream.write(<span class="hljs-string">&#x27;c&#x27;</span>);   <span class="hljs-comment">//同read一样，可以直接写入内容</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());   <span class="hljs-comment">//也可以直接写入byte[]</span><br>      outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes(), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//同上输入流</span><br>      outputStream.flush();  <span class="hljs-comment">//建议在最后执行一次刷新操作（强制写入）来保证数据正确写入到硬盘文件中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果是我只想在文件尾部进行追加写入数据呢？我们可以调用另一个构造方法来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>, <span class="hljs-literal">true</span>)) &#123;  <span class="hljs-comment">//true表示开启追加模式</span><br>        outputStream.write(<span class="hljs-string">&quot;lb&quot;</span>.getBytes());   <span class="hljs-comment">//现在只会进行追加写入，而不是直接替换原文件内容</span><br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用输入流和输出流，就可以轻松实现文件的拷贝了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>);<br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)) &#123;   <span class="hljs-comment">//可以写入多个</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];    <span class="hljs-comment">//使用长度为10的byte[]做传输媒介</span><br>        <span class="hljs-type">int</span> tmp;   <span class="hljs-comment">//存储本地读取字节数</span><br>        <span class="hljs-keyword">while</span> ((tmp = inputStream.read(bytes)) != -<span class="hljs-number">1</span>)&#123;   <span class="hljs-comment">//直到读取完成为止</span><br>            outputStream.write(bytes, <span class="hljs-number">0</span>, tmp);    <span class="hljs-comment">//写入对应长度的数据到输出流</span><br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件字符流"><a href="#文件字符流" class="headerlink" title="文件字符流"></a>文件字符流</h3><p>字符流不同于字节，字符流是以一个具体的字符进行读取，因此它只适合读纯文本的文件，如果是其他类型的文件不适用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>      reader.skip(<span class="hljs-number">1</span>);   <span class="hljs-comment">//现在跳过的是一个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) reader.read());   <span class="hljs-comment">//现在是按字符进行读取，而不是字节，因此可以直接读取到中文字符</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理，字符流只支持<code>char[]</code>类型作为存储：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))&#123;<br>        <span class="hljs-type">char</span>[] str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">10</span>];<br>        reader.read(str);<br>        System.out.println(str);   <span class="hljs-comment">//直接读取到char[]中</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然有了Reader肯定也有Writer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>))&#123;<br>      writer.getEncoding();   <span class="hljs-comment">//支持获取编码（不同的文本文件可能会有不同的编码类型）</span><br>       writer.write(<span class="hljs-string">&#x27;牛&#x27;</span>);<br>       writer.append(<span class="hljs-string">&#x27;牛&#x27;</span>);   <span class="hljs-comment">//其实功能和write一样</span><br>      writer.flush();   <span class="hljs-comment">//刷新</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现不仅有<code>write()</code>方法，还有一个<code>append()</code>方法，但是实际上他们效果是一样的，看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Writer <span class="hljs-title function_">append</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    write(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>append支持像StringBuilder那样的链式调用，返回的是Writer对象本身。</p><p><strong>练习</strong>：尝试一下用Reader和Writer来拷贝纯文本文件。</p><p>这里需要额外介绍一下File类，它是专门用于表示一个文件或文件夹，只不过它只是代表这个文件，但并不是这个文件本身。通过File对象，可以更好地管理和操作硬盘上的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);   <span class="hljs-comment">//直接创建文件对象，可以是相对路径，也可以是绝对路径</span><br>    System.out.println(file.exists());   <span class="hljs-comment">//此文件是否存在</span><br>    System.out.println(file.length());   <span class="hljs-comment">//获取文件的大小</span><br>    System.out.println(file.isDirectory());   <span class="hljs-comment">//是否为一个文件夹</span><br>    System.out.println(file.canRead());   <span class="hljs-comment">//是否可读</span><br>    System.out.println(file.canWrite());   <span class="hljs-comment">//是否可写</span><br>    System.out.println(file.canExecute());   <span class="hljs-comment">//是否可执行</span><br>  <br>    file.createNewFile();   <span class="hljs-comment">//创建新文件</span><br>    file.delete();   <span class="hljs-comment">//删除文件</span><br>    file.mkdir();    <span class="hljs-comment">//创建目录，但父级目录不存在会直接报错</span><br>    file.mkdirs();   <span class="hljs-comment">//创建目录，如果父级目录不存在会一起创建</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过File对象，我们就能快速得到文件的所有信息，如果是文件夹，还可以获取文件夹内部的文件列表等内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>System.out.println(Arrays.toString(file.list()));   <span class="hljs-comment">//快速获取文件夹下的文件名称列表</span><br><span class="hljs-keyword">for</span> (File f : file.listFiles())&#123;   <span class="hljs-comment">//所有子文件的File对象</span><br>    System.out.println(f.getAbsolutePath());   <span class="hljs-comment">//获取文件的绝对路径</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们希望读取某个文件的内容，可以直接将File作为参数传入字节流或是字符流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file))&#123;   <span class="hljs-comment">//直接做参数</span><br>    System.out.println(inputStream.available());<br>&#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习</strong>：尝试拷贝文件夹下的所有文件到另一个文件夹</p><h3 id="Java-7-8-11-文件工具类"><a href="#Java-7-8-11-文件工具类" class="headerlink" title="(Java 7&#x2F;8&#x2F;11) 文件工具类"></a>(Java 7&#x2F;8&#x2F;11) 文件工具类</h3><p><code>Files</code>类是<code>java.nio.file</code>包中的一个实用类，在Java 7中推出，提供了许多静态方法，用于文件和目录的操作。它大大简化了文件处理的工作，例如创建、删除、读取、写入和属性管理等。比如之前的创建目录操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    Files.createDirectory(Path.of(<span class="hljs-string">&quot;./test&quot;</span>));  <span class="hljs-comment">//使用createDirectory直接创建一个指定目录</span><br>    Files.createDirectories(Path.of(<span class="hljs-string">&quot;./test&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中提供了非常方便的方法直接创建目录，只不过此工具类的路径需要配合<code>Path</code>对象来指定，它代表一个文件路径，可以直接通过<code>of</code>方法来创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;src/com/test&quot;</span>);<br>System.out.println(path.toAbsolutePath());   <span class="hljs-comment">//获取绝对路径</span><br>System.out.println(path.toAbsolutePath().getParent());  <span class="hljs-comment">//获取父路径</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/1YIRTzM3nWwL8xK.png" alt="image-20250708204944405"></p><p>利用此类型代表路径，可以为我们带来更多的便利，如快速获取绝对路径、父级目录等。现在回到<code>Files</code>类，对于文件的删除也是很方便的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;test&quot;</span>);<br>Files.delete(path);   <span class="hljs-comment">//删除，没有文件报错</span><br>Files.deleteIfExists(path);  <span class="hljs-comment">//删除，没有文件返回false否则返回true</span><br></code></pre></td></tr></table></figure><p>还有很多对于文件的快捷操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.readString(path)   <span class="hljs-comment">//Java 11新增，读取所有内容并以字符串返回</span><br>List&lt;String&gt; lines = Files.readAllLines(path);   <span class="hljs-comment">//一键读取所有文件内容并按行分割返回</span><br>Stream&lt;String&gt; linesStream = Files.lines(path);   <span class="hljs-comment">//同上，以Java 8之后的Stream形式返回</span><br><br>Files.write(path, <span class="hljs-string">&quot;HelloWorld&quot;</span>.getBytes());   <span class="hljs-comment">//一键写入内容</span><br>Files.writeString(path, <span class="hljs-string">&quot;HelloWorld&quot;</span>);  <span class="hljs-comment">//Java 11新增，更快捷的用字符串一键写入</span><br><br>Files.copy(path, Path.of(<span class="hljs-string">&quot;another&quot;</span>));   <span class="hljs-comment">//拷贝文件到另一个路径</span><br>Files.move(path, Path.of(<span class="hljs-string">&quot;another&quot;</span>));   <span class="hljs-comment">//移动文件到另一个路径</span><br><br>Files.exists(path);   <span class="hljs-comment">//判断文件是否存在</span><br>Files.notExists(path);  <span class="hljs-comment">//判断文件是否不存在</span><br><br>Files.isExecutable(path);  <span class="hljs-comment">//文件是否可执行</span><br>Files.isDirectory(path);  <span class="hljs-comment">//文件是否是文件夹</span><br>Files.isWritable(path);   <span class="hljs-comment">//文件是否可写</span><br>Files.isReadable(path);   <span class="hljs-comment">//文件是否可读</span><br>Files.isHidden(path);   <span class="hljs-comment">//文件是否为隐藏文件</span><br><br>Files.newInputStream(path);  <span class="hljs-comment">//创建新的文件输入流</span><br>Files.newOutputStream(path);   <span class="hljs-comment">//创建新的文件输出流</span><br></code></pre></td></tr></table></figure><p>此外，对于文件的查找，该工具类也给了非常好用API，其中<code>find</code>方法可以帮助我们快速查找文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//其中第一个参数为起始查找点，第二参数为最大查找深度，最后就是一个断言函数式，就是判断每一个文件是否符合我们要查找的要求</span><br>Files.find(Path.of(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-number">4</span>, (path, attributes) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (path.getFileName().toString().equals(<span class="hljs-string">&quot;Main.java&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;).forEach(path -&gt; &#123;   <span class="hljs-comment">//find的结果会以Stream的形式返回</span><br>    System.out.println(path);<br>&#125;);<br></code></pre></td></tr></table></figure><p>对于整个目录下文件的遍历，我们可以使用<code>walkFileTree</code>方法，此方法需要我们手动实现一个<code>FileVisitor</code>类，用于指定文件的查找操作，假设我们希望遍历项目目录下所有文件并打印所有非文件夹的普通文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个参数指定起始位置，第二个参数实现FileVisitor</span><br>Files.walkFileTree(Path.of(<span class="hljs-string">&quot;.&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;找到目录: &quot;</span> + dir.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;  <span class="hljs-comment">//需要返回一个文件结果，CONTINUE就是继续，如果不想继续了也可以返回TERMINATE或是SKIP_SUBTREE跳过这个目录</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;找到文件: &quot;</span> + file.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFileFailed</span><span class="hljs-params">(Path file, IOException exc)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.err.println(<span class="hljs-string">&quot;访问失败: &quot;</span> + file.toString());<br>        <span class="hljs-keyword">return</span> FileVisitResult.CONTINUE;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>不过上面这种方式写起来还是有点复杂，在Java8之后，Files也为我们提供了很方便的<code>walk</code>方法，它同样是返回一个Stream给我们，其中包含遍历的每一个文件的<code>Path</code>对象，这样就简单多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Files.walk(Path.of(<span class="hljs-string">&quot;.&quot;</span>))  <span class="hljs-comment">//返回Stream&lt;Path&gt;</span><br>        .filter(Files::isRegularFile)   <span class="hljs-comment">//filter过滤判断是否为普通文件</span><br>        .forEach(System.out::println);   <span class="hljs-comment">//打印</span><br></code></pre></td></tr></table></figure><p>有关Files的相关操作就介绍到这里，详细内容各位小伙伴可以继续尝试探索。</p><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>虽然普通的文件流读取文件数据非常便捷，但是每次都需要从外部I&#x2F;O设备去获取数据，由于外部I&#x2F;O设备的速度一般都达不到内存的读取速度，很有可能造成程序反应迟钝，因此性能还不够高，而缓冲流正如其名称一样，它能够提供一个缓冲，提前将部分内容存入内存（缓冲区）在下次读取时，如果缓冲区中存在此数据，则无需再去请求外部设备。同理，当向外部设备写入数据时，也是由缓冲区处理，而不是直接向外部设备写入。</p><p><img src="https://s2.loli.net/2022/10/04/S8O61JP2lqKTzjd.png" alt="image-20221004125755217"></p><p>要创建一个缓冲字节流，只需要将原本的流作为构造参数传入BufferedInputStream即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;   <span class="hljs-comment">//传入FileInputStream</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//操作和原来的流是一样的</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上进行I&#x2F;O操作的并不是BufferedInputStream，而是我们传入的FileInputStream，而BufferedInputStream虽然有着同样的方法，但是进行了一些额外的处理然后再调用FileInputStream的同名方法，这样的写法称为<code>装饰者模式</code>，我们会在设计模式篇中详细介绍。我们可以来观察一下它的<code>close</code>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">byte</span>[] buffer;<br>    <span class="hljs-keyword">while</span> ( (buffer = buf) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (bufUpdater.compareAndSet(<span class="hljs-built_in">this</span>, buffer, <span class="hljs-literal">null</span>)) &#123;  <span class="hljs-comment">//CAS无锁算法，并发会用到，暂时不需要了解</span><br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> in;<br>            in = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-literal">null</span>)<br>                input.close();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Else retry in case a new buf was CASed in fill()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这种模式是父类FilterInputStream提供的规范，后面我们还会讲到更多FilterInputStream的子类。</p><p>我们可以发现在BufferedInputStream中还存在一个专门用于缓存的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The internal buffer array where the data is stored. When necessary,</span><br><span class="hljs-comment"> * it may be replaced by another array of</span><br><span class="hljs-comment"> * a different size.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">byte</span> buf[];<br></code></pre></td></tr></table></figure><p>I&#x2F;O操作一般不能重复读取内容（比如键盘发送的信号，主机接收了就没了），而缓冲流提供了缓冲机制，一部分内容可以被暂时保存，BufferedInputStream支持<code>reset()</code>和<code>mark()</code>操作，首先我们来看看<code>mark()</code>方法的介绍：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marks the current position in this input stream. A subsequent</span><br><span class="hljs-comment"> * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at</span><br><span class="hljs-comment"> * the last marked position so that subsequent reads re-read the same bytes.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to</span><br><span class="hljs-comment"> * allow that many bytes to be read before the mark position gets</span><br><span class="hljs-comment"> * invalidated.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span><br><span class="hljs-comment"> *                      the mark position becomes invalid.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#in</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     java.io.FilterInputStream#reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mark</span><span class="hljs-params">(<span class="hljs-type">int</span> readlimit)</span> &#123;<br>    in.mark(readlimit);<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用<code>mark()</code>之后，输入流会以某种方式保留之后读取的<code>readlimit</code>数量的内容，当读取的内容数量超过<code>readlimit</code>则之后的内容不会被保留，当调用<code>reset()</code>之后，会使得当前的读取位置回到<code>mark()</code>调用时的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        bufferedInputStream.reset();   <span class="hljs-comment">//回到mark时的位置</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现虽然后面的部分没有保存，但是依然能够正常读取，其实<code>mark()</code>后保存的读取内容是取<code>readlimit</code>和BufferedInputStream类的缓冲区大小两者中的最大值，而并非完全由<code>readlimit</code>确定。因此我们限制一下缓冲区大小，再来观察一下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bufferedInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>), <span class="hljs-number">1</span>))&#123;  <span class="hljs-comment">//将缓冲区大小设置为1</span><br>        bufferedInputStream.mark(<span class="hljs-number">1</span>);   <span class="hljs-comment">//只保留之后的1个字符</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());   <span class="hljs-comment">//已经超过了readlimit，继续读取会导致mark失效</span><br>        bufferedInputStream.reset();   <span class="hljs-comment">//mark已经失效，无法reset()</span><br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>        System.out.println((<span class="hljs-type">char</span>) bufferedInputStream.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>了解完了BufferedInputStream之后，我们再来看看BufferedOutputStream，其实和BufferedInputStream原理差不多，只是反向操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        outputStream.write(<span class="hljs-string">&quot;lbwnb&quot;</span>.getBytes());<br>        outputStream.flush();<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>操作和FileOutputStream一致，这里就不多做介绍了。</p><p>既然有缓冲字节流，那么肯定也有缓冲字符流，缓冲字符流和缓冲字节流一样，也有一个专门的缓冲区，BufferedReader构造时需要传入一个Reader对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用和reader也是一样的，内部也包含一个缓存数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">char</span> cb[];<br></code></pre></td></tr></table></figure><p>相比Reader更方便的是，它支持按行读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(reader.readLine());   <span class="hljs-comment">//按行读取</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取后直接得到一个字符串，当然，它还能把每一行内容依次转换为集合类提到的Stream流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader<br>                .lines()<br>                .limit(<span class="hljs-number">2</span>)<br>                .distinct()<br>                .sorted()<br>                .forEach(System.out::println);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它同样也支持<code>mark()</code>和<code>reset()</code>操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        reader.mark(<span class="hljs-number">1</span>);<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>        reader.reset();<br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BufferedReader处理纯文本文件时就更加方便了，BufferedWriter在处理时也同样方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        reader.newLine();   <span class="hljs-comment">//使用newLine进行换行</span><br>        reader.write(<span class="hljs-string">&quot;汉堡做滴彳亍不彳亍&quot;</span>);   <span class="hljs-comment">//可以直接写入一个字符串</span><br>      reader.flush();   <span class="hljs-comment">//清空缓冲区</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>合理使用缓冲流，可以大大提高我们程序的运行效率，只不过现在初学阶段，很少会有机会接触到实际的应用场景。</p><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>有时会遇到这样一个很麻烦的问题：我这里读取的是一个字符串或是一个个字符，但是我只能往一个OutputStream里输出，但是OutputStream又只支持byte类型，如果要往里面写入内容，进行数据转换就会很麻烦，那么能否有更加简便的方式来做这样的事情呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileOutputStream，但是现在支持以Writer的方式进行写入</span><br>        writer.write(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//以操作Writer的样子写入OutputStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们现在只拿到了一个InputStream，但是我们希望能够按字符的方式读取，我们就可以使用InputStreamReader来帮助我们实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;  <span class="hljs-comment">//虽然给定的是FileInputStream，但是现在支持以Reader的方式进行读取</span><br>        System.out.println((<span class="hljs-type">char</span>) reader.read());<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InputStreamReader和OutputStreamWriter本质也是Reader和Writer，因此可以直接放入BufferedReader来实现更加方便的操作。</p><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流其实我们从一开始就在使用了，比如<code>System.out</code>就是一个PrintStream，PrintStream也继承自FilterOutputStream类因此依然是装饰我们传入的输出流，但是它存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用<code>flush()</code>方法。PrintStream也永远不会抛出异常，而是使用内部检查机制<code>checkError()</code>方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>可以看到<code>System.out</code>也是PrintStream，不过默认是向控制台打印，我们也可以让它向文件中打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">PrintStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        stream.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//其实System.out就是一个PrintStream</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们平时使用的<code>println</code>方法就是PrintStream中的方法，它会直接打印基本数据类型或是调用对象的<code>toString()</code>方法得到一个字符串，并将字符串转换为字符，放入缓冲区再经过转换流输出到给定的输出流上。</p><p><img src="https://s2.loli.net/2022/10/04/w8RKJxLm6Ik5usn.png" alt="img"></p><p>因此实际上内部还包含这两个内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Track both the text- and character-output streams, so that their buffers</span><br><span class="hljs-comment"> * can be flushed without flushing the entire stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> BufferedWriter textOut;<br><span class="hljs-keyword">private</span> OutputStreamWriter charOut;<br></code></pre></td></tr></table></figure><p>与此相同的还有一个PrintWriter，不过他们的功能基本一致，PrintWriter的构造方法可以接受一个Writer作为参数，这里就不再做过多阐述了。</p><p>而我们之前使用的Scanner，使用的是系统提供的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);   <span class="hljs-comment">//系统输入流，默认是接收控制台输入</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用Scanner来扫描其他的输入流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>    <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;秘制小汉堡.txt&quot;</span>));  <span class="hljs-comment">//将文件内容作为输入流进行扫描</span><br>&#125;<br></code></pre></td></tr></table></figure><p>相当于直接扫描文件中编写的内容，同样可以读取。</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>数据流DataInputStream也是FilterInputStream的子类，同样采用装饰者模式，最大的不同是它支持基本数据类型的直接读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dataInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)))&#123;<br>        System.out.println(dataInputStream.readBoolean());   <span class="hljs-comment">//直接将数据读取为任意基本数据类型</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用于写入基本数据类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dataOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        dataOutputStream.writeBoolean(<span class="hljs-literal">false</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，写入的是二进制数据，并不是写入的字符串，使用DataInputStream可以读取，一般他们是配合一起使用的。</p><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><p>既然基本数据类型能够读取和写入基本数据类型，那么能否将对象也支持呢？ObjectOutputStream不仅支持基本数据类型，通过对对象的序列化操作，以某种格式保存对象，来支持对象类型的IO，注意：它不是继承自FilterInputStream的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>      outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);<br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;   <span class="hljs-comment">//必须实现Serializable接口才能被序列化</span><br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们后续的操作中，有可能会使得这个类的一些结构发生变化，而原来保存的数据只适用于之前版本的这个类，因此我们需要一种方法来区分类的不同版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456</span>;   <span class="hljs-comment">//在序列化时，会被自动添加这个属性，它代表当前类的版本，我们也可以手动指定版本。</span><br><br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当发生版本不匹配时，会无法反序列化为对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">java.io.InvalidClassException: com.test.Main$People; local <span class="hljs-keyword">class</span> <span class="hljs-title class_">incompatible</span>: stream <span class="hljs-type">classdesc</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">123456</span>, local <span class="hljs-keyword">class</span> <span class="hljs-title class_">serialVersionUID</span> = <span class="hljs-number">1234567</span><br>at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="hljs-number">699</span>)<br>at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="hljs-number">2003</span>)<br>at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="hljs-number">1850</span>)<br>at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="hljs-number">2160</span>)<br>at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="hljs-number">1667</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">503</span>)<br>at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="hljs-number">461</span>)<br>at com.test.Main.main(Main.java:<span class="hljs-number">27</span>)<br></code></pre></td></tr></table></figure><p>如果我们不希望某些属性参与到序列化中进行保存，我们可以添加<code>transient</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>));<br>         <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;output.txt&quot;</span>)))&#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>(<span class="hljs-string">&quot;lbw&quot;</span>);<br>        outputStream.writeObject(people);<br>        outputStream.flush();<br>        people = (People) inputStream.readObject();<br>        System.out.println(people.name);  <span class="hljs-comment">//虽然能得到对象，但是name属性并没有保存，因此为null</span><br>    &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234567</span>;<br><br>    <span class="hljs-keyword">transient</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实我们可以看到，在一些JDK内部的源码中，也存在大量的transient关键字，使得某些属性不参与序列化，取消这些不必要保存的属性，可以节省数据空间占用以及减少序列化时间。</p><h3 id="字节数组流"><a href="#字节数组流" class="headerlink" title="字节数组流"></a>字节数组流</h3><p>这个流是一个非常特殊的流，它内部维护了一个<code>byte[]</code>类型的对象，用于直接包含流的数据。</p><p>有些时候我们可能希望将某些数据直接转换为流的形式，比如字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-string">&quot;我是一个可爱的字符串&quot;</span>.getBytes());<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">buffered</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(stream));<br>    System.out.println(buffered.readLine());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过构造<code>ByteArrayInputStream</code>来快速将我们需要的数据构造为流，它接受一个<code>byte[]</code>数组，此数组将直接作为其数据，当对流的数据进行读取时，直接返回数据中的内容。</p><p>与之相反的有一个叫<code>ByteArrayOutputStream</code>的流，它内部同样维护一个<code>byte[]</code>数组，用于存放外部写入的数据，在写入数据完成后，我们可以调用<code>toByteArray</code>来获取其中的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>    stream.write(<span class="hljs-string">&quot;Hello, world!&quot;</span>.getBytes());<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(stream.toByteArray()));<br>&#125;<br></code></pre></td></tr></table></figure><p>这两种流在处理一些直接数据时非常方便。</p><h3 id="Java-9-11-12-输入流快捷操作"><a href="#Java-9-11-12-输入流快捷操作" class="headerlink" title="(Java 9&#x2F;11&#x2F;12) 输入流快捷操作"></a>(Java 9&#x2F;11&#x2F;12) 输入流快捷操作</h3><p>在Java9之后，InputStream中新增了很多实用的工具方法，这里我们来学习一下。</p><p>首先是内容读取，在之前我们如果需要读取一个文本文件的内容，需要写一个循环来不断<code>read</code>里面的内容，直到结束，这实在是太繁琐了，通过<code>available()</code>获取的剩余容量又不一定准确。所以，从Java 9 开始，官方内置一个新的方法来便于我们一次性读取文件内容，我们终于可以解放双手了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = stream.readAllBytes();   <span class="hljs-comment">//此方法可以阻塞地一次性读取流中所有剩余字节</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/07/9jLtir2Shd7DWPu.png" alt="image-20250707214750947"></p><p>注意如果流已经被读取完成，调用此方法只能直接返回空数组，因为没数据可读了。</p><p>那如果我需要读取指定数量的数据怎么办呢？同样的，Java 9 为我们提供了<code>readNBytes</code>方法，它可以更灵活地控制读取流中的多少字节或是哪个位置开始的字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">9</span>];<br>    stream.readNBytes(bytes, <span class="hljs-number">0</span>, bytes.length);  <span class="hljs-comment">//从流的起始位置开始读取9个字节</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/07/14cyC8xMJeB5qYL.png" alt="image-20250707215146453"></p><p>注意<code>readNBytes</code>返回值为实际读取的字节数，因为有可能出现流中数据还没有想要的这么长的情况。</p><p>从Java 11开始，我们还可以直接使用一个重载之后的更简单的<code>readNBytes</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>)) &#123;<br>    <span class="hljs-type">byte</span>[] bytes = stream.readNBytes(<span class="hljs-number">9</span>);   <span class="hljs-comment">//和readAllBytes一样，直接返回数组</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>它可以直接指定要读取的数量，并返回对应的byte数组。</p><p>对于值之前的<code>skip()</code>方法，Java 12为我们提供了一个更强大的<code>skipNBytes</code>方法，此方法同样用于跳过指定字节，但是其行为是<strong>精确地跳过</strong>输入流中的 <code>n</code> 个，它不像<code>skip()</code>那样跳过多少算多少，而是要求必须跳过这么多字节，否则抛出<code>EOFException</code>异常，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>.getBytes())) &#123;<br>    stream.skipNBytes(<span class="hljs-number">200</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>Java 11还为我们提供了一个直接生成已读取结束的流的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> InputStream.nullInputStream()) &#123; <span class="hljs-comment">//直接生成一个没有数据的等价于用完的流</span><br>    <span class="hljs-type">byte</span>[] bytes = stream.readAllBytes();<br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));   <span class="hljs-comment">//读取出来的直接就是一个空数组，因为已经用过了</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的还有OutputStream的<code>nullOutputStream</code>方法，生成一个可以无限倾倒数据的输出流，就像给黑洞吞了就没了。</p><p>最后还有一个非常实用的方法，它是Java 9提供的<code>transferTo</code>，它可以直接将当前输入流中的内容转换到一个输出流中，相当于用一个管道直接把输入输出连接起来，输入的内容直接往输出的地方跑。这就很方便了，比如我们要拷贝一个文件，可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;./hello.txt&quot;</span>);<br>     <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;./hello2.txt&quot;</span>)) &#123;<br>    in.transferTo(out);   <span class="hljs-comment">//直接transfer到新文件里，并返回实际传输了多少字节的数据</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个文件拷贝就轻松实现了。</p><hr><h2 id="实战：图书管理系统"><a href="#实战：图书管理系统" class="headerlink" title="实战：图书管理系统"></a>实战：图书管理系统</h2><p>要求实现一个图书管理系统（控制台），支持以下功能：保存书籍信息（要求持久化），查询、添加、删除、修改书籍信息。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/k6fmxd6qabgkwm9i">https://www.itbaima.cn/zh-CN/document/k6fmxd6qabgkwm9i</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（五）泛型程序设计</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/24/AulBzXWK6JCPMH5.png" alt="image-20220924223020333"></p><h1 id="泛型程序设计"><a href="#泛型程序设计" class="headerlink" title="泛型程序设计"></a>泛型程序设计</h1><p>在前面我们学习了最重要的类和对象，了解了面向对象编程的思想，注意，非常重要，面向对象是必须要深入理解和掌握的内容，不能草草结束。在本章节，我们还会继续深入了解，从泛型开始，再到数据结构，最后再开始我们的集合类学习，循序渐进。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？</p><p>现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br>    String name;<br>    String id;<br>    Object value;  <span class="hljs-comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.score = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Score</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);  <span class="hljs-comment">//是String类型的</span><br><br>    ...<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> (Integer) score.score;  <span class="hljs-comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺</p><p>所以说这种解决办法虽然可行，但并不是最好的方案。</p><p>为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型在Java非常重要，我们可以使用一个特殊的名字表示待定类型，在泛型类中，我们可以将这个待定类型添加到类名后，它通常也被称为<strong>类型参数</strong>（Type Parameter）泛型在定义时并不明确是什么类型，而是需要到使用时才会确定具体的类型。</p><p>我们可以将一个类定义为一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>&lt;T&gt; &#123;   <span class="hljs-comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型参数</span><br>    String name;<br>    String id;<br>    T value;   <span class="hljs-comment">//T会根据使用时提供的类型自动变成对应类型</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, T value)</span> &#123;   <span class="hljs-comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看这是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;String&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;String&gt;(<span class="hljs-string">&quot;计算机网络&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-string">&quot;优秀&quot;</span>);<br>  <span class="hljs-comment">//因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型</span><br>  <span class="hljs-comment">//这样我们就可以根据不同的类型进行选择了</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> score.value;   <span class="hljs-comment">//一旦类型明确，那么泛型就变成对应的类型了</span><br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：</p><p><img src="https://s2.loli.net/2022/09/27/RCqAhvMGzNwfH7J.png" alt="image-20220927135128332"></p><p>只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：</p><p><img src="https://s2.loli.net/2022/09/26/gkFs35US9rxo7f2.png" alt="image-20220926235642963"></p><p>我们可以对其进行强制类型转换，但是实际上没多大必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) t;   <span class="hljs-comment">//都明确要用String了，那这里定义泛型不是多此一举吗</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：</p><p><img src="https://s2.loli.net/2022/09/27/RlHYhPSUJ5ICswG.png" alt="image-20220927134825845"></p><p>注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：</p><p><img src="https://s2.loli.net/2022/09/25/jhekq9ZKHoiT2yI.png" alt="image-20220925170746329"></p><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;?&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;Integer&gt;();<br>    test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;String&gt;();<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> test.value;    <span class="hljs-comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;A, B, C&gt; &#123;   <span class="hljs-comment">//多个类型变量使用逗号隔开</span><br>    <span class="hljs-keyword">public</span> A a;<br>    <span class="hljs-keyword">public</span> B b;<br>    <span class="hljs-keyword">public</span> C c;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么在使用时，就需要将这三种类型都进行明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;String, Integer, Character&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();  <span class="hljs-comment">//使用钻石运算符可以省略其中的类型</span><br>    test.a = <span class="hljs-string">&quot;lbwnb&quot;</span>;<br>    test.b = <span class="hljs-number">10</span>;<br>    test.c = <span class="hljs-string">&#x27;淦&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    <br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过，泛型只能确定为一个引用类型，基本类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">public</span> T value;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/26/TI6tWwj4vXFdenr.png" alt="image-20220926232135111"></p><p>如果要存放基本数据类型的值，我们只能使用对应的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;Integer&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;<span class="hljs-type">int</span>[]&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型也可以支持套娃使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;Test&lt;Test&lt;Integer&gt;&gt;&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();  <br><span class="hljs-comment">//你没看错，泛型的类型参数也可以是另一个泛型类型，套娃形式存在</span><br></code></pre></td></tr></table></figure><p>通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。</p><h3 id="泛型与多态"><a href="#泛型与多态" class="headerlink" title="泛型与多态"></a>泛型与多态</h3><p>不只是类，包括接口、抽象类，都是可以支持泛型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>&lt;Integer&gt; &#123;   <br>      <span class="hljs-comment">//在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是继续摆烂，依然使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        A&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>&lt;T&gt; &#123;   <br>      <span class="hljs-comment">//让子类继续为一个泛型类，那么可以不用明确</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继承也是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; &#123;<br>    <br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&lt;String&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>当然，类型参数并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。</p><p>当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> test(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>&#123;   <span class="hljs-comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span><br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    main.add(strings, <span class="hljs-string">&quot;Hello&quot;</span>);<br>    System.out.println(Arrays.toString(strings));<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T[] arr, T t)</span>&#123;<br>    arr[<span class="hljs-number">0</span>] = t;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;   <br>  <span class="hljs-comment">//通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;   <span class="hljs-comment">//这个方法会在执行排序时被调用（别人来调用我们的实现）</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>比如现在我们想要让数据从大到小排列，我们就可以自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>    Arrays.sort(arr, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;   <span class="hljs-comment">//两个需要比较的数会在这里给出</span><br>            <span class="hljs-keyword">return</span> o2 - o1;    <br>          <span class="hljs-comment">//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于</span><br>          <span class="hljs-comment">//这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于</span><br>        &#125;<br>    &#125;);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>&#125;;<br>    Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);   <span class="hljs-comment">//瞬间变一行，效果跟上面是一样的</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>包括数组复制方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = &#123;<span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span>, <span class="hljs-string">&quot;CCC&quot;</span>&#125;;<br>    String[] newArr = Arrays.copyOf(arr, <span class="hljs-number">3</span>);   <span class="hljs-comment">//这里传入的类型是什么，返回的类型就是什么，也是用到了泛型</span><br>    System.out.println(Arrays.toString(newArr));<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。</p><h3 id="泛型的界限"><a href="#泛型的界限" class="headerlink" title="泛型的界限"></a>泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; &#123;   <span class="hljs-comment">//设定类型参数上界，必须是Number或是Number的子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Score</span><span class="hljs-params">(String name, String id, T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：</p><p><img src="https://s2.loli.net/2022/09/27/BAgmdCkDFL62V8H.png" alt="image-20220927000902574"></p><p>实际上就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/rLnjHp73tdFSPUM.png" alt="img"></p><p>同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Integer</span>&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">60</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么既然泛型有上界，那么有没有下界呢？肯定的啊：</p><p><img src="https://s2.loli.net/2022/09/27/UJg7s41NC9Gn6fX.png" alt="image-20220927002611032"></p><p>只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/QFZNSCpnAmKG7qr.png" alt="4aa52791-73f4-448f-bab3-9133ea85d850.jpg"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">Number</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> score.getValue();   <span class="hljs-comment">//可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Score&lt;? <span class="hljs-built_in">super</span> Number&gt; score = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Score</span>&lt;&gt;(<span class="hljs-string">&quot;数据结构与算法基础&quot;</span>, <span class="hljs-string">&quot;EP074512&quot;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> score.getValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T&gt;&#123;<br>    <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(Object t)</span>;  <span class="hljs-comment">//默认就是Object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;&#123;   <span class="hljs-comment">//设定上界为Number</span><br>    <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">abstract</span> Number <span class="hljs-title function_">test</span><span class="hljs-params">(Number t)</span>;  <span class="hljs-comment">//上界Number，因为现在只可能出现Number的子类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();    <span class="hljs-comment">//对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过此时编译器会给出警告：</p><p><img src="https://s2.loli.net/2022/09/27/kVCIg3TilOuLFmj.png" alt="image-20220927131226728"></p><p>同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    A&lt;String&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">String</span>  <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a.test(<span class="hljs-string">&quot;10&quot;</span>);     <span class="hljs-comment">//因为类型A只有返回值为原始类型Object的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (String) a.test(<span class="hljs-string">&quot;10&quot;</span>);   <span class="hljs-comment">//依靠强制类型转换完成的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么<code>@Override</code>不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    String <span class="hljs-title function_">test</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看编译之后长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Compiled from &quot;B.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.test.entity.B <span class="hljs-keyword">extends</span> <span class="hljs-title class_">com</span>.test.entity.A&lt;java.lang.String&gt; &#123;<br>  <span class="hljs-keyword">public</span> com.test.entity.B();<br>  java.lang.String <span class="hljs-title function_">test</span><span class="hljs-params">(java.lang.String)</span>;<br>  java.lang.Object <span class="hljs-title function_">test</span><span class="hljs-params">(java.lang.Object)</span>;   <span class="hljs-comment">//桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">test</span><span class="hljs-params">(Object obj)</span> &#123;   <span class="hljs-comment">//这才是重写的桥接方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.test((Integer) obj);   <span class="hljs-comment">//桥接方法调用我们自己写的方法</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;   <span class="hljs-comment">//我们自己写的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：</p><p>首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：</p><p><img src="https://s2.loli.net/2022/09/27/q7DQ9lAweJLOFky.png" alt="image-20220927133232627"></p><p>只能判断是不是原始类型，里面的具体类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;String&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;();<br>System.out.println(test <span class="hljs-keyword">instanceof</span> Test);   <span class="hljs-comment">//在进行类型判断时，不允许使用泛型，只能使用原始类型</span><br></code></pre></td></tr></table></figure><p>还有，泛型类型是不支持创建参数化类型数组的：</p><p><img src="https://s2.loli.net/2022/09/27/7tK5APuSZovBLIc.png" alt="image-20220927133611288"></p><p>要用只能用原始类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test[] test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>[<span class="hljs-number">10</span>];   <span class="hljs-comment">//同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过只是把它当做泛型类型的数组还是可以用的：</p><p><img src="https://s2.loli.net/2022/09/27/upjWbyq9XC5FLDv.png" alt="image-20220927134335255"></p><h3 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h3><p><strong>注意：</strong> 本小节作为选学内容，不强制要求掌握。</p><p>我们在前面介绍了泛型的基本使用，实际上就是一个待定的类型，我们在使用时可以指定具体的类型，并在编译时检查类型是否匹配，保证运行时类型的安全性，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test&lt;Integer&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-number">10</span>);<br>&#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&lt;T&gt; &#123;<br>    T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦泛型变量类型确定，后续将一直固定使用此类型，并且当我们将其赋值给其他类型时，也会提示不兼容：</p><p><img src="https://s2.loli.net/2025/07/18/CTqAP1NBKRrO9FV.png" alt="image-20250718201919135"></p><p>但是现在存在这样一个问题，我们如果使用某个类型的父类呢，会不会出现类型不匹配的情况？</p><p><img src="https://s2.loli.net/2025/07/18/N8O5PuXVoKrxdEl.png" alt="image-20250718201644710"></p><p>可以看到，即使是Integer类型的父类Number，也无法接收其子类类型的结果，这就很奇怪了，我们前面说过一个类可以被当做其父类使用（因为父类具有属性什么子类一定也有）会自动完成隐式类型转换，但是为什么到了泛型这里就不行了呢？</p><p>为了探究这个问题，我们先从几个概念开始说起，现在假设Integer类型是Number类型的子类，正常情况下只能子类转换为父类，泛型类型<code>Test&lt;T&gt;</code>存在以下几种形变：</p><ul><li>协变 (Covariance)：因为Integer是Number的子类，所以<code>Test&lt;Integer&gt;</code>同样是<code>Test&lt;Number&gt;</code>的子类，可以直接转换</li><li>逆变(Contravariance)：跟上面相反，<code>Test&lt;Number&gt;</code>可以直接转换为<code>Test&lt;Integer&gt;</code>，前者是后者的子类</li><li>抗变 (Invariant)：<code>Test&lt;Integer&gt;</code>跟<code>Test&lt;Number&gt;</code>没半毛钱关系，无法互相转换</li></ul><p>而Java的泛型，默认就是抗变的，即使两个类型存在父子关系，到编译器这里也不认账。而我们前面认识的数组，它的性质就是协变的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123; <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span> &#125;;<br>Object[] objects = strings;   <span class="hljs-comment">//正常编译通过</span><br></code></pre></td></tr></table></figure><p>因为Integer是Number的子类，因此，数组的<code>Integer[]</code>同样也是<code>Object[]</code>的子类。</p><p>那为什么泛型要设计成抗变性质的呢？这其实是为了类型安全，我们可以通过协变的数组来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] strings = &#123; <span class="hljs-string">&quot;AAA&quot;</span>, <span class="hljs-string">&quot;BBB&quot;</span> &#125;;<br>    Object[] objects = strings;   <span class="hljs-comment">//通过其父类数组接收对于String[]的引用</span><br>    objects[<span class="hljs-number">1</span>] = <span class="hljs-number">666</span>;   <span class="hljs-comment">//此时由于类型是Object[]，那么任何Object的子类对象都可以塞</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会出现问题了，我们这里原本的对象是一个String类型的数组，但是现在我们却在往里面存一个Integer类型的数据，并且程序没有出现任何的编译错误，这就出现BUG了，我们居然可以存入一个不符合数组类型的元素。</p><p>因此，在程序实际运行时，会直接抛出ArrayStoreException异常：</p><p><img src="https://s2.loli.net/2025/07/18/OdkbRhi1aTs2gux.png" alt="image-20250718203104428"></p><p>实际上这就是协变带来的缺点，它可能会导致我们使用一个错误的类型进行存取。因此现在很多其他的编程语言都会设计泛型，但是很少会有支持协变的泛型，几乎都是抗变。</p><p>除此之外，在我们使用通配符时，也会存在逆变和协变，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-number">10</span>);  <span class="hljs-comment">//接收到一个Test&lt;Integer&gt;类型的对象</span><br></code></pre></td></tr></table></figure><p>我们可以将<code>?</code>添加<code>extends</code>来限制其上界，我们前面说过它将可以同时匹配所有继承自Number的类型（包括其自身）也就是我们这里谈到的协变性质，但是这样是存在风险的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-number">10</span>);  <span class="hljs-comment">//Test&lt;Integer&gt;</span><br>test.value = <span class="hljs-number">1.5</span>;   <span class="hljs-comment">//此时由于类型为Number，那么所有子类都可以，我们可以直接给一个Double</span><br></code></pre></td></tr></table></figure><p>如果这段代码可以正常执行，那么这将导致我们为一个Integer类型的变量，赋值了一个Double类型的结果，这显然是错误的。因此，我们实际上会发现，这里会限制我们对于协变的泛型属性赋值，当然，只是获取则不会受到影响。</p><p>同样的，如果我们使用<code>super</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;? <span class="hljs-built_in">super</span> Number&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>那么此时它会具有逆变性质，只要是任何其父类都可以直接转换为<code>? super Number</code>，只不过由于Java中所有类型都是Object的子类，所以这里直接给一个<code>Integer</code>类型的value也不会出现错误，但是这并不影响它的逆变性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Test&lt;? <span class="hljs-built_in">super</span> Number&gt; test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> test.value;   <span class="hljs-comment">//这里只能使用Object来接收其结果</span><br></code></pre></td></tr></table></figure><p>由于此时限制的是上界，这里给到value的对象有可能是Number类型但是也有可能Object类型的，因此我们只能拿到一个Object类型的结果。因此，针对于以上三种类型，虽然协变和逆变允许更灵活地进行使用，但是同时也存在一定代价：</p><ul><li><strong>协变：</strong> 不允许修改或添加任何元素（除了<code>null</code>），读取可以正常得到T或其子类型（主要用于读取数据）</li><li><strong>逆变：</strong> 允许修改或添加T及其子类，但是读取被限制为只能读取Object类型的结果（主要用于写入数据）</li><li><strong>抗变：</strong> 修改和读取均不受限制（读写通用）</li></ul><p>实际上到了后面的集合类中，如果类型为协变或是抗变，某些操作同样会受到限制。</p><h3 id="Java-8-函数式接口"><a href="#Java-8-函数式接口" class="headerlink" title="(Java 8) 函数式接口"></a>(Java 8) 函数式接口</h3><p>学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。</p><p>函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：</p><p><strong>Supplier供给型函数式接口：</strong> 这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>   <span class="hljs-comment">//函数式接口都会打上这样一个注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//实现此方法，实现供给功能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们要实现一个专门供给Student对象Supplier，就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//专门供给Student对象的Supplier</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::<span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> STUDENT_SUPPLIER.get();<br>    student.hello();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Consumer消费型函数式接口：</strong> 这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;    <span class="hljs-comment">//这个方法就是用于消费的，没有返回值</span><br><br>    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;   <span class="hljs-comment">//这个方法便于我们连续使用此消费接口</span><br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用起来也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//专门消费Student对象的Consumer</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+<span class="hljs-string">&quot; 真好吃！&quot;</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    STUDENT_CONSUMER.accept(student);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们也可以使用<code>andThen</code>方法继续调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    STUDENT_CONSUMER   <span class="hljs-comment">//我们可以提前将消费之后的操作以同样的方式预定好</span><br>            .andThen(stu -&gt; System.out.println(<span class="hljs-string">&quot;我是吃完之后的操作！&quot;</span>)) <br>            .andThen(stu -&gt; System.out.println(<span class="hljs-string">&quot;好了好了，吃饱了！&quot;</span>))<br>            .accept(student);   <span class="hljs-comment">//预定好之后，再执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：</p><p><img src="https://s2.loli.net/2022/09/27/Pu1jGzKNSvnV9YZ.png" alt="image-20220927181706365"></p><p><strong>Function函数型函数式接口：</strong> 这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt; &#123;<br>    R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;   <span class="hljs-comment">//这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型</span><br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="hljs-title function_">compose</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> V, ? extends T&gt; before)</span> &#123;<br>        Objects.requireNonNull(before);<br>        <span class="hljs-keyword">return</span> (V v) -&gt; apply(before.apply(v));<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> R, ? extends V&gt; after)</span> &#123;<br>        Objects.requireNonNull(after);<br>        <span class="hljs-keyword">return</span> (T t) -&gt; after.apply(apply(t));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="hljs-title function_">identity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> t -&gt; t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口方法有点多，我们一个一个来看，首先还是最基本的<code>apply</code>方法，这个是我们需要实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION.apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>compose</code>将指定函数式的结果作为当前函数式的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION<br>            .compose((String s) -&gt; s.length())   <span class="hljs-comment">//将此函数式的返回值作为当前实现的实参</span><br>            .apply(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//传入上面函数式需要的参数</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>相反的，<code>andThen</code>可以将当前实现的返回值进行进一步的处理，得到其他类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> INTEGER_STRING_FUNCTION<br>            .andThen(String::isEmpty)   <span class="hljs-comment">//在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了</span><br>            .apply(<span class="hljs-number">10</span>);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Function&lt;String, String&gt; function = Function.identity();   <span class="hljs-comment">//原样返回</span><br>    System.out.println(function.apply(<span class="hljs-string">&quot;不会吧不会吧，不会有人听到现在还是懵逼的吧&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Predicate断言型函数式接口：</strong> 接收一个参数，然后进行自定义判断并返回一个boolean结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;    <span class="hljs-comment">//这个方法就是我们要实现的</span><br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;<br>        Objects.requireNonNull(other);<br>        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)<br>                ? Objects::isNull<br>                : object -&gt; targetRef.equals(object);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以来编写一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> score;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= <span class="hljs-number">60</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-keyword">if</span>(STUDENT_PREDICATE.test(student)) &#123;  <span class="hljs-comment">//test方法的返回值是一个boolean结果</span><br>        System.out.println(<span class="hljs-string">&quot;及格了，真不错，今晚奖励自己一次&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;不是，Java都考不及格？隔壁初中生都在打ACM了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用组合条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.score = <span class="hljs-number">80</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> STUDENT_PREDICATE<br>            .and(stu -&gt; stu.score &gt; <span class="hljs-number">90</span>)   <span class="hljs-comment">//需要同时满足这里的条件，才能返回true</span><br>            .test(student);<br>    <span class="hljs-keyword">if</span>(!b) System.out.println(<span class="hljs-string">&quot;Java到现在都没考到90分？你的室友都拿国家奖学金了&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Predicate&lt;String&gt; predicate = Predicate.isEqual(<span class="hljs-string">&quot;Hello World&quot;</span>);   <span class="hljs-comment">//这里传入的对象会和之后的进行比较</span><br>    System.out.println(predicate.test(<span class="hljs-string">&quot;Hello World&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。</p><h3 id="Java-8-判空包装"><a href="#Java-8-判空包装" class="headerlink" title="(Java 8) 判空包装"></a>(Java 8) 判空包装</h3><p>Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。</p><p>比如对于下面这样一个很简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;   <span class="hljs-comment">//传入字符串，如果不是空串，那么就打印长度</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们在传入参数时，丢个null进去，直接原地爆炸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123; <br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;   <span class="hljs-comment">//此时传入的值为null，调用方法马上得到空指针异常</span><br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此我们还需要在使用之前进行判空操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-keyword">if</span>(str == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;   <span class="hljs-comment">//这样就可以防止null导致的异常了</span><br>    <span class="hljs-keyword">if</span>(!str.isEmpty()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+str.length());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    Optional<br>            .ofNullable(str)   <span class="hljs-comment">//将传入的对象包装进Optional中</span><br>            .ifPresent(s -&gt; System.out.println(<span class="hljs-string">&quot;字符串长度为：&quot;</span>+s.length()));  <br>  <span class="hljs-comment">//如果不为空，则执行这里的Consumer实现</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str : String? = <span class="hljs-literal">null</span><br>str?.upperCase()<br></code></pre></td></tr></table></figure><p>并且，包装之后，我们再获取时可以优雅地处理为空的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Optional.ofNullable(str).get();   <span class="hljs-comment">//get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</span><br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Optional.ofNullable(str).orElse(<span class="hljs-string">&quot;我是为null的情况备选方案&quot;</span>);<br>    System.out.println(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，这跟隔壁Kotlin和JS的语法如出一辙：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = a ?? <span class="hljs-string">&quot;替代值&quot;</span><br></code></pre></td></tr></table></figure><p>是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span>&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Optional<br>            .ofNullable(str)<br>            .map(String::length)   <span class="hljs-comment">//使用map来进行映射，将当前类型转换为其他类型，或者是进行处理</span><br>            .orElse(-<span class="hljs-number">1</span>);<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Optional的方法比较多，这里就不一一介绍了。</p><h3 id="Java-9-10-判空包装增强"><a href="#Java-9-10-判空包装增强" class="headerlink" title="(Java 9&#x2F;10) 判空包装增强"></a>(Java 9&#x2F;10) 判空包装增强</h3><p>在Java 9中，官方为Optional带来了一些额外的操作，让其使用起来更加方便，首先是<code>ifPresentOrElse</code>，我们可以直接将如果存在和不存在的两种情况都进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional.ofNullable(str).ifPresentOrElse(s -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;存在: &quot;</span> + s);<br>&#125;, () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;不存在&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>还有快速对Optional进行空值替换的操作<code>or</code>，这个跟<code>orElse</code>稍微有些区别，它返回的是一个Optional对象，依然处于包装状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; op = Optional.ofNullable(str).or(() -&gt; Optional.of(<span class="hljs-string">&quot;替代值&quot;</span>));<br></code></pre></td></tr></table></figure><p>同时还包含我们后面要学习的Stream一键转换方法<code>stream()</code>，它可以直接生成只包含一个值（就是Optional包裹的）的Stream对象，各位小伙伴可以等到后面学习StreamAPI之后再进行回顾，这里不展开介绍了。</p><p>Java 10 还针对之前的<code>orElseThrow</code>方法进行简化，推出了一个无参版本的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional.ofNullable(str).orElseThrow();<br></code></pre></td></tr></table></figure><hr><h2 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h2><p><strong>注意：</strong> 本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。</p><p>学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。</p><blockquote><p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p></blockquote><p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p><p><img src="https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li><strong>获取指定位置上的元素：</strong> 直接获取线性表指定位置<code>i</code>上的元素。</li><li><strong>插入元素：</strong> 在指定位置<code>i</code>上插入一个元素。</li><li><strong>删除元素：</strong> 删除指定位置<code>i</code>上的一个元素。</li><li><strong>获取长度：</strong> 返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://s2.loli.net/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="线性表：顺序表"><a href="#线性表：顺序表" class="headerlink" title="线性表：顺序表"></a>线性表：顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://s2.loli.net/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; &#123;   <span class="hljs-comment">//泛型E，因为表中要存的具体数据类型待定</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;   <span class="hljs-comment">//当前顺序表的容量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//当前已经存放的元素数量</span><br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];   <span class="hljs-comment">//底层存放数据的数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>顺序表的插入和删除操作，其实就是：</p><p><img src="https://s2.loli.net/2022/09/27/24Glc7UQjLt5Wny.jpg" alt="67813f22-3607-4351-934d-f8127e6ba15a"></p><p>当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。</p><p>所以说我们可以来尝试实现一下，首先是插入方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element, <span class="hljs-type">int</span> index)</span>&#123;   <span class="hljs-comment">//插入方法需要支持在指定下标位置插入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &gt; index; i--)   <span class="hljs-comment">//从后往前，一个一个搬运元素</span><br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;   <span class="hljs-comment">//腾出位置之后，直接插入元素放到对应位置上</span><br>    size++;   <span class="hljs-comment">//插入完成之后，记得将size自增</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内</p><p><img src="https://s2.loli.net/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>所以说我们需要在插入之前进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)    <span class="hljs-comment">//插入之前先判断插入位置是否合法</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &gt; index; i--)<br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);    <span class="hljs-comment">//一上来只能在第一个位置插入，第二个位置肯定是非法的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>于是就成功得到异常：</p><p><img src="https://s2.loli.net/2022/09/27/rtkRMaWseE2Cm1z.png" alt="image-20220927211134905"></p><p>只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);<br>    <span class="hljs-keyword">if</span>(capacity == size) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> capacity + (capacity &gt;&gt; <span class="hljs-number">1</span>);   <span class="hljs-comment">//扩容规则就按照原本容量的1.5倍来吧</span><br>        Object[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapacity];    <span class="hljs-comment">//创建一个新的数组来存放更多的元素</span><br>        System.arraycopy(array, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, size);   <span class="hljs-comment">//使用arraycopy快速拷贝原数组内容到新的数组</span><br>        array = newArray;   <span class="hljs-comment">//更换为新的数组</span><br>      capacity = newCapacity;   <span class="hljs-comment">//容量变成扩容之后的</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &gt; index; i--)<br>        array[i] = array[i - <span class="hljs-number">1</span>];<br>    array[index] = element;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来重写一下<code>toString</code>方法打印当前存放的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) builder.append(array[i]).append(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们的底层数组会自动扩容，便于我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>        list.add(i, i);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/6SMZxC5QI3cgXYk.png" alt="image-20220927212426959"></p><p>我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>   <span class="hljs-comment">//屏蔽未经检查警告</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;   <span class="hljs-comment">//删除对应位置上的元素，注意需要返回被删除的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[index];   <span class="hljs-comment">//因为存放的是Object类型，这里需要强制类型转换为E</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; size; i++)   <span class="hljs-comment">//从前往后，挨个往前搬一位</span><br>        array[i] = array[i + <span class="hljs-number">1</span>];<br>    size--;    <span class="hljs-comment">//删完记得将size--</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们需要对删除的合法范围进行判断：</p><p><img src="https://s2.loli.net/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>所以说我们也来进行一下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;删除位置非法，合法的插入位置为：0 ~ &quot;</span>+(size - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) array[index];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; size; i++)<br>        array[i] = array[i + <span class="hljs-number">1</span>];<br>    size--;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。</p><p>当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)   <span class="hljs-comment">//在插入之前同样要进行范围检查</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">return</span> (E) array[index];   <span class="hljs-comment">//直接返回就完事</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//获取当前存放的元素数量</span><br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。</p><h3 id="线性表：链表"><a href="#线性表：链表" class="headerlink" title="线性表：链表"></a>线性表：链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://s2.loli.net/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>我们来尝试定义一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; &#123;<br>  <span class="hljs-comment">//链表的头结点，用于连接之后的所有结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//当前的元素数量还是要存一下，方便后面操作</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;  <span class="hljs-comment">//结点类，仅供内部使用</span><br>        E element;   <span class="hljs-comment">//每个结点都存放元素</span><br>        Node&lt;E&gt; next;   <span class="hljs-comment">//以及指向下一个结点的引用</span><br>      <br>      <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E element)</span> &#123;<br>            <span class="hljs-built_in">this</span>.element = element;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://s2.loli.net/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://s2.loli.net/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://s2.loli.net/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://s2.loli.net/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element, <span class="hljs-type">int</span> index)</span>&#123;<br>    Node&lt;E&gt; prev = head;   <span class="hljs-comment">//先找到对应位置的前驱结点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) <br>        prev = prev.next;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);   <span class="hljs-comment">//创建新的结点</span><br>    node.next = prev.next;   <span class="hljs-comment">//先让新的节点指向原本在这个位置上的结点</span><br>    prev.next = node;   <span class="hljs-comment">//然后让前驱结点指向当前结点</span><br>    size++;   <span class="hljs-comment">//完事之后一样的，更新size</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来重写一下toString方法看看能否正常插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    Node&lt;E&gt; node = head.next;   <span class="hljs-comment">//从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去</span><br>    <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>        builder.append(node.element).append(<span class="hljs-string">&quot; &quot;</span>);<br>        node = node.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> builder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到我们的插入操作是可以正常工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>    list.add(<span class="hljs-number">30</span>, <span class="hljs-number">0</span>);<br>    list.add(<span class="hljs-number">20</span>, <span class="hljs-number">1</span>);<br>    System.out.println(list);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/Mpj9azwWciemAZY.png" alt="image-20220927235051844"></p><p>只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E element, <span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);<br>    Node&lt;E&gt; prev = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>        prev = prev.next;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>    node.next = prev.next;<br>    prev.next = node;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://s2.loli.net/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://s2.loli.net/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://s2.loli.net/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)   <span class="hljs-comment">//同样的，先判断位置是否合法</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;删除位置非法，合法的删除位置为：0 ~ &quot;</span>+(size - <span class="hljs-number">1</span>));<br>    Node&lt;E&gt; prev = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)   <span class="hljs-comment">//同样需要先找到前驱结点</span><br>        prev = prev.next;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> prev.next.element;   <span class="hljs-comment">//先把待删除结点存放的元素取出来</span><br>    prev.next = prev.next.next;  <span class="hljs-comment">//可以删了</span><br>    size--;   <span class="hljs-comment">//记得size--</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。</p><p>我们接着来实现一下获取对应位置上的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="hljs-number">1</span>));<br>    Node&lt;E&gt; node = head;<br>    <span class="hljs-keyword">while</span> (index-- &gt;= <span class="hljs-number">0</span>)   <span class="hljs-comment">//这里直接让index减到-1为止</span><br>        node = node.next;<br>    <span class="hljs-keyword">return</span> node.element;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。</p><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p>虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://s2.loli.net/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><h3 id="线性表：栈"><a href="#线性表：栈" class="headerlink" title="线性表：栈"></a>线性表：栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://s2.loli.net/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://s2.loli.net/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://s2.loli.net/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedStack</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);   <span class="hljs-comment">//大体内容跟链表类似</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E element)</span> &#123;<br>            <span class="hljs-built_in">this</span>.element = element;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://s2.loli.net/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E element)</span>&#123;<br>    Node&lt;E&gt; node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);   <span class="hljs-comment">//直接创建新结点</span><br>    node.next = head.next;    <span class="hljs-comment">//新结点的下一个变成原本的栈顶结点</span><br>    head.next = node;     <span class="hljs-comment">//头结点的下一个改成新的结点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//如果栈已经没有元素了，那么肯定是没办法取的</span><br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">&quot;栈为空&quot;</span>);<br>    <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> head.next.element;   <span class="hljs-comment">//先把待出栈元素取出来</span><br>    head.next = head.next.next;   <span class="hljs-comment">//直接让头结点的下一个指向下一个的下一个</span><br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    LinkedStack&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedStack</span>&lt;&gt;();<br>    stack.push(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    stack.push(<span class="hljs-string">&quot;CCC&quot;</span>);<br>    System.out.println(stack.pop());<br>    System.out.println(stack.pop());<br>    System.out.println(stack.pop());<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，入栈顺序和出栈顺序是完全相反的：</p><p><img src="https://s2.loli.net/2022/09/28/yaWmfPDU63X8BQn.png" alt="image-20220928101152179"></p><p>其实还是挺简单的。</p><h3 id="线性表：队列"><a href="#线性表：队列" class="headerlink" title="线性表：队列"></a>线性表：队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://s2.loli.net/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://s2.loli.net/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://s2.loli.net/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E element)</span>&#123;  <span class="hljs-comment">//入队操作</span><br>        Node&lt;E&gt; last = head;<br>        <span class="hljs-keyword">while</span> (last.next != <span class="hljs-literal">null</span>)   <span class="hljs-comment">//入队直接丢到最后一个结点的屁股后面就行了</span><br>            last = last.next;<br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//出队操作</span><br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>)   <span class="hljs-comment">//如果队列已经没有元素了，那么肯定是没办法取的</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> head.next.element;<br>        head.next = head.next.next;   <span class="hljs-comment">//直接从队首取出</span><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E element)</span> &#123;<br>            <span class="hljs-built_in">this</span>.element = element;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实使用起来还是挺简单的，我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    LinkedQueue&lt;String&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedQueue</span>&lt;&gt;();<br>    stack.offer(<span class="hljs-string">&quot;AAA&quot;</span>);<br>    stack.offer(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    stack.offer(<span class="hljs-string">&quot;CCC&quot;</span>);<br>    System.out.println(stack.poll());<br>    System.out.println(stack.poll());<br>    System.out.println(stack.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/28/FUS1Rc8JuEMT6bq.png" alt="image-20220928154121872"></p><p>可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。</p><h3 id="树：二叉树"><a href="#树：二叉树" class="headerlink" title="树：二叉树"></a>树：二叉树</h3><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://s2.loli.net/2022/08/08/NajFZzXHxUCDQBW.png" alt="树枝666"></p><p>在我们的程序中，想要表示出一棵树，就可以像下面这样连接：</p><p><img src="https://s2.loli.net/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><p>而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://s2.loli.net/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><p>我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用：</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了：</p><p><img src="https://s2.loli.net/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">public</span> E element;<br>    <span class="hljs-keyword">public</span> TreeNode&lt;E&gt; left, right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeNode</span><span class="hljs-params">(E element)</span>&#123;<br>        <span class="hljs-built_in">this</span>.element = element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeNode&lt;Character&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    TreeNode&lt;Character&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    TreeNode&lt;Character&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;C&#x27;</span>);<br>    TreeNode&lt;Character&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;D&#x27;</span>);<br>    TreeNode&lt;Character&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;E&#x27;</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ...<br>    a.left = b;<br>    a.right = c;<br>    b.left = d;<br>    b.right = e;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(a.left.left.element);<br></code></pre></td></tr></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://s2.loli.net/2022/09/30/XCkDxVBFz2bWph8.png" alt="image-20220930160452608"></p><p>这样，我们就通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：<strong>前序遍历、中序遍历、后序遍历、层序遍历。</strong>不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://s2.loli.net/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    TreeNode&lt;Character&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    TreeNode&lt;Character&gt; b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    TreeNode&lt;Character&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;C&#x27;</span>);<br>    TreeNode&lt;Character&gt; d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;D&#x27;</span>);<br>    TreeNode&lt;Character&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;E&#x27;</span>);<br>    TreeNode&lt;Character&gt; f = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>&lt;&gt;(<span class="hljs-string">&#x27;F&#x27;</span>);<br>    a.left = b;<br>    a.right = c;<br>    b.left = d;<br>    b.right = e;<br>    c.right = f;<br>&#125;<br></code></pre></td></tr></table></figure><p>组装好之后，我们来实现一下前序遍历的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    System.out.print(root.element + <span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">//首先肯定要打印，这个是必须的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    System.out.print(root.element + <span class="hljs-string">&quot; &quot;</span>);<br>    preOrder(root.left);    <span class="hljs-comment">//先走左边</span><br>    preOrder(root.right);   <span class="hljs-comment">//再走右边</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    System.out.print(root.element);<br>    preOrder(root.left);<br>    preOrder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ...<br>    preOrder(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果为：</p><p><img src="https://s2.loli.net/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://s2.loli.net/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    inOrder(root.left);    <span class="hljs-comment">//先完成全部左子树的遍历</span><br>    System.out.print(root.element);    <span class="hljs-comment">//等待左子树遍历完成之后再打印</span><br>    inOrder(root.right);    <span class="hljs-comment">//然后就是对右子树进行遍历</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://s2.loli.net/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://s2.loli.net/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    postOrder(root.left);<br>    postOrder(root.right);<br>    System.out.print(root.element);  <span class="hljs-comment">//时机延迟到最后</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://s2.loli.net/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://s2.loli.net/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://s2.loli.net/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedQueue</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt; head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E element)</span>&#123;<br>        Node&lt;E&gt; last = head;<br>        <span class="hljs-keyword">while</span> (last.next != <span class="hljs-literal">null</span>)<br>            last = last.next;<br>        last.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(<span class="hljs-string">&quot;队列为空&quot;</span>);<br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> head.next.element;<br>        head.next = head.next.next;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;   <span class="hljs-comment">//这里多写了一个判断队列为空的操作，方便之后使用</span><br>        <span class="hljs-keyword">return</span> head.next == <span class="hljs-literal">null</span>;   <span class="hljs-comment">//直接看头结点后面还有没有东西就行了</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E element;<br>        Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E element)</span> &#123;<br>            <span class="hljs-built_in">this</span>.element = element;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来尝试编写一下层序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode&lt;T&gt; root)</span>&#123;<br>    LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedQueue</span>&lt;&gt;();  <span class="hljs-comment">//创建一个队列</span><br>    queue.offer(root);    <span class="hljs-comment">//将根结点丢进队列</span><br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;   <span class="hljs-comment">//如果队列不为空，就一直不断地取出来</span><br>        TreeNode&lt;T&gt; node = queue.poll();   <span class="hljs-comment">//取一个出来</span><br>        System.out.print(node.element);  <span class="hljs-comment">//打印</span><br>        <span class="hljs-keyword">if</span>(node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);   <span class="hljs-comment">//如果左右孩子不为空，直接将左右孩子丢进队列</span><br>        <span class="hljs-keyword">if</span>(node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://s2.loli.net/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><h3 id="树：二叉查找树和平衡二叉树"><a href="#树：二叉查找树和平衡二叉树" class="headerlink" title="树：二叉查找树和平衡二叉树"></a>树：二叉查找树和平衡二叉树</h3><p><strong>注意：</strong> 本部分只进行理论介绍，不做代码实现。</p><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://s2.loli.net/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">20 </span><span class="hljs-number">15</span> <span class="hljs-number">13</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://s2.loli.net/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://s2.loli.net/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://s2.loli.net/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://s2.loli.net/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://s2.loli.net/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://s2.loli.net/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://s2.loli.net/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://s2.loli.net/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://s2.loli.net/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://s2.loli.net/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://s2.loli.net/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://s2.loli.net/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://s2.loli.net/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://s2.loli.net/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。</p><h3 id="树：红黑树"><a href="#树：红黑树" class="headerlink" title="树：红黑树"></a>树：红黑树</h3><p><strong>注意：</strong> 本部分只进行理论介绍，不做代码实现。</p><p>很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://s2.loli.net/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://s2.loli.net/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://s2.loli.net/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://s2.loli.net/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://s2.loli.net/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://s2.loli.net/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://s2.loli.net/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://s2.loli.net/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://s2.loli.net/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://s2.loli.net/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://s2.loli.net/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://s2.loli.net/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://s2.loli.net/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf</span> *ideaIU-<span class="hljs-number">2022</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.dmg<br></code></pre></td></tr></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://s2.loli.net/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://s2.loli.net/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://s2.loli.net/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://s2.loli.net/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://s2.loli.net/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TABLE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[TABLE_SIZE];<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(E element)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash(element);<br>        TABLE[index] = element;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(E element)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash(element);<br>        <span class="hljs-keyword">return</span> TABLE[index] == element;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object object)</span>&#123;   <span class="hljs-comment">//哈希函数，计算出存放的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> object.hashCode();  <br>      <span class="hljs-comment">//每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况）</span><br>        <span class="hljs-keyword">return</span> hashCode % TABLE_SIZE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://s2.loli.net/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。</p><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p><img src="https://s2.loli.net/2022/09/30/Hd1LDvkY6ScVTN2.png" alt="image-20220820220237535"></p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashTable</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TABLE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;E&gt;[] TABLE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[TABLE_SIZE];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashTable</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TABLE_SIZE; i++)<br>            TABLE[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(E element)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash(element);<br>        Node&lt;E&gt; prev = TABLE[index];<br>        <span class="hljs-keyword">while</span> (prev.next != <span class="hljs-literal">null</span>)<br>            prev = prev.next;<br>        prev.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(element);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(E element)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> hash(element);<br>        Node&lt;E&gt; node = TABLE[index].next;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node.element == element)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            node = node.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object object)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> object.hashCode();<br>        <span class="hljs-keyword">return</span> hashCode % TABLE_SIZE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E element;<br>        <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(E element)</span>&#123;<br>            <span class="hljs-built_in">this</span>.element = element;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p>至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>合理利用集合类，我们可以巧妙地解决各种各样的难题。</p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><h3 id="括号匹配问题"><a href="#括号匹配问题" class="headerlink" title="括号匹配问题"></a>括号匹配问题</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s &#x3D; “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s &#x3D; “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong> </p><blockquote><p>输入：s &#x3D; “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong> </p><blockquote><p>输入：s &#x3D; “{[]}”<br>输出：true</p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><h3 id="实现计算器"><a href="#实现计算器" class="headerlink" title="实现计算器"></a>实现计算器</h3><p>输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3&#x2F;1.321，得到结果为：2.2</p><p>现在请你设计一个Java程序，实现计算器。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/hnkrjrkm3hjzeq6s?segment=1#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">https://www.itbaima.cn/zh-CN/document/hnkrjrkm3hjzeq6s?segment=1#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3</a></p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/6r4llai92yc15j98">https://www.itbaima.cn/zh-CN/document/6r4llai92yc15j98</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（四）面向对象高级篇</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/22/lmKBNFc5wPEgjaS.png" alt="image-20220922170926093"></p><h1 id="面向对象高级篇"><a href="#面向对象高级篇" class="headerlink" title="面向对象高级篇"></a>面向对象高级篇</h1><p>经过前面的学习，我们已经了解了面向对象编程的大部分基础内容，这一部分，我们将继续探索面向对象编程过程中一些常用的东西。</p><h2 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><h3 id="包装类介绍"><a href="#包装类介绍" class="headerlink" title="包装类介绍"></a>包装类介绍</h3><p>所有的包装类层次结构如下：</p><p><img src="https://s2.loli.net/2022/09/22/mulb5VdvBLiWNe2.png" alt="5c3a6a27-6370-4c60-9bbc-8039e11e752d"></p><p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p><ul><li>byte  -&gt;  Byte</li><li>boolean  -&gt;  Boolean</li><li>short  -&gt;  Short</li><li>char  -&gt;  Character</li><li>int -&gt; Integer</li><li>long -&gt;  Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>我们可以直接使用，这里我们以Integer类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);    <span class="hljs-comment">//将10包装为一个Integer类型的变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;  <span class="hljs-comment">//类中实际上就靠这个变量在存储包装的值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Integer</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">//将int类型值作为包装类型使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">10</span>);    <span class="hljs-comment">//上面的写法跟这里是等价的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上上面的写法本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i.intValue();   <span class="hljs-comment">//通过此方法变成基本类型int值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a * b;    <span class="hljs-comment">//直接自动拆箱成基本类型参与到计算中</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br><br>    System.out.println(a == b);    <span class="hljs-comment">//虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么自动装箱的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">10</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="hljs-comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span><br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>IntegerCache会默认缓存-128<del>127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128</del>127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>, b = <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。</p><p>我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-string">&quot;666&quot;</span>);   <span class="hljs-comment">//直接将字符串的666，转换为数字666</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，字符串转Integer有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-string">&quot;5555&quot;</span>);<br>    <span class="hljs-comment">//Integer i = Integer.parseInt(&quot;5555&quot;);</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.decode(<span class="hljs-string">&quot;0xA6&quot;</span>);<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以将十进制的整数转换为其他进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Integer.toHexString(<span class="hljs-number">166</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，Integer中提供的方法还有很多，这里就不一一列出了。</p><h3 id="特殊包装类"><a href="#特殊包装类" class="headerlink" title="特殊包装类"></a>特殊包装类</h3><p>除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。</p><p>其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="hljs-comment">//表示Long的最大值，轻轻松松</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过调用类中的方法，进行运算操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);<br>    i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE));   <span class="hljs-comment">//即使是long的最大值乘以long的最大值，也能给你算出来</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/22/FTPGhgnAEm1QKkV.png" alt="image-20220922211414392"></p><p>可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);<br>    i = i.pow(<span class="hljs-number">100</span>);   <span class="hljs-comment">//long的最大值来个100次方吧</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这个数字已经大到一排显示不下了：</p><p><img src="https://s2.loli.net/2022/09/22/w1OoFmbLiJ4rlcV.png" alt="image-20220922211651719"></p><p>一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。</p><p>我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigDecimal.valueOf(<span class="hljs-number">10</span>);<br>    i = i.divide(BigDecimal.valueOf(<span class="hljs-number">3</span>), <span class="hljs-number">100</span>, RoundingMode.CEILING);<br>  <span class="hljs-comment">//计算10/3的结果，精确到小数点后100位</span><br>  <span class="hljs-comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span><br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，确实可以精确到这种程度：</p><p><img src="https://s2.loli.net/2022/09/22/IUJ5rwzxonCBMT4.png" alt="image-20220922212222762"></p><p>但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>我们接着来看一个比较特殊的类型，数组。</p><p>假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。</p><p><img src="https://s2.loli.net/2022/09/22/y4ISWZLrYE3Pdig.png" alt="image-20220922214604430"></p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array;   <span class="hljs-comment">//类型[]就表示这个是一个数组类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用<code>new </code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];   <span class="hljs-comment">//在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值</span><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> array;   <span class="hljs-comment">//因为同样是类，肯定是继承自Object的，所以说可以直接向上转型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了上面这种方式之外，我们也可以使用其他方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[数组大小];<br>类型 变量名称[] = <span class="hljs-keyword">new</span> 类型[数组大小];  <span class="hljs-comment">//支持C语言样式，但不推荐！</span><br><br>类型[] 变量名称 = <span class="hljs-keyword">new</span> 类型[]&#123;...&#125;;  <span class="hljs-comment">//静态初始化（直接指定值和大小）</span><br>类型[] 变量名称 = &#123;...&#125;;   <span class="hljs-comment">//同上，但是只能在定义时赋值</span><br></code></pre></td></tr></table></figure><p>创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="hljs-number">0</span>]);  <span class="hljs-comment">//使用 变量名[下标] 的方式访问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。</p><p>我们也可以使用这种方式为数组的元素赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    array[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;   <span class="hljs-comment">//就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值</span><br>    System.out.println(<span class="hljs-string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="hljs-number">0</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(<span class="hljs-string">&quot;当前数组长度为：&quot;</span>+array.length);   <span class="hljs-comment">//length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这个<code>length</code>是在一开始就确定的，而且是<code>final</code>类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。</p><p>当然，既然是类型，那么肯定也是继承自Object类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.out.println(array.toString());<br>    System.out.println(array.equals(array));<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：</p><p><img src="https://s2.loli.net/2022/09/22/UfTGu9sZheW21jB.png" alt="image-20220922220403391"></p><p>所以说通过<code>toString()</code>打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是<code>[</code>开头的。</p><p>因此，如果我们要打印整个数组中所有的元素，得一个一个访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候为了方便，我们可以使用简化版的for语句<code>foreach</code>语法来遍历数组中的每一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : array) &#123;    <span class="hljs-comment">//int i就是每一个数组中的元素，array就是我们要遍历的数组</span><br>        System.out.print(i+<span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">//每一轮循环，i都会更新成数组中下一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <span class="hljs-comment">//反编译的结果</span><br>    <span class="hljs-type">int</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-type">int</span>[] var2 = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> array.length;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var4 &lt; var3; ++var4) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> var2[var4];<br>        System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    Integer[] test = arr;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</p><p><img src="https://s2.loli.net/2022/09/24/XbfZ9YHkqjv7613.png" alt="image-20220924114859252"></p><p>但是如果是引用类型的话，是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>    Object[] array = arr;    <span class="hljs-comment">//数组同样支持向上转型</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>    String[] array = (String[]) arr;   <span class="hljs-comment">//也支持向下转型</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>][<span class="hljs-number">10</span>];    <span class="hljs-comment">//数组类型数组那么就要写两个[]了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组：</p><p><img src="https://s2.loli.net/2022/09/22/kRcO1aGY6fMBiu9.png" alt="image-20220922221557130"></p><p>这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] arr = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>                    &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>                    &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;   <span class="hljs-comment">//一个三行两列的数组</span><br>    System.out.println(arr[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]);   <span class="hljs-comment">//访问第三行第二列的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在访问多维数组时，我们需要使用多次<code>[]</code>运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>            &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>            &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;    <span class="hljs-comment">//要遍历一个二维数组，那么我们得一列一列一行一行地来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;<br>            System.out.println(arr[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h3><p>我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... strings)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在使用时，可以传入0 - N个对应类型的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person.test(<span class="hljs-string">&quot;1！&quot;</span>, <span class="hljs-string">&quot;5！&quot;</span>, <span class="hljs-string">&quot;哥们在这跟你说唱&quot;</span>); <span class="hljs-comment">//这里我们可以自由传入任意数量的字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String... strings)</span>&#123;   <span class="hljs-comment">//strings这个变量就是一个String[]类型的</span><br>    <span class="hljs-keyword">for</span> (String string : strings) &#123;<br>        System.out.println(string);   <span class="hljs-comment">//遍历打印数组中每一个元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果同时存在其他参数，那么可变长参数只能放在最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, String... strings)</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里最后我们再来说一个从开始到现在一直都没有说的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <span class="hljs-comment">//这个String[] args到底是个啥？？？</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (String arg : args) &#123;<br>        System.out.println(arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">java com/test/Main lbwnb aaaa xxxxx   <span class="hljs-comment">#放在包中需要携带主类完整路径才能运行</span><br></code></pre></td></tr></table></figure><p>可以看到，我们在后面随意添加的三个参数，都放到数组中了：</p><p><img src="https://s2.loli.net/2022/09/22/DL3WTMdRwrSYJIl.png" alt="image-20220922223152648"></p><p>这个东西我们作为新手一般也不会用到，只做了解就行了。</p><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型<code>char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以象征性地使用一下new关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);  <span class="hljs-comment">//这种方式就是创建一个新的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    System.out.println(str1 == str2);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    System.out.println(str1 == str2);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了<code>equals</code>方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    System.out.println(str1.equals(str2));   <span class="hljs-comment">//字符串的内容比较，一定要用equals</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    System.out.println(str.length());   <span class="hljs-comment">//length方法可以求字符串长度，这个长度是字符的数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>.length());   <span class="hljs-comment">//虽然看起来挺奇怪的，但是确实支持这种写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sub</span> <span class="hljs-operator">=</span> str.substring(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);   <span class="hljs-comment">//分割字符串，并返回一个新的子串对象</span><br>    System.out.println(sub);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    String[] strings = str.split(<span class="hljs-string">&quot; &quot;</span>);   <span class="hljs-comment">//使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组</span><br>    <span class="hljs-keyword">for</span> (String string : strings) &#123;<br>        System.out.println(string);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符数组和字符串之间是可以快速进行相互转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">char</span>[] chars = str.toCharArray();<br>    System.out.println(chars);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span>[] chars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[]&#123;<span class="hljs-string">&#x27;奥&#x27;</span>, <span class="hljs-string">&#x27;利&#x27;</span>, <span class="hljs-string">&#x27;给&#x27;</span>&#125;;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，String类还有很多其他的一些方法，这里就不一一介绍了。</p><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><p>我们在之前的学习中已经了解，字符串支持使用<code>+</code>和<code>+=</code>进行拼接操作。</p><p>但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;杰哥&quot;</span> + <span class="hljs-string">&quot;你干嘛&quot;</span>;    <span class="hljs-comment">//我们在写代码时使用的是拼接的形式</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译之后就变成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;杰哥你干嘛&quot;</span>;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于变量来说，也有优化，比如下面这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你看&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;汉堡&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;做滴&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;行不行&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1 + str2 + str3 + str4 + str5;   <span class="hljs-comment">//5个变量连续加</span><br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你看&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;这&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;汉堡&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;做滴&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;行不行&quot;</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    builder.append(str1).append(str2).append(str3).append(str4).append(str5);<br>    System.out.println(builder.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();   <span class="hljs-comment">//一开始创建时，内部什么都没有</span><br>    builder.append(<span class="hljs-string">&quot;AAA&quot;</span>);   <span class="hljs-comment">//我们可以使用append方法来讲字符串拼接到后面</span><br>    builder.append(<span class="hljs-string">&quot;BBB&quot;</span>);<br>    System.out.println(builder.toString());   <span class="hljs-comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它还支持裁剪等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;AAABBB&quot;</span>);   <span class="hljs-comment">//在构造时也可以指定初始字符串</span><br>    builder.delete(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//删除2到4这个范围内的字符</span><br>    System.out.println(builder.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h3 id="Java-11-字符串增强"><a href="#Java-11-字符串增强" class="headerlink" title="(Java 11) 字符串增强"></a>(Java 11) 字符串增强</h3><p>官方在Java11对String类进行了一波加强，主要增加了很多对于字符的判定和特殊处理操作，我们来看看。</p><p>首先是用于去除字符串前后空格<code>strip</code>方法，他会自动去除字符串的前后空格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World   &quot;</span>;<br>System.out.println(string.strip());   <span class="hljs-comment">//Hello World</span><br></code></pre></td></tr></table></figure><p>可以看到，通过<code>strip()</code>直接去除字符串前后空格，不过仅仅是前后，不会去除其中间的空格。注意，当传入的字符串只有空格时，会返回一个空字符串。</p><p>当然，我们也可以使用<code>stripLeading</code>和<code>stripTrailing</code>来只对前面的空格或是后面的空格进行删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   Hello World   &quot;</span>;<br>System.out.println(string.stripLeading());   <span class="hljs-comment">//Hello World   </span><br>System.out.println(string.stripTrailing());   <span class="hljs-comment">//   Hello World</span><br></code></pre></td></tr></table></figure><p>这些操作跟之前一样，因为字符串本身是不可变的，所以返回的是一个新的字符串对象，而非对其本身进行修改。</p><p>除此之外，还有判断字符串是否为纯空格组成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;   &quot;</span>;<br>System.out.println(string.isBlank());  <span class="hljs-comment">//判断是否只有空格（空串也算）</span><br></code></pre></td></tr></table></figure><p>还有直接让字符串重复排列的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ABC&quot;</span>;<br>System.out.println(string.repeat(<span class="hljs-number">5</span>));   <span class="hljs-comment">//让字符串内容重复5次</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/DNvacpzWjh49EnJ.png" alt="image-20250708215325206"></p><h3 id="Java-15-文本块"><a href="#Java-15-文本块" class="headerlink" title="(Java 15) 文本块"></a>(Java 15) 文本块</h3><p>如果你学习过Python，一定知道三引号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#当我们需要使用复杂字符串时，可能字符串中包含了很多需要转义的字符，比如双引号等，这时我们就可以使用三引号来囊括字符串</span><br>multi_line =  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                nice to meet you!</span><br><span class="hljs-string">                  nice to meet you!</span><br><span class="hljs-string">                      nice to meet you!</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span> multi_line<br></code></pre></td></tr></table></figure><p>没错，Java 13也带了这样的特性，旨在方便我们编写复杂字符串，这样就不用再去用那么多的转义字符了，官方为其起的名字叫文本块，此功能在Java 15中实装。我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        &quot;dad&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>;<br>System.out.println(string);  <span class="hljs-comment">//&quot;dad&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到，Java中也可以使用这样的三引号来表示字符串了，并且可以随意在里面使用特殊字符，包括双引号等，不需要任何转义字符就能使用。当然，这个功能只是一个语法糖，最后编译出来的class文件还是会变成普通字符串，只是自动帮我们加了转义字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;\&quot;dad\&quot;\n&quot;</span>;<br>System.out.println(string);<br></code></pre></td></tr></table></figure><p>仔细想想，这样我们写SQL或是HTML岂不是就舒服多了？</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaa731341@163.com&quot;</span>;<br>  <span class="hljs-comment">//假设邮箱格式为 数字/字母@数字/字母.com</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><p>我们先来看看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;oooo&quot;</span>;<br>  <span class="hljs-comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span><br>    System.out.println(str.matches(<span class="hljs-string">&quot;o+&quot;</span>));   <span class="hljs-comment">//+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配前面的子表达式零次或多次。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”<strong>。</strong></strong>* 等价于 **{0,}**。</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 <strong>“z”<strong>。</strong>+</strong> 等价于 **{1,}**。</td></tr><tr><td align="center">?</td><td align="center">匹配前面的子表达式零次或一次。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”<strong>、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 。</strong>?</strong> 等价于 **{0,1}**。</td></tr><tr><td align="center">{n}</td><td align="center">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="center">{n,}</td><td align="center">n 是一个非负整数。至少匹配n 次。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+<strong>。</strong>o{0,}</strong> 则等价于 **o***。</td></tr><tr><td align="center">{n,m}</td><td align="center">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>如果我们想要表示一个范围内的字符，可以使用方括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcabccaa&quot;</span>;<br>    System.out.println(str.matches(<span class="hljs-string">&quot;[abc]*&quot;</span>));   <span class="hljs-comment">//表示abc这几个字符可以出现 0 - N 次</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于普通字符来说，我们可以下面的方式实现多种字符匹配：</p><table><thead><tr><th align="center">字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><strong>[ABC]</strong></td><td align="center">匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td align="center"><strong>[^ABC]</strong></td><td align="center">匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td align="center"><strong>[A-Z]</strong></td><td align="center">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td align="center"><strong>.</strong></td><td align="center">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]</td></tr><tr><td align="center"><strong>[\s\S]</strong></td><td align="center">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td align="center"><strong>\w</strong></td><td align="center">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><p>当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p><p>正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。</p><h3 id="Java-21-22-25-switch模式匹配"><a href="#Java-21-22-25-switch模式匹配" class="headerlink" title="(Java 21&#x2F;22&#x2F;25) switch模式匹配"></a>(Java 21&#x2F;22&#x2F;25) switch模式匹配</h3><p>在前面我们介绍了switch表达式，相比传统的switch语法，它可以非常方便地实现分支判断和结果返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (str) &#123;  <span class="hljs-comment">//直接使用switch表达式的结果作为返回值</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span> -&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span> -&gt; <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p> 在Java 14中对switch进行了进一步增强，引入了模式匹配，可以直接判断目标类型，此功能最终在Java 21实装。原来我们如果要实现类型判断的分支语句，需要像这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> String) &#123;<br>    System.out.println(<span class="hljs-string">&quot;String&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Integer)&#123;<br>    System.out.println(<span class="hljs-string">&quot;Integer&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Other&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在switc支持模式匹配后，我们可以像这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (obj) &#123;<br>        <span class="hljs-keyword">case</span> String s -&gt; <span class="hljs-string">&quot;String&quot;</span>;   <span class="hljs-comment">//直接在case后写上类型和变量名称即可进行类型匹配</span><br>        <span class="hljs-keyword">case</span> Integer i -&gt; <span class="hljs-string">&quot;Integer&quot;</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-string">&quot;Null&quot;</span>;   <span class="hljs-comment">//甚至还可以直接判断null</span><br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;Other&quot;</span>;<br>    &#125;;<br>    System.out.println(type);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这些改进，switch 语句在 Java 中的应用变得更加广泛和灵活。不过我们注意到，模式匹配中的类型后面必须跟一个变量名字，哪怕我根本就不用它，这似乎有点鸡肋，能否有一种办法省略掉呢？在Java 22之后，我们可以使用<code>_</code>下划线来直接取代，表示这是一个后续不会使用的未命名的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (obj) &#123;<br>    <span class="hljs-keyword">case</span> String _ -&gt; <span class="hljs-string">&quot;String&quot;</span>;   <span class="hljs-comment">//直接使用_表示未命名变量</span><br>    <span class="hljs-keyword">case</span> Integer _ -&gt; <span class="hljs-string">&quot;Integer&quot;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-string">&quot;Null&quot;</span>;<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;Other&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不止如此，我们还可以在模式后添加<code>when</code>子句进行额外条件检查，这种操作称为”守卫条件”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (str) &#123;<br>        <span class="hljs-keyword">case</span> String s <span class="hljs-keyword">when</span> s.length() &gt; <span class="hljs-number">2</span> -&gt; <span class="hljs-number">1</span>;  <span class="hljs-comment">//使用when关键字</span><br>        <span class="hljs-keyword">case</span> String s <span class="hljs-keyword">when</span> s.isEmpty() -&gt; <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">0</span>;  <span class="hljs-comment">//注意使用守卫条件后其他情况会变得不可预估，必须使用default对其他情况做处理</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需在case语句后附加<code>when</code>关键字即可，<code>when</code>后面需要填写判断条件，和<code>if</code>一样，必须为一个返回值为<code>boolean</code>的表达式，也可以使用与或非操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (str) &#123;<br>        <span class="hljs-keyword">case</span> String s <span class="hljs-keyword">when</span> s.length() &gt; <span class="hljs-number">2</span> &amp;&amp; s.contains(<span class="hljs-string">&quot;A&quot;</span>) -&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> String _ -&gt; <span class="hljs-number">2</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们做梦都想要的<code>switch</code>区间判断，在Java 21版本终于可以实现了（虽然隔壁Kotlin几年前就能用了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (score) &#123;<br>    <span class="hljs-keyword">case</span> Integer c <span class="hljs-keyword">when</span> c &gt;= <span class="hljs-number">90</span> -&gt; <span class="hljs-string">&quot;优秀&quot;</span>;   <span class="hljs-comment">//注意switch是从上往下匹配，大于90要放前面优先匹配</span><br>    <span class="hljs-keyword">case</span> Integer c <span class="hljs-keyword">when</span> c &gt;= <span class="hljs-number">80</span> -&gt; <span class="hljs-string">&quot;良好&quot;</span>;   <span class="hljs-comment">//走到这里一定小于90，再判断是否大于80</span><br>    <span class="hljs-keyword">case</span> Integer c <span class="hljs-keyword">when</span> c &gt;= <span class="hljs-number">60</span> -&gt; <span class="hljs-string">&quot;及格&quot;</span>;<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;滚蛋&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 可能很多小伙伴说为什么这里不直接用<code>int</code>基本类型呢？实际上针对于基本类型的模式匹配和守卫条件，在Java 24才作为预览特性支持，到Java 25之后才可以正式使用。</p><p>此外，针对于此前提到的记录类型，在<code>switch</code>语句中支持直接解构使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">(Object object)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (object) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> -&gt; x + y;  <span class="hljs-comment">//直接解构其参数使用</span><br>        <span class="hljs-keyword">case</span> String _ -&gt; <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">5</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里针对于记录类型，类似重新写了一次类型声明，编写完整的类名加参数<code>Point(int x, int y)</code>表示当<code>object</code>如果是记录类型，则进入此分支且解构其内部成员变量，这里写的<code>x</code>和<code>y</code>作为结构出来的变量可以直接在后续使用。同样的，解构的变量如果后续不使用也可以直接使用下划线代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (object) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> _, <span class="hljs-type">int</span> y)</span> -&gt; y;<br>    <span class="hljs-keyword">case</span> String _ -&gt; <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">5</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>你以为这样就完了吗，<code>switch</code>还支持对记录类内部成员的类型嵌套匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">record</span> <span class="hljs-title class_">Container</span><span class="hljs-params">(Object data)</span> &#123;&#125;  <span class="hljs-comment">//这里data是Object类型的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">test</span><span class="hljs-params">(Container object)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (object) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-title function_">Container</span><span class="hljs-params">(String str)</span> -&gt; str.length();  <span class="hljs-comment">//其内部类型如果是String</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-title function_">Container</span><span class="hljs-params">(Integer i)</span> -&gt; i;  <span class="hljs-comment">//其内部类型如果是Integer</span><br>        <span class="hljs-keyword">default</span> -&gt; <span class="hljs-number">0</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。</p><p><strong>注意：</strong> 内部类很多地方都很绕，所以说一定要仔细思考。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>我们可以直接在类的内部定义成员内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;   <span class="hljs-comment">//内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是成员内部类！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();   <span class="hljs-comment">//我们首先需要创建对象</span><br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//成员内部类的类型名称就是 外层.内部类名称</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> test.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>    inner.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为<code>private</code>，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的：</p><p><img src="https://s2.loli.net/2022/09/24/HklipN4uOfK9JrG.png" alt="image-20220924122217070"></p><p>可以看到这里直接不认识了。</p><p>这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是成员内部类：&quot;</span>+name);<br>         <span class="hljs-comment">//成员内部类可以访问到外部的成员变量</span><br>          <span class="hljs-comment">//因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png" alt="image-20220924123600217"></p><p>每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。</p><p>所以说我们在使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;小明&quot;</span>);<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner1</span> <span class="hljs-operator">=</span> a.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//依附于a创建的对象，那么就是a的</span><br>    inner1.test();<br><br>    <span class="hljs-type">Test</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;小红&quot;</span>);<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner2</span> <span class="hljs-operator">=</span> b.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <span class="hljs-comment">//依附于b创建的对象，那么就是b的</span><br>    inner2.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>那现在问大家一个问题，外部能访问内部类里面的成员变量吗？</p><p>那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>        String name;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;方法参数的name = &quot;</span>+name);    <span class="hljs-comment">//依然是就近原则，最近的是参数，那就是参数了</span><br>            System.out.println(<span class="hljs-string">&quot;成员内部类的name = &quot;</span>+<span class="hljs-built_in">this</span>.name);   <span class="hljs-comment">//在内部类中使用this关键字，只能表示内部类对象</span><br>            System.out.println(<span class="hljs-string">&quot;成员内部类的name = &quot;</span>+Test.<span class="hljs-built_in">this</span>.name);<br>          <span class="hljs-comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包括对方法的调用和super关键字的使用，也是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.toString();<span class="hljs-comment">//内部类自己的toString方法</span><br>        <span class="hljs-built_in">super</span>.toString();    <span class="hljs-comment">//内部类父类的toString方法</span><br>        Test.<span class="hljs-built_in">this</span>.toString();   <span class="hljs-comment">//外部类的toSrting方法</span><br>        Test.<span class="hljs-built_in">super</span>.toString();  <span class="hljs-comment">//外部类父类的toString方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;我是静态内部类！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不需要依附任何对象，我们可以直接创建静态内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Test.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>.Inner();   <span class="hljs-comment">//静态内部类的类名同样是之前的格式，但是可以直接new了</span><br>  inner.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：</p><p><img src="https://s2.loli.net/2022/09/24/cZapwgeATlG2FHn.png" alt="image-20220924124919135"></p><p>只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br><br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态内部类：&quot;</span>+name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类就像局部变量一样，可以在方法中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;    <span class="hljs-comment">//直接在方法中创建局部内部类</span><br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然是在方法中声明的类，那作用范围也就只能在方法中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;   <span class="hljs-comment">//局部内部类跟局部变量一样，先声明后使用</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;我是局部内部类&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();   <span class="hljs-comment">//局部内部类直接使用类名就行</span><br>        inner.test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。</p><p>还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#123;   <span class="hljs-comment">//在new的时候，后面加上花括号，把未实现的方法实现了</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是匿名内部类的实现!&quot;</span>);<br>        &#125;<br>    &#125;;<br>    student.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。</p><p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>() &#123;<br>    <span class="hljs-type">int</span> a;   <span class="hljs-comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;我是匿名内部类的实现!&quot;</span>);   <span class="hljs-comment">//直接使用父类中的name变量</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Study</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);<br>        &#125;<br>    &#125;;<br>    study.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);   <span class="hljs-comment">//是不是感觉非常简洁！</span><br>  study.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）</p><p>那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">() -&gt; System.out.println(<span class="hljs-string">&quot;我是学习方法！&quot;</span>);   <span class="hljs-comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span><br></code></pre></td></tr></table></figure><p>当然，如果有一个参数和返回值的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学习方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天学会了&quot;</span>+a;    <span class="hljs-comment">//实际上这里面就是方法体，该咋写咋写</span><br>    &#125;;<br>    System.out.println(study.study(<span class="hljs-number">10</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;今天学会了&quot;</span>+a;   <span class="hljs-comment">//这种情况是可以简化的</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a) -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a;<br></code></pre></td></tr></table></figure><p>如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> a -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a;<br></code></pre></td></tr></table></figure><p>是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(a -&gt; <span class="hljs-string">&quot;今天学会了&quot;</span>+a);   <span class="hljs-comment">//参数直接写成lambda表达式</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Study study)</span>&#123;<br>    study.study(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;   <span class="hljs-comment">//待实现的求和方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么使用时候，可以直接使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a, b) -&gt; a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Integer类中就已经有对应的实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，我们可以直接将已有方法的实现作为接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> (a, b) -&gt; Integer.sum(a, b);   <span class="hljs-comment">//直接使用Integer为我们通过好的求和方法</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> Integer::sum;    <span class="hljs-comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span><br>    System.out.println(study.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    String <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> main::lbwnb;   <span class="hljs-comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span><br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">lbwnb</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;卡布奇诺今犹在，不见当年倒茶人。&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> String::<span class="hljs-keyword">new</span>;    <span class="hljs-comment">//没错，构造方法也可以被引用，使用new表示</span><br>&#125;<br></code></pre></td></tr></table></figure><p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。</p><hr><h2 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h2><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//当b为0的时候，还能正常运行吗？</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a/b;   <span class="hljs-comment">//没有任何的判断而是直接做计算</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们可以看到，出现了运算异常：</p><p><img src="https://s2.loli.net/2022/09/24/5PxTJv7M2YFzfg4.png" alt="image-20220924164357033"></p><p>那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    object.toString();   <span class="hljs-comment">//这种情况就会出现运行时异常</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/cTAqbZ93HidRIGW.png" alt="image-20220924164637887"></p><p>又比如下面的这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> (Main) object;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/QxMimbjZk19C25d.png" alt="image-20220924164844005"></p><p>异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p>比如Object类中定义的<code>clone</code>方法，就明确指出了在运行的时候会出现的异常。</p><p>还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure><p>比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：</p><p><img src="https://s2.loli.net/2022/09/24/9YEZV2L73ROQTuA.png" alt="image-20220924165500108"></p><p>这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Object[] objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[Integer.MAX_VALUE];   <span class="hljs-comment">//这里申请一个超级大数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：</p><p><img src="https://s2.loli.net/2022/09/24/qj8zJnGxdS5IybX.png" alt="image-20220924165657392"></p><p>此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。</p><p>当然，我们这一块主要讨论的目录依然是异常。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);   <span class="hljs-comment">//这里我们选择使用父类的带参构造，这个参数就是异常的原因</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。</p><p><img src="https://s2.loli.net/2022/09/24/TzUu5Sk6NycB9An.png" alt="image-20220924202450589"></p><p>异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。</p><p>运行时异常只需要继承RuntimeException就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TestException</span><span class="hljs-params">(String message)</span>&#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RuntimeException继承自Exception，Exception继承自Throwable：</p><p><img src="https://s2.loli.net/2022/09/24/RjzWnNDc6TZeSoJ.png" alt="image-20220924203130042"></p><p>运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。</p><p>当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。</p><h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">if</span>(b == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;被除数不能为0&quot;</span>);  <span class="hljs-comment">//使用throw关键字来抛出异常</span><br>    <span class="hljs-keyword">return</span> a / b;<br>&#125;<br></code></pre></td></tr></table></figure><p>异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。</p><p>当出现异常时：</p><p><img src="https://s2.loli.net/2022/09/24/Ttr4kZSyodKi3M8.png" alt="image-20220924200817314"></p><p>程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p><p>注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;    <span class="hljs-comment">//使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;我是编译时异常！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, ClassNotFoundException &#123;  <span class="hljs-comment">//多个异常使用逗号隔开</span><br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> RuntimeException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。</p><p>最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">//使用try-catch语句进行异常捕获</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        object.toString();<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e)&#123;   <span class="hljs-comment">//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常</span><br><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序继续正常运行！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常：</p><p><img src="https://s2.loli.net/2022/09/24/7Ek5A46QHNKtWoJ.png" alt="image-20220924195434572"></p><p>可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。</p><p>注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。</p><p>我们可以在<code>catch</code>语句块中对捕获到的异常进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        object.toString();<br>    &#125; <span class="hljs-keyword">catch</span> (NullPointerException e)&#123;<br>        e.printStackTrace();   <span class="hljs-comment">//打印栈追踪信息</span><br>        System.out.println(<span class="hljs-string">&quot;异常错误信息：&quot;</span>+e.getMessage());   <span class="hljs-comment">//获取异常的错误信息</span><br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;程序继续正常运行！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/d15ns6hQblU8TAS.png" alt="image-20220924201405697"></p><p>如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-number">10</span>);    <span class="hljs-comment">//必须要进行异常的捕获，否则报错</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <span class="hljs-comment">//明确会抛出IOException</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;  <span class="hljs-comment">//继续编写throws往上一级抛</span><br>    test(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。</p><p>注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br>        arr[<span class="hljs-number">1</span>] = <span class="hljs-number">100</span>;    <span class="hljs-comment">//这里发生的是数组越界异常，它是运行时异常的子类</span><br>    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//使用运行时异常同样可以捕获到</span><br>        System.out.println(<span class="hljs-string">&quot;捕获到异常&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;<br>            <br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;<br><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;<br>            <br>&#125;<br></code></pre></td></tr></table></figure><p>但是要注意一下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (RuntimeException e)&#123;  <span class="hljs-comment">//父类型在前，会将子类的也捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException e) &#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="hljs-comment">//永远都不会被捕获</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过这样写好像有点丑，我们也可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//....</span><br>&#125; <span class="hljs-keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="hljs-comment">//用|隔开每种类型即可</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。</p><p>最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//....</span><br>&#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            <br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>  System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>);   <span class="hljs-comment">//无论是否出现异常，都会在最后执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    a /= <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">finally</span> &#123;  <span class="hljs-comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span><br>    System.out.println(<span class="hljs-string">&quot;lbwnb&quot;</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>思考：</strong> <code>try</code>、<code>catch</code>和<code>finally</code>执行顺序？</p><h3 id="断言表达式"><a href="#断言表达式" class="headerlink" title="断言表达式"></a>断言表达式</h3><p>我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下：</p><p><img src="https://s2.loli.net/2022/09/24/cAG8kY395fOuTLg.png" alt="image-20220924220327591"></p><p>开启断言之后，我们就可以开始使用了。</p><p>断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们可以判断变量的值，如果大于10就抛出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/12b6zRAL3evQ9ZB.png" alt="image-20220924220704026"></p><p>我们可以在表达式的后面添加错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">assert</span> a &gt; <span class="hljs-number">10</span> : <span class="hljs-string">&quot;我是自定义的错误信息&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就会显示到错误后面了：</p><p><img src="https://s2.loli.net/2022/09/24/NaYk5pFiBPLXVIr.png" alt="image-20220924220813609"></p><p>断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。</p><hr><h2 id="常用工具类介绍"><a href="#常用工具类介绍" class="headerlink" title="常用工具类介绍"></a>常用工具类介绍</h2><p>前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。</p><h3 id="数学工具类"><a href="#数学工具类" class="headerlink" title="数学工具类"></a>数学工具类</h3><p>Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//Math也是java.lang包下的类，所以说默认就可以直接使用</span><br>    System.out.println(Math.pow(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>));   <span class="hljs-comment">//我们可以使用pow方法直接计算a的b次方</span><br>  <br>  Math.abs(-<span class="hljs-number">1</span>);    <span class="hljs-comment">//abs方法可以求绝对值</span><br>  Math.max(<span class="hljs-number">19</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//快速取最大值</span><br>  Math.min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//快速取最小值</span><br>  Math.sqrt(<span class="hljs-number">9</span>);    <span class="hljs-comment">//求一个数的算术平方根</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，三角函数肯定也是安排上了的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Math.sin(Math.PI / <span class="hljs-number">2</span>);     <span class="hljs-comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span><br>Math.cos(Math.PI);       <span class="hljs-comment">//求π的余弦值</span><br>Math.tan(Math.PI / <span class="hljs-number">4</span>);    <span class="hljs-comment">//求π/4的正切值</span><br><br>Math.asin(<span class="hljs-number">1</span>);     <span class="hljs-comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span><br>Math.acos(<span class="hljs-number">1</span>);<br>Math.atan(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Math.sin(Math.PI));   <span class="hljs-comment">//计算 sinπ 的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fZ6OVRejDXWSalC.png" alt="image-20220923231536032"></p><p>正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li>$1.2246467991473532 \times 10^{-16}$</li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>我们也可以快速计算对数函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Math.log(Math.E);    <span class="hljs-comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span><br>    Math.log10(<span class="hljs-number">100</span>);     <span class="hljs-comment">//10为底的对数函数</span><br>    <span class="hljs-comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Math.log(<span class="hljs-number">4</span>) / Math.log(<span class="hljs-number">2</span>);   <span class="hljs-comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Math.ceil(<span class="hljs-number">4.5</span>);    <span class="hljs-comment">//通过使用ceil来向上取整</span><br>    Math.floor(<span class="hljs-number">5.6</span>);   <span class="hljs-comment">//通过使用floor来向下取整</span><br>&#125;<br></code></pre></td></tr></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><p>这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();   <span class="hljs-comment">//创建Random对象</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>        System.out.print(random.nextInt(<span class="hljs-number">100</span>)+<span class="hljs-string">&quot; &quot;</span>);  <span class="hljs-comment">//nextInt方法可以指定创建0 - x之内的随机数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为，可以看到确实是一堆随机数：</p><p><img src="https://s2.loli.net/2022/09/23/fM8J7zO2qHXhvst.png" alt="image-20220923234642670"></p><p>只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）</p><h3 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h3><p>前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。</p><p>这个类也是<code>java.util</code>包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fx61nKT7LjdMv5q.png" alt="image-20220923235747731"></p><p>是不是感觉非常方便？这样我们直接就可以打印数组了！</p><p>除了这个方法，它还支持将数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>&#125;;<br>    Arrays.sort(arr);    <span class="hljs-comment">//可以对数组进行排序，将所有的元素按照从小到大的顺序排放</span><br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。</p><p>数组中的内容也可以快速进行填充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    Arrays.fill(arr, <span class="hljs-number">66</span>);<br>    System.out.println(Arrays.toString(arr));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以快速地对一个数组进行拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = Arrays.copyOf(arr, <span class="hljs-number">5</span>);<br>    System.out.println(Arrays.toString(target));   <span class="hljs-comment">//拷贝数组的全部内容，并生成一个新的数组对象</span><br>    System.out.println(arr == target);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = Arrays.copyOfRange(arr, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//也可以只拷贝某个范围内的内容</span><br>    System.out.println(Arrays.toString(target));<br>    System.out.println(arr == target);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以将一个数组中的内容拷贝到其他数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>[] target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>    System.arraycopy(arr, <span class="hljs-number">0</span>, target, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>);   <span class="hljs-comment">//使用System.arraycopy进行搬运</span><br>    System.out.println(Arrays.toString(target));<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    System.out.println(Arrays.binarySearch(arr, <span class="hljs-number">5</span>));   <span class="hljs-comment">//二分搜索仅适用于有序数组</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。</p><p>那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.toString(array));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/L2at7HJi3BKf6jF.png" alt="image-20220924114142785"></p><p>只不过别担心，Arrays也支持对多维数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.deepToString(array));    <span class="hljs-comment">//deepToString方法可以对多维数组进行打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    <span class="hljs-type">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[][]&#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>&#125;&#125;;<br>    System.out.println(Arrays.equals(a, b));   <span class="hljs-comment">//equals仅适用于一维数组</span><br>    System.out.println(Arrays.deepEquals(a, b));   <span class="hljs-comment">//对于多维数组，需要使用deepEquals来进行深层次判断</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是<code>Object[]</code>也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错：</p><p><img src="https://s2.loli.net/2022/09/24/ab94eNcJPERlOYA.png" alt="image-20220924115440998"></p><p>总体来说，这个工具类对于我们数组的使用还是很方便的。</p><h3 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h3><p>在开始之前，我们先来介绍一下计算机中的时间是如何进行存储的，如何进行表示的以及时区是如何划分的。</p><p>在计算机中，日期一般以时间戳的形式存在，是自1970年1月1日00:00:00（UTC时间）起到某一时刻的毫秒数。比如按照毫秒进行计时，当时间戳为1000时，就表示时间为1970年1月1日00:00:01这个时间。</p><p>那么什么又是时区呢？</p><blockquote><p>时区（Time Zone）是地球上划分的区域，用于标准化时间。由于地球自转，全球不同地区的日出日落时间不同，为了方便统一时间的管理和交流，地球被划分为多个时区。</p><p><img src="https://s2.loli.net/2025/07/08/vCtf6e7iMR3caHd.png" alt="image-20250708173054858"></p><p>原则上，全球共分为24个时区，每隔经度15°划分一个时区，时区从英国的本初子午线开始，向东方每增加一个时区则+1，+1则称为东一区，+8就是东八区。向西方每增加一个时区则-1，-1就是西一区。中国相当于是横跨了5个时区，从东五区（西藏）到东九区（吉林），但实际上中国全国统一使用一个标准时间，就是位于东八区的北京时间，当本初子午线的时间为凌晨0点时，中国时间则需要按照规则+8偏移，也就是早上的8点钟，相当于中国已经看到了日出，而英国还在夜晚，这与现实是一致的，其他地区也是一样的计算规则。</p><p>其中位于本初子午线的时间被称为格林威治标准时间GMT，就像周杰伦歌词里写的那样，它是时间的标准起点。</p><p><img src="https://s2.loli.net/2025/07/08/7KHinqC5ON8X3Mo.png" alt="image-20250708174926873"></p><p>UTC（Coordinated Universal Time，协调世界时）是一种世界标准时间，用于同步全球的时间系统。也是按照标准时区进行计算，其中格林威治时间就是UTC+0，而位于东八区的北京时间，则是UTC+8，称为中国标准时间（CTT），位于西六区的北美中部地区则是UTC-6，是中部标准时间（CST）。</p><p>当然，时区也有一些别名，比如中国标准时区CST也可以使用别名<code>Asia/ShangHai</code>，一般别名格式为<code>州名称/城市名称</code>，比如美国纽约就是<code>America/New_York</code>。</p></blockquote><p>在了解完时间和时区的概念后，我们回到Java中，如果需要表示日期和时间，我们可以使用官方提供的<code>Date</code>类，它同样是按时间戳数字保存时间的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    System.out.println(date);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Date</code>对象代表一个日期，其中包含当前的详细时间，我们直接创建一个新的<code>Date</code>对象其中的时间直接就是创建时的时间，精确到毫秒。打印结果为：</p><p><img src="https://s2.loli.net/2025/07/08/Y7fMZLv3sNXxHUi.png" alt="image-20250708011705152"></p><p>可以看到打印的日期结果上有当前的年月日和时分秒信息，以及对应的时区，这里是中国标准时间CST。我们也可以直接传入一个时间戳来为其指定时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1000</span>);<br>System.out.println(date);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/AVCqyd82YDWOH9L.png" alt="image-20250708175750292"></p><p>时间戳 1000 代表的就是 1970年1月1日 0点0分1秒，注意时间戳代表的是格林威治时间，也就是UTC+0，换算成中国的时间，UTC+8就是早上的8点0分1秒。如果需要得到UTC+0的格林威治时间，可以使用<code>toGMTString</code>打印为格林威治时间的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">1000</span>);<br>System.out.println(date.toGMTString());<br></code></pre></td></tr></table></figure><p>当然我们也可以自由指定Date对象所代表的时间，它有多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">125</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//直接设置年月日时分秒，其中年是相对于1900年，月份从0开始</span><br>System.out.println(date);<br></code></pre></td></tr></table></figure><p>可以看到，虽然Date类有直接构造的方法，但是这些构造方法都被标记为过时，因为这设计实在是太难用了，而且时区问题更是难以处理，为了不破坏原来的API，JDK 1.1的时候新增了大量日期相关的类，我们会在后面介绍。</p><p>接着我们来看Date类的一些其他方法，比如比较两个日期谁前谁后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">125</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">123</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>System.out.println(date1.after(date2));<br>System.out.println(date1.before(date2));<br></code></pre></td></tr></table></figure><p>我们也可以使用<code>compareTo</code>来进行比较，如果两个Date相等，则返回值为 0，如果前者位于后者之前，则返回值小于 0 ，反之大于0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">125</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">123</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>System.out.println(date1.compareTo(date2));<br></code></pre></td></tr></table></figure><p>其他诸如获取年份、月份、日期等方法，均被标记为过时，它门都指向了一个新的类 —— <code>Calendar</code>类，它用于在日期和时间字段之间进行转换，提供了大量实用方法，相比直接使用Date来说，会方便不少。我们需要通过<code>getInstance</code>来获取其对象实例：</p><p><img src="https://s2.loli.net/2025/07/08/9BfW47dGOgpVm8z.png" alt="image-20250708013055861"></p><p>我们可以通过<code>setTime</code>来直接传入<code>Date</code>对象设置一个日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>instance.setTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());  <span class="hljs-comment">//实际上默认情况下不设定也是当前时间</span><br></code></pre></td></tr></table></figure><p>当然，除了这种方式之外，我们也可以使用<code>set</code>方法来直接设置年月日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>instance.set(<span class="hljs-number">2025</span>, Calendar.NOVEMBER, <span class="hljs-number">1</span>);<br>instance.set(<span class="hljs-number">2025</span>, Calendar.NOVEMBER, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//时分秒也可以一起</span><br></code></pre></td></tr></table></figure><p>其中月份可以直接使用<code>Calendar</code>提供的静态变量，每一个月份都有对应的变量。也可以针对某一个特定项单独设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>instance.set(<span class="hljs-number">2025</span>, Calendar.NOVEMBER, <span class="hljs-number">1</span>);<br>instance.set(Calendar.YEAR, <span class="hljs-number">2019</span>);   <span class="hljs-comment">//直接设置年份</span><br></code></pre></td></tr></table></figure><p><code>Calendar</code>同样提供了大量静态变量表示日期的每一个位置，比如年份，月份，日期等，这里的<code>Calendar.YEAR</code>代表的就是就是年份。我们还可以使用<code>add</code>直接为指定参数添加值，比如让年份增加6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>instance.set(<span class="hljs-number">2019</span>, Calendar.NOVEMBER, <span class="hljs-number">1</span>);<br>instance.add(Calendar.YEAR, <span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure><p>构建好日期后，使用<code>getTime</code>就可以直接生成一个对应的Date对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>instance.set(<span class="hljs-number">2025</span>, Calendar.NOVEMBER, <span class="hljs-number">1</span>);<br><span class="hljs-type">Date</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> instance.getTime();<br>System.out.println(time);<br></code></pre></td></tr></table></figure><p>除此之外，<code>Calendar</code>还提供了很多日期相关的工具，这里就不详细介绍了。</p><p>我们最后来认识一下<code>DateFormat</code>类，它可以实现字符串和日期的相互转换。由于其定义是一个抽象类无法直接使用，其常用的子类是<code>SimpleDateFormat</code>，通过配置能实现各种各样的日期转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//对应的日期格式为：2025-11-11 21:12:03（区分大小写）</span><br><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br></code></pre></td></tr></table></figure><p>其中日期格式需要我们手动指定，日期格式的规则可以参考，常用格式符号：</p><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">y</td><td align="center">年 (年份)</td><td align="center"><code>yyyy</code>（四位数年，如2024）<br><code>yy</code>（两位数年，如24）</td></tr><tr><td align="center">M</td><td align="center">月 (月份)</td><td align="center"><code>MM</code>（两位数月，如01）<br><code>MMM</code>（简写月名，如Jan）<br><code>MMMM</code>（全名，如January）</td></tr><tr><td align="center">d</td><td align="center">日 (天数)</td><td align="center"><code>dd</code>（两位数日，如09）<br><code>d</code>（无前导零）</td></tr><tr><td align="center">H</td><td align="center">24小时制小时（0-23）</td><td align="center"><code>HH</code>（两位，如08）<br><code>H</code>（无前导零）</td></tr><tr><td align="center">h</td><td align="center">12小时制小时（1-12）</td><td align="center"><code>hh</code>（两位，如08）<br><code>h</code>（无前导零）</td></tr><tr><td align="center">m</td><td align="center">分钟</td><td align="center"><code>mm</code>（两位，如05）<br><code>m</code>（无前导零）</td></tr><tr><td align="center">s</td><td align="center">秒</td><td align="center"><code>ss</code>（两位，如09）<br><code>s</code>（无前导零）</td></tr><tr><td align="center">S</td><td align="center">毫秒</td><td align="center"><code>SSS</code>（三位，如123）</td></tr><tr><td align="center">a</td><td align="center">上午&#x2F;下午标志</td><td align="center"><code>AM</code> 或 <code>PM</code></td></tr></tbody></table><p>接着，我们可以直接将指定格式的字符串进行转换，变成对应的日期对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(format.parse(<span class="hljs-string">&quot;2025-11-11 21:12:03&quot;</span>));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/DrzSq6LpAWaPxUl.png" alt="image-20250708020545472"></p><p>同样的，日期对象也可以按照格式进行反向转换，变回字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(format.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/p9AdtGCn7DzQaWX.png" alt="image-20250708020631733"></p><p>不过这些日期工具还是太难用了，在现代化的今天显得很鸡肋，下一部分我们会介绍Java8带来的全新日期类和工具，可以让你的使用体验提升N个档次。</p><h3 id="Java-8-新的日期类"><a href="#Java-8-新的日期类" class="headerlink" title="(Java 8) 新的日期类"></a>(Java 8) 新的日期类</h3><p>Java 8 引入了一套全新的日期和时间 API，主要包括以下几个核心类，它们都位于 <code>java.time</code> 包中，旨在解决旧版 <code>java.util.Date</code> 和 <code>java.util.Calendar</code> 设计上的不足。</p><p>Java 8为我们提供了几种全新的日期类型：</p><ul><li><strong>LocalDate：</strong> 表示没有时间部分的日期（年、月、日）例如：2024-04-27</li><li><strong>LocalTime：</strong> 表示没有日期部分的时间（时、分、秒、纳秒）例如：14:30:00</li><li><strong>LocalDateTime：</strong> 表示日期和时间的组合（没有时区信息）例如：2024-04-27T14:30:00</li><li><strong>ZonedDateTime：</strong> 表示带有时区的日期和时间，例如：2024-04-27T14:30:00+08:00[Asia&#x2F;Shanghai]</li></ul><p>我们首先来体验下普通的LocalDate类，它只代表一个日期，不包含具体时分秒等信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now();  <span class="hljs-comment">//需要使用其内部的静态方法创建对象</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date1</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>);  <span class="hljs-comment">//按年月日创建所见即所得</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date2</span> <span class="hljs-operator">=</span> LocalDate.of(<span class="hljs-number">2025</span>, Month.AUGUST, <span class="hljs-number">18</span>);   <span class="hljs-comment">//同上，按年月日创建</span><br><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date3</span> <span class="hljs-operator">=</span> LocalDate.ofYearDay(<span class="hljs-number">2025</span>, <span class="hljs-number">240</span>);   <span class="hljs-comment">//直接取2025年的第240天</span><br>System.out.println(date);<br></code></pre></td></tr></table></figure><p>使用<code>now()</code>方法可以立即创建一个代表当前时间的<code>LocalDate</code>对象，其中包含了很多关于日期的工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;月份: &quot;</span> + date.getMonth());<br>System.out.println(<span class="hljs-string">&quot;月份数字: &quot;</span> + date.getMonthValue());<br>System.out.println(<span class="hljs-string">&quot;年份: &quot;</span> + date.getYear());<br>System.out.println(<span class="hljs-string">&quot;今年的第几天: &quot;</span> + date.getDayOfYear());<br>System.out.println(<span class="hljs-string">&quot;这个月的第几天: &quot;</span> + date.getDayOfMonth());<br>System.out.println(<span class="hljs-string">&quot;这周的第几天: &quot;</span> + date.getDayOfWeek());<br></code></pre></td></tr></table></figure><p>其中，月份返回的是一个<code>Month</code>对象，其中包含大量对于月份的处理方法。除此之外，它还内置了大量计算操作，比如我们希望这个日期向后加7天，可以直接调用<code>plus</code>方法：</p><p><img src="https://s2.loli.net/2025/07/08/5msecNL2D3SlMqO.png" alt="image-20250708162144958"></p><p>当然向后减去天数的操作也有：</p><p><img src="https://s2.loli.net/2025/07/08/FupaO5kYCItrUJM.png" alt="image-20250708162231000"></p><p>不过需要注意，<code>LocalDate</code>本身的日期是不可变的，我们进行加减操作之后得到的结果是对于原对象的拷贝重新生成的对象，包括我们如果想要单独修改年月日，也只能使用<code>with</code>方法来创建副本：</p><p><img src="https://s2.loli.net/2025/07/08/tmpcT6ZDoQXaRbB.png" alt="image-20250708162431195"></p><p>我们接着来看用于表示时间的<code>LocalTime</code>对象，用法也非常简单，支持通过静态方法或是直接使用内置的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();   <span class="hljs-comment">//现在的时间</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time1</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">30</span>);   <span class="hljs-comment">//指定时分</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>);   <span class="hljs-comment">//指定时分秒</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time3</span> <span class="hljs-operator">=</span> LocalTime.of(<span class="hljs-number">12</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//指定时分秒以及纳秒(注意不是毫秒)</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time4</span> <span class="hljs-operator">=</span> LocalTime.MAX;   <span class="hljs-comment">//LocalTime最大支持时间，也是即将到达下一天的最大时间23:59:59.999</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time5</span> <span class="hljs-operator">=</span> LocalTime.MIN;   <span class="hljs-comment">//LocalTime最小支持时间，也是一天开始的时间0:00:00.000</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time6</span> <span class="hljs-operator">=</span> LocalTime.MIDNIGHT;   <span class="hljs-comment">//同上，午夜，也就是一天开始的时间0:00:00.000</span><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time7</span> <span class="hljs-operator">=</span> LocalTime.NOON;    <span class="hljs-comment">//中午，12:00:00.000</span><br></code></pre></td></tr></table></figure><p>它只能代表某一个时刻，不包含日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();<br>System.out.println(time);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/fYGUMJhXO4IjTrV.png" alt="image-20250708161914665"></p><p>和<code>LocalDate</code>一样，它也内置了很多工具方法，方便我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();<br>System.out.println(<span class="hljs-string">&quot;小时: &quot;</span> + time.getHour());<br>System.out.println(<span class="hljs-string">&quot;分钟: &quot;</span> + time.getMinute());<br>System.out.println(<span class="hljs-string">&quot;秒: &quot;</span> + time.getSecond());<br></code></pre></td></tr></table></figure><p>它同样也包括<code>LocalDate</code>中的加减操作、单独修改时分秒操作，同样会生成副本对象，这里就不详细介绍了。</p><p>我们接着来看<code>LocalDate</code>和<code>LocalTime</code>的结合体，<code>LocalDateTime</code>包含了完整的时间信息，和之前使用的<code>Date</code>比较相似，想要创建也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time2</span> <span class="hljs-operator">=</span> LocalDateTime.of(LocalDate.now(), LocalTime.now()); <span class="hljs-comment">//融合两个对象</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time3</span> <span class="hljs-operator">=</span> LocalDateTime.of(<span class="hljs-number">2025</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">23</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">//年月日时分秒</span><br></code></pre></td></tr></table></figure><p><code>LocalDateTime</code>包含了<code>LocalDate</code>和<code>LocalTime</code>内的所有方法，使用起来更加全面。</p><p>同时，<code>LocalDate</code>和<code>LocalTime</code>也内置了一键补全确实的日期信息的方法，能够直接转换为<code>LocalDateTime</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now();<br>System.out.println(date.atTime(LocalTime.now()));  <span class="hljs-comment">//补齐时分秒</span><br>System.out.println(date.atTime(<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <span class="hljs-comment">//补齐时分秒</span><br><br><span class="hljs-type">LocalTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalTime.now();<br>System.out.println(time.atDate(LocalDate.of(<span class="hljs-number">2025</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)));  <span class="hljs-comment">//补齐年月日</span><br><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>time.toLocalTime();   <span class="hljs-comment">//能转过来，那拆回去肯定也是没问题的</span><br>time.toLocalDate();<br></code></pre></td></tr></table></figure><p>对于时间的格式化，Java 8也提供了一个全新的<code>DateTimeFormatter</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br></code></pre></td></tr></table></figure><p>用法和之前的<code>SimpleDateFormat</code>类似，如果我们需要将字符串日期进行转换，可以像这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//首先创建日期格式化工具</span><br><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-comment">//使用parse指定格式进行转换</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.parse(<span class="hljs-string">&quot;2025-01-01 01:18:22&quot;</span>, formatter);<br>System.out.println(now);<br></code></pre></td></tr></table></figure><p>也可以直接通过<code>SimpleDateFormat</code>进行转换，会返回一个<code>TemporalAccessor</code>类型的对象，它是我们之前认识的几种日期对象的公共父接口，但是注意，它的具体实现类并不是我们想要的类型，而是其他的实现类，不过日期类同样有对应的<code>from</code>转换方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.from(formatter.parse(<span class="hljs-string">&quot;2025-01-01 01:18:22&quot;</span>));<br><span class="hljs-comment">//使用from转换返回的TemporalAccessor为对应日期对象</span><br></code></pre></td></tr></table></figure><p>如果要把日期转换为格式化的字符串，也是和之前一样的，直接使用<code>format</code>方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>System.out.println(formatter.format(LocalDateTime.now()));<br></code></pre></td></tr></table></figure><p>我们接着来看携带偏移值的日期类，它相比<code>LocalDateTime</code>多了一个时间偏移，创建方式还是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> OffsetDateTime.now();<br><span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().atOffset(ZoneOffset.UTC); <span class="hljs-comment">//也可以直接用LocalDateTime补全信息创建，需要携带时间偏移</span><br>System.out.println(time);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/v7YAtjEzN8gJaID.png" alt="image-20250708182739301"></p><p>这里的+08:00实际上就是UTC时间的偏移，中国正好是东八区也就是UTC+8，所以默认得到的时间就是+8小时。</p><p>可能细心的小伙伴在之前已经发现，不仅仅是<code>OffsetDateTime</code>，之前的几个类型都可以在创建时指定时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LocalDate</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> LocalDate.now(ZoneId.of(<span class="hljs-string">&quot;UTC+0&quot;</span>));  <span class="hljs-comment">//直接指定UTC时区</span><br><span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now(ZoneId.of(<span class="hljs-string">&quot;UTC+0&quot;</span>));<br><span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> OffsetDateTime.now(ZoneId.of(<span class="hljs-string">&quot;UTC+0&quot;</span>));<br></code></pre></td></tr></table></figure><p>虽然之前几种时间类型允许传入时区，生成出来的时间也确实是对应时区的时间，但是其中不会保存有关时区的设置，得到的只是对应时区的时间，而<code>OffsetDateTime</code>内部会保存时区，我们可以通过<code>getOffset()</code>获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> OffsetDateTime.now(ZoneId.of(<span class="hljs-string">&quot;UTC+5&quot;</span>));<br><span class="hljs-comment">//返回一个ZoneOffset对象，包含时间偏移量信息</span><br>System.out.println(offset.getOffset());  <span class="hljs-comment">//当时区为UTC标准时区打印Z，其他时间打印+05:00这种</span><br></code></pre></td></tr></table></figure><p>注意这个时间偏移量可以精确到秒，并非只能严格按小时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OffsetDateTime</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> OffsetDateTime.now(ZoneId.of(<span class="hljs-string">&quot;UTC+05:00:02&quot;</span>));<br>System.out.println(offset);  <span class="hljs-comment">//2025-07-08T15:52:39.926356+05:00:02</span><br></code></pre></td></tr></table></figure><p>我们接着来看携带时区信息的日期对象<code>ZonedDateTime</code>，他相比<code>OffsetDateTime</code>信息则更全面，不仅携带偏移值，还携带了时区信息，注意偏移值和时区不是一个概念，偏移值只是表示时间需要向前或是向后偏移多少，而时区信息则包含更加完整的时区信息，比如时区ID等，创建方式也很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> ZonedDateTime.now();<br><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().atZone(ZoneOffset.UTC);  <span class="hljs-comment">//LocalDateTime补全时区信息</span><br>System.out.println(time);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/kdRn4rBjPoHbtAi.png" alt="image-20250708165726855"></p><p>默认的时区为系统设定的时区，我们也可以手动指定其他地区。我们可以打印看下当前时区信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> ZonedDateTime.now();<br>System.out.println(time.getZone());<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/nGu7HgQNSIJKMPU.png" alt="image-20250708185807803"></p><p>这里的时区信息其实就是时区对应的城市。</p><p>接着需要给大家介绍一个非常特殊的时间类型<code>Instant</code>，它用于表示时间线上的一个点，通常用来表示时间戳（即自1970年1月1日格林威治标准时间（UTC）以来的秒数或毫秒数）可能大家会认为它跟之前的日期一样也是表示时间的，但是从定义来说，它更适合表示某一个时间点的时间戳。构造起来很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> Instant.now();<br>Instant.ofEpochSecond(<span class="hljs-number">1</span>);  <span class="hljs-comment">//也可以通过时间点创建，这里是1970-01-01 0:00:01</span><br>Instant.ofEpochSecond(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">//可以精确到纳秒</span><br>System.out.println(instant);<br></code></pre></td></tr></table></figure><p>从打印结果可以看到，其输出默认为格林威治时间，而不是根据当前系统时区展示，所以确实很像是只表示时间戳，而非给我们当做时间对象使用的，并且它的内部不存在任何获取日期时间信息的方法，像是一个砍掉所有功能只用于保存时间的<code>LocalDateTime</code>对象。</p><p>对于我们之前使用的<code>Date</code>对象，在Java8之后同样也可以快速转换为<code>Instant</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-type">Instant</span> <span class="hljs-variable">instant</span> <span class="hljs-operator">=</span> date.toInstant();<br></code></pre></td></tr></table></figure><p>最后是用于表示时间持续和频率的两个工具类，他们都用作表示时间段，也可以被用来计算时间的差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.ofSeconds(<span class="hljs-number">1</span>);   <span class="hljs-comment">//表示相差时间1秒</span><br>Duration.between(LocalTime.now(), LocalTime.now().plusDays(<span class="hljs-number">1</span>));  <span class="hljs-comment">//通过between来计算两个时间的差值</span><br><span class="hljs-type">Period</span> <span class="hljs-variable">period</span> <span class="hljs-operator">=</span> Period.ofDays(<span class="hljs-number">1</span>);   <span class="hljs-comment">//表示相差时间1天</span><br></code></pre></td></tr></table></figure><p>其中，Duration用于计算时间更精确的差值，精确到秒和纳秒，而Period用于粗略计算差值，精确到天。</p><p>有关Java 8新增的日期时间相关类型就介绍到这里。</p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>到目前为止，关于面向对象相关的内容我们已经学习了非常多了，接着依然是练习题。</p><h3 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h3><p>有一个int数组，但是数组内的数据是打乱的，现在我们需要将数组中的数据按<strong>从小到大</strong>的顺序进行排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>请你设计一个Java程序将这个数组中的元素按照顺序排列。</p><h3 id="二分搜索算法"><a href="#二分搜索算法" class="headerlink" title="二分搜索算法"></a>二分搜索算法</h3><p>现在有一个从小到大排序的数组，给你一个目标值<code>target</code>，现在我们想要找到这个值在数组中的对应下标，如果数组中没有这个数，请返回<code>-1</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">15</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>请你设计一个Java程序实现这个功能。</p><h3 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h3><p>现在一共有n个台阶，一只青蛙每次只能跳一阶或是两阶，那么一共有多少种跳到顶端的方案？</p><p>例如n&#x3D;2，那么一共有两种方案，一次性跳两阶或是每次跳一阶。</p><p>现在请你设计一个Java程序，计算当台阶数为n的情况下，能够有多少种方案到达顶端。</p><h3 id="回文串判断"><a href="#回文串判断" class="headerlink" title="回文串判断"></a>回文串判断</h3><p>“回文串”是一个正读和反读都一样的字符串，请你实现一个Java程序，判断用户输入的字符串（仅出现英文字符）是否为“回文”串。</p><blockquote><p> ABCBA   就是一个回文串，因为正读反读都是一样的</p><p> ABCA   就不是一个回文串，因为反着读不一样</p></blockquote><h3 id="汉诺塔求解"><a href="#汉诺塔求解" class="headerlink" title="汉诺塔求解"></a>汉诺塔求解</h3><p>什么是汉诺塔？</p><blockquote><p><strong>汉诺塔</strong>（Tower of Hanoi），又称<strong>河内塔</strong>，是一个源于<a href="https://baike.baidu.com/item/%E5%8D%B0%E5%BA%A6/121904">印度</a>古老传说的<a href="https://baike.baidu.com/item/%E7%9B%8A%E6%99%BA%E7%8E%A9%E5%85%B7/223159">益智玩具</a>。<a href="https://baike.baidu.com/item/%E5%A4%A7%E6%A2%B5%E5%A4%A9/711550">大梵天</a>创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令<a href="https://baike.baidu.com/item/%E5%A9%86%E7%BD%97%E9%97%A8/1796550">婆罗门</a>把圆盘从下面开始</p><p><strong>按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</strong></p></blockquote><p><img src="https://s2.loli.net/2022/09/24/mMpDNwrKk6z3CIo.png" alt="img"></p><p>这三根柱子我们就依次命名为A、B、C，现在请你设计一个Java程序，计算N阶（n片圆盘）汉诺塔移动操作的每一步。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/48zphgkpjto8cath">https://www.itbaima.cn/zh-CN/document/48zphgkpjto8cath</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（三）面向对象基础</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2022/09/18/UsqxV8ndNzYmGjy.png" alt="image-20220918121719900"></p><h1 id="面向对象基础篇"><a href="#面向对象基础篇" class="headerlink" title="面向对象基础篇"></a>面向对象基础篇</h1><p>我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。</p><blockquote><p>面向对象是新手成长的一道分水岭，有的人秒懂，有的人直到最后都无法理解。</p></blockquote><p>这一章开始难度就上来了，所以说请各位小伙伴一定认真。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类的概念我们在生活中其实已经听说过很多了。</p><p>人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p>对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。</p><p><img src="https://s2.loli.net/2022/09/19/U2P7qWOtRz5bhFY.png" alt="image-20220919203119479"></p><p>所以说，类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul><li>A：是谁拿走了我的手机？</li><li>B：是个人。（某一个类）</li><li>A：我还知道是个人呢，具体是谁呢？</li><li>B：是XXX。（具体某个对象）</li></ul><p>而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为<strong>面向对象编程</strong>。</p><h3 id="类的定义与对象创建"><a href="#类的定义与对象创建" class="headerlink" title="类的定义与对象创建"></a>类的定义与对象创建</h3><p>前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p>比如现在我们想要定义一个人类，我们可以右键<code>src</code>目录，点击创建新的类：</p><p><img src="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png" alt="image-20220919204004526"></p><p>我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p><img src="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png" alt="image-20220919204159248"></p><p>可以看到，现在我们的目录下有了两个<code>.java</code>源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。</p><p>我们来看看创建好之后，一个类写了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。</p><p>现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？</p><p>我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//这里定义的人类具有三个属性，名字、年龄、性别</span><br>    String name;   <span class="hljs-comment">//直接在类中定义变量，表示类具有的属性</span><br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。</p><p>那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()</span><br>  <span class="hljs-comment">//这里创建出来的，就是一个具体的人了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上整个流程为：</p><p><img src="https://s2.loli.net/2022/09/19/dSM4XDBV7qkIUlb.png" alt="image-20220919205550104"></p><p>只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。</p><h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><p>既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。</p><p>我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//这里的a存放的是具体的某个值</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  <span class="hljs-comment">//创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名</span><br>  <span class="hljs-comment">//这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>至于为什么对象类型的变量存放的是对象的引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> p1;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><p><img src="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png" alt="image-20220919211443657"></p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> p1;<br>    System.out.println(p1 == p2);    <span class="hljs-comment">//使用 == 可以判断两个变量引用的是不是同一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们像这样去编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//这两个变量分别引用的是不同的两个对象</span><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(p1 == p2);   <span class="hljs-comment">//如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。</p><p>现在我们有了对象的引用之后，我们就可以进行操作了：</p><p><img src="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png" alt="image-20220919210058797"></p><p>我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p>比如我们可以修改对象的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//要访问对象的属性，我们需要使用 . 运算符</span><br>    System.out.println(p.name);   <span class="hljs-comment">//直接打印对象的名字，就是我们刚刚修改好的结果了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p1.name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//这个修改的是第一个对象的属性</span><br>    p2.name = <span class="hljs-string">&quot;大明&quot;</span>;   <span class="hljs-comment">//这里修改的是第二个对象的属性</span><br>    System.out.println(p1.name);  <span class="hljs-comment">//这里我们获取的是第一个对象的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关于对象类型的变量，我们也可以不对任何对象进行引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">//null是一个特殊的值，它表示空，也就是不引用任何的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）</p><p>虽然这样可以编译通过，但是在运行时会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;   <span class="hljs-comment">//此时变量没有引用任何对象</span><br>    p.name = <span class="hljs-string">&quot;小红&quot;</span>;   <span class="hljs-comment">//我任性，就是要操作</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来尝试运行一下这段代码：</p><p><img src="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png" alt="image-20220919213732810"></p><p>此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。</p><p>这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。</p><p>我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(<span class="hljs-string">&quot;name = &quot;</span>+p.name);<br>    System.out.println(<span class="hljs-string">&quot;age = &quot;</span>+p.age);<br>    System.out.println(<span class="hljs-string">&quot;sex = &quot;</span>+p.sex);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看运行结果：</p><p><img src="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png" alt="image-20220919214248053"></p><p>我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="方法创建与使用"><a href="#方法创建与使用" class="headerlink" title="方法创建与使用"></a>方法创建与使用</h3><p>前面我们介绍了类的定义以及对象的创建和使用。</p><p>现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p>而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）</p><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><p>方法的定义如下：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">返回值类型 方法名称() </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">方法体...</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><p>首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>  <span class="hljs-comment">//自我介绍只需要完成就行，没有返回值，所以说使用void</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//完成自我介绍需要执行的所有代码就在这个花括号中编写</span><br>      <span class="hljs-comment">//这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数）</span><br>      <span class="hljs-comment">//自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值</span><br>        System.out.println(<span class="hljs-string">&quot;我叫 &quot;</span>+name+<span class="hljs-string">&quot; 今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p><p><img src="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png" alt="image-20220920101033325"></p><p>现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    p.age = <span class="hljs-number">18</span>;<br>    p.hello();    <span class="hljs-comment">//我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可</span><br>&#125;<br></code></pre></td></tr></table></figure><p>像这样执行定义好的方法，我们一般称为<strong>方法的调用</strong>，我们来看看效果：</p><p><img src="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png" alt="image-20220919220837991"></p><p>比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们的方法需要别人提供参与运算的值才可以</span><br><span class="hljs-comment">//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以</span><br><span class="hljs-comment">//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这里需要两个int类型的参数进行计算</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在参数从外部传入之后，我们怎么使用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;   <span class="hljs-comment">//直接c = a + b</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>    <span class="hljs-keyword">return</span> c;   <span class="hljs-comment">//return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了</span><br>  <span class="hljs-comment">//带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>    p.age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//现在我们要让这个对象帮我们计算10 + 20的结果</span><br>    System.out.println(result);    <span class="hljs-comment">//成功得到30，实际上这里的println也是在调用方法进行打印操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。</p><p>是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。</p><p>关于<code>return</code>关键字，我们还需要进行进一步的介绍。</p><p>在我们使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><p><img src="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png" alt="image-20220919222813469"></p><p>在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p>如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><p><img src="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png" alt="image-20220919223037197"></p><p>只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p>当然，如果方法没有返回值，我们也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//当a等于10时直接结束方法，后面无论有没有代码都不会执行了</span><br>    System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);   <span class="hljs-comment">//不是的情况就正常执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们来讨论一下参数的传递问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;   <span class="hljs-comment">//我们可以设置参数来让外部的数据传入到函数内部</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;   <span class="hljs-comment">//这个函数的目的很明显，就是为了交换a和b的值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>    a = b;<br>    b = a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>, b = <span class="hljs-number">9</span>;   <span class="hljs-comment">//外面也叫a和b</span><br>    p.swap(a, b);<br>    System.out.println(<span class="hljs-string">&quot;a = &quot;</span>+a+<span class="hljs-string">&quot;, b = &quot;</span>+b);   <span class="hljs-comment">//最后的结果会变成什么样子呢？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看结果是什么：</p><p><img src="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png" alt="image-20220919224219071"></p><p>我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）</p><p><img src="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png" alt="image-20220919224623727"></p><p>所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。</p><p>那么各位小伙伴看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">modify</span><span class="hljs-params">(Person person)</span>&#123;<br>    person.name = <span class="hljs-string">&quot;lbwnb&quot;</span>;   <span class="hljs-comment">//修改对象的名称</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.name = <span class="hljs-string">&quot;小明&quot;</span>;     <span class="hljs-comment">//先在外面修改一次</span><br>    p.modify(p);        <span class="hljs-comment">//调用方法再修改一次</span><br>    System.out.println(p.name);    <span class="hljs-comment">//请问最后name会是什么？</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png" alt="image-20220919224957971"></p><p>不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？</p><p>确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><p><img src="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png" alt="image-20220919225455752"></p><h3 id="方法进阶使用"><a href="#方法进阶使用" class="headerlink" title="方法进阶使用"></a>方法进阶使用</h3><p>有时候我们的方法中可能会出现一些与成员变量重名的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//我们希望使用这个方法，来为当前对象设定名字</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>此时类中定义的变量名称也是<code>name</code>，那么我们是否可以这样编写呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    name = name;    <span class="hljs-comment">//出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p.setName(<span class="hljs-string">&quot;小明&quot;</span>);<br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.name = <span class="hljs-string">&quot;小明&quot;</span>;    <span class="hljs-comment">//我们之前在外面使用时，可以直接通过对象.属性的形式访问到</span><br></code></pre></td></tr></table></figure><p>同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;   <span class="hljs-comment">//让当前对象的name变量值等于参数传入的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们接着来看方法的重载。</p><p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(p.sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>));    <span class="hljs-comment">//这里可以正常计算两个整数的和</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p><p><img src="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png" alt="image-20220920102347110"></p><p>当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-type">double</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b)</span>&#123;    <span class="hljs-comment">//为了支持小数加法，我们可以进行一次重载</span><br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以正常使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>  <span class="hljs-comment">//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用</span><br>    System.out.println(p.sum(<span class="hljs-number">1.5</span>, <span class="hljs-number">2.2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>包括我们之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p>注意，如果仅仅是返回值的不同，是不支持重载的：</p><p><img src="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png" alt="image-20220920102933047"></p><p>当然，方法之间是可以相互调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是test&quot;</span>);   <span class="hljs-comment">//实际上这里也是调用另一个方法</span><br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>    test();   <span class="hljs-comment">//在一个方法内调用另一个方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们这样写的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    say();<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span>&#123;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure><p>各位猜猜看会出现什么情况？</p><p><img src="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png" alt="image-20220921001914601"></p><p>此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p><p>方法自己也可以调用自己：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    test();<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> test(n - <span class="hljs-number">1</span>) + n;    <span class="hljs-comment">//返回的结果是下一层返回的结果+当前这一层的n</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>我们接着来看一种比较特殊的方法，构造方法。</p><p>我们前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p><p>实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//反编译中，多出来了这样一个方法，这其实就是构造方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    Person()&#123;    <span class="hljs-comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span><br>        name = <span class="hljs-string">&quot;小明&quot;</span>;   <span class="hljs-comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span><br>        age = <span class="hljs-number">18</span>;<br>        sex = <span class="hljs-string">&quot;男&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//这里的new Person()其实就是在调用无参构造方法</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，我们也可以为构造方法设定参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;   <span class="hljs-comment">//跟普通方法是一样的</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-comment">//调用自己定义的带三个参数的构造方法</span><br>    System.out.println(p.name);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p><p>当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;未知&quot;</span>;   <span class="hljs-comment">//直接赋值，那么对象构造好之后，属性默认就是这个值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;男&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;<br>    System.out.println(age);    <span class="hljs-comment">//在赋值之前看看是否有初始值</span><br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是代码块&quot;</span>);   <span class="hljs-comment">//代码块中的内容会在对象创建时仅执行一次</span><br>    &#125;<br><br>    Person(String name, <span class="hljs-type">int</span> age, String sex)&#123;<br>        System.out.println(<span class="hljs-string">&quot;我被构造了&quot;</span>);<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="静态变量和静态方法"><a href="#静态变量和静态方法" class="headerlink" title="静态变量和静态方法"></a>静态变量和静态方法</h3><p>前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。</p><p>静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>    <span class="hljs-keyword">static</span> String info;    <span class="hljs-comment">//这里我们定义一个info静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    p1.info = <span class="hljs-string">&quot;杰哥你干嘛&quot;</span>;<br>    System.out.println(p2.info);   <span class="hljs-comment">//可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Person.info = <span class="hljs-string">&quot;让我看看&quot;</span>;<br>    System.out.println(Person.info);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，我们可以将方法标记为静态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><p><img src="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png" alt="image-20220920234401275"></p><p>因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：</p><p><img src="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png" alt="image-20220920235418115"></p><p>成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p>但是静态方法是可以访问到静态变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;静态变量的值为：&quot;</span>+info);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为他们都属于类，所以说肯定是可以访问到的。</p><p>我们也可以将代码块变成静态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String info;<br><br><span class="hljs-keyword">static</span> &#123;   <span class="hljs-comment">//静态代码块可以用于初始化静态变量</span><br>    info = <span class="hljs-string">&quot;测试&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，静态变量，是在什么时候进行初始化的呢？</p><p>我们在一开始介绍了，我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> test();  <span class="hljs-comment">//这里我们用test方法的返回值作为变量的初始值，便于观察</span><br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是普通代码块&quot;</span>);<br>    &#125;<br>    <br>    Person()&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是构造方法&quot;</span>);<br>    &#125;<br>    <br>    String <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是成员变量初始化&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;小明&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> init();   <span class="hljs-comment">//这里我们用init静态方法的返回值作为变量的初始值，便于观察</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态代码块&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> String <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态变量初始化&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：</p><p><img src="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png" alt="image-20220921000953525"></p><p>可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p>当然，如果我们直接访问类的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Person.info);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时同样会使得类初始化，进行加载：</p><p><img src="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png" alt="image-20220921001222465"></p><p>可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。</p><p>有关类与对象的基本内容，我们就全部讲解完毕了。</p><hr><h2 id="包和访问控制"><a href="#包和访问控制" class="headerlink" title="包和访问控制"></a>包和访问控制</h2><p>通过前面的学习，我们知道该如何创建和使用类。</p><h3 id="包声明和导入"><a href="#包声明和导入" class="headerlink" title="包声明和导入"></a>包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。</p><p>包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，我们的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹，比如<code>com.test</code>：</p><p><img src="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png" alt="image-20220921120040350"></p><p>我们可以将类放入到包中：</p><p><img src="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png" alt="image-20220921115055000"></p><p>我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;   <span class="hljs-comment">//在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;   <span class="hljs-comment">//将Main类放到com.test这个包中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p>不同的类可以放在不同的包下：</p><p><img src="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png" alt="image-20220921120241184"></p><p>当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> com.test.entity.Person;   <span class="hljs-comment">//使用import关键字导入其他包中的类</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();   <span class="hljs-comment">//只有导入之后才可以使用，否则编译器不知道这个类从哪来的</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了<code>import</code>关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用<code>*</code>表示导入这个包中全部的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.test.entity.*;<br></code></pre></td></tr></table></figure><p>实际上我们之前一直在使用的<code>System</code>类，也是在一个包中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Executable;<br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.security.AccessControlContext;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.PropertyPermission;<br><span class="hljs-keyword">import</span> java.util.StringTokenizer;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.security.AccessController;<br><span class="hljs-keyword">import</span> java.security.PrivilegedAction;<br><span class="hljs-keyword">import</span> java.security.AllPermission;<br><span class="hljs-keyword">import</span> java.nio.channels.Channel;<br><span class="hljs-keyword">import</span> java.nio.channels.spi.SelectorProvider;<br><span class="hljs-keyword">import</span> sun.nio.ch.Interruptible;<br><span class="hljs-keyword">import</span> sun.reflect.CallerSensitive;<br><span class="hljs-keyword">import</span> sun.reflect.Reflection;<br><span class="hljs-keyword">import</span> sun.security.util.SecurityConstants;<br><span class="hljs-keyword">import</span> sun.reflect.annotation.AnnotationType;<br><br><span class="hljs-keyword">import</span> jdk.internal.util.StaticProperty;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span><br><span class="hljs-comment"> * and methods. It cannot be instantiated.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span><br><span class="hljs-comment"> * are standard input, standard output, and error output streams;</span><br><span class="hljs-comment"> * access to externally defined properties and environment</span><br><span class="hljs-comment"> * variables; a means of loading files and libraries; and a utility</span><br><span class="hljs-comment"> * method for quickly copying a portion of an array.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  unascribed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   JDK1.0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System</span> &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此我们不需要手动指定。</p><p>IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。</p><p>注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;    <span class="hljs-comment">//我们在自己的包中也建一个名为String的类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当我们在使用时：</p><p>![image-20220921121404900](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220921121404900.png)</p><p>由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[] args)</span> &#123;   <span class="hljs-comment">//主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了</span><br>com.test.entity.<span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.test.entity.String();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><p>可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？</p><p><img src="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png" alt="image-20220921122514457"></p><p>编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。</p><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。</p><p>所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul><li><code>private</code>   -   私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li><li><code>什么都不写</code>   -   默认，默认情况下，只能被类本身和同包中的其他类访问。</li><li><code>protected</code>   -   受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）</li><li><code>public</code>    -   公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p>这四种访问权限，总结如下表：</p><table><thead><tr><th align="center"></th><th align="center">当前类</th><th align="center">同一个包下的类</th><th align="center">不同包下的子类</th><th align="center">不同包下的类</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr><tr><td align="center">protected</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td></tr><tr><td align="center">默认</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">private</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr></tbody></table><p>比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;   <span class="hljs-comment">//在name变量前添加public关键字，将其可见性提升为公共等级</span><br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在外部正常使用这个属性了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    System.out.println(person.name);   <span class="hljs-comment">//正常访问到成员变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是<code>public</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//class前面有public关键字</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.entity;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-comment">//去掉public变成默认等级</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果是默认等级的话，那么在外部同样是无法访问的：</p><p><img src="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png" alt="image-20220921142724239"></p><p>但是注意，我们创建的普通类不能是<code>protected</code>或是<code>private</code>权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是<code>private</code>谁都不能用，那这个类定义出来干嘛呢？</p><p>如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是静态方法！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来尝试一下静态导入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.test.entity.Person.test;    <span class="hljs-comment">//静态导入test方法</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test();    <span class="hljs-comment">//直接使用就可以，就像在这个类定义的方法一样</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，有关包相关的内容，我们就讲解到这里。</p><hr><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p><p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p>正是这三大特性，让我们的Java程序更加生动形象。</p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p>我们可以将之前的类进行改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//现在类的属性只能被自己直接访问</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;   <span class="hljs-comment">//构造方法也要声明为公共，否则对象都构造不了</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;    <span class="hljs-comment">//想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(person.getName());    <span class="hljs-comment">//只能通过调用getName()方法来获取名字</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含”小”这个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-keyword">if</span>(name.contains(<span class="hljs-string">&quot;小&quot;</span>)) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String sex;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;   <span class="hljs-comment">//不允许外部使用new关键字创建对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Person <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//而是需要使用我们的独特方法来生成对象并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，我们可以实现单例模式：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Test instance;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;&#125;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Test <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) <br>         instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>     <span class="hljs-keyword">return</span> instance;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。</p></blockquote><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：</p><p><img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="image-20220921150139125"></p><p>实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//先定义一个父类</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用<code>extends</code>关键字即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;    <span class="hljs-comment">//工人类</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;   <span class="hljs-comment">//学生类</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <span class="hljs-comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的名字是 &quot;</span>+name+<span class="hljs-string">&quot;，我在学习！&quot;</span>);   <span class="hljs-comment">//可以直接访问父类中定义的name属性</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，在父类中定义的方法同样会被子类继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    String sex;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我叫 &quot;</span>+name+<span class="hljs-string">&quot;，今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.study();    <span class="hljs-comment">//子类不仅有自己的独特技能</span><br>    student.hello();    <span class="hljs-comment">//还继承了父类的全部技能</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p>如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>  <span class="hljs-comment">//构造方法也改成protected，只能子类用</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex, String profession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.profession = profession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;[&quot;</span>+profession+<span class="hljs-string">&quot;] 我叫 &quot;</span>+name+<span class="hljs-string">&quot;，今年 &quot;</span>+age+<span class="hljs-string">&quot; 岁了!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，此时两个子类都报错了：</p><p><img src="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png" alt="image-20220921153512798"></p><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：</p><p>既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;    <span class="hljs-comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span><br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);   <span class="hljs-comment">//使用super代表父类，父类的构造方法就是super()</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我的名字是 &quot;</span>+name+<span class="hljs-string">&quot;，我在学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);    <span class="hljs-comment">//父类构造调用必须在最前面</span><br>        System.out.println(<span class="hljs-string">&quot;工人构造成功！&quot;</span>);    <span class="hljs-comment">//注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在使用子类时，可以将其当做父类来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);    <span class="hljs-comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span><br>    person.hello();    <span class="hljs-comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p>我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) person;   <span class="hljs-comment">//使用强制类型转换（向下转型）</span><br>    student.study();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);   <span class="hljs-comment">//实际创建的是Work类型的对象</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) person;<br>    student.study();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png" alt="image-20220921160309835"></p><p>此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p>那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Student) &#123;   <span class="hljs-comment">//我们可以使用instanceof关键字来对类型进行判断</span><br>        System.out.println(<span class="hljs-string">&quot;对象是 Student 类型的&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Person) &#123;<br>        System.out.println(<span class="hljs-string">&quot;对象是 Person 类型的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p>最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//子类中同样可以定义name属性</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是 &quot;</span>+name+<span class="hljs-string">&quot;，我在工作！&quot;</span>);   <span class="hljs-comment">//这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所以说，我们在使用时，实际上这里得到的结果为<code>null</code>：</p><p><img src="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png" alt="image-20220921160742714"></p><p>那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用<code>super</code>关键字来表示父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是 &quot;</span>+<span class="hljs-built_in">super</span>.name+<span class="hljs-string">&quot;，我在工作！&quot;</span>);   <span class="hljs-comment">//这里使用super.name来表示需要的是父类的name变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样得到的结果就不一样了：</p><p><img src="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png" alt="image-20220921160851193"></p><p>但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="顶层Object类"><a href="#顶层Object类" class="headerlink" title="顶层Object类"></a>顶层Object类</h3><p>实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><p><img src="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png" alt="image-20220921214642969"></p><p>我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span>&#123;   <br><span class="hljs-comment">//除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>所以说我们的继承结构差不多就是：</p><p><img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="image-20220921214944267"></p><p>既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//标记为native的方法是本地方法，底层是由C++实现的</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        registerNatives();   <span class="hljs-comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span><br>    &#125;<br><br>    <span class="hljs-comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br><br>    <span class="hljs-comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>    &#125;<br>  <br>    <span class="hljs-comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br><br>    <span class="hljs-comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br>    <span class="hljs-comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//唤醒所有等待当前对象锁的线程，同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//使得持有当前对象锁的线程进入等待状态，同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//同上</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们可以尝试调用一下Object为我们提供的<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> person.toString();<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是按照上面说的格式进行打印：</p><p><img src="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png" alt="image-20220921221053801"></p><p>当然，我们直接可以给<code>println</code>传入一个Object类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(Object x)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> String.valueOf(x);   <span class="hljs-comment">//这里同样会调用对象的toString方法，所以说跟上面效果是一样的</span><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        print(s);<br>        newLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p>我们也可以试试看默认提供的<code>equals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(p1.equals(p2));<br>&#125;<br></code></pre></td></tr></table></figure><p>因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="Java-16-类型判断模式匹配"><a href="#Java-16-类型判断模式匹配" class="headerlink" title="(Java 16) 类型判断模式匹配"></a>(Java 16) 类型判断模式匹配</h3><p>在Java 14，<code>instanceof</code>迎来了一波小更新，之前我们判断某个对象是否为某个类型或是某个类型的子类时，会用到<code>instanceof</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>());<br>&#125;<br><br><span class="hljs-comment">//实现如果是学生就执行study方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Person person)</span> &#123;<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Student) &#123;   <span class="hljs-comment">//首先判断是否为学生类型</span><br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> (Student) person;  <span class="hljs-comment">//如果是直接进行强制类型转换</span><br>        student.study();   <span class="hljs-comment">//执行学习</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; &#125;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我要打瓦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在之前我们一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但是这个版本<code>instanceof</code>加强之后，我们就不需要了，我们可以直接将student替换为模式变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Person person)</span> &#123;<br>    <span class="hljs-keyword">if</span>(person <span class="hljs-keyword">instanceof</span> Student student) &#123;  <span class="hljs-comment">//直接在instanceof后写变量名称，作为判断成功之后转换的此类型变量名称</span><br>        student.study();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用<code>instanceof</code>判断类型成立后，会自动强制转换类型为指定类型，我们只需要指定强制转换之后的变量名称，简化了我们手动转换的步骤。注意此功能在Java 16中才实装，到Java 17才能不转换类型直接使用。</p><h3 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h3><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的<code>equals</code>方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;   <span class="hljs-comment">//重写方法要求与父类的定义完全一致</span><br>        <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;   <span class="hljs-comment">//如果传入的对象为null，那肯定不相等</span><br>        <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> Person) &#123;     <span class="hljs-comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span><br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) obj;   <span class="hljs-comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="hljs-comment">//字符串内容的比较，不能使用==，必须使用equals方法</span><br>                    <span class="hljs-built_in">this</span>.age == person.age &amp;&amp;       <span class="hljs-comment">//基本类型的比较跟之前一样，直接==</span><br>                    <span class="hljs-built_in">this</span>.sex.equals(person.sex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在重写Object提供的<code>equals</code>方法之后，就会按照我们的方式进行判断了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(p1.equals(p2));   <span class="hljs-comment">//此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有时候为了方便查看对象的各个属性，我们可以将Object类提供的<code>toString</code>方法重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//使用IDEA可以快速生成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>            <span class="hljs-string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, profession=&#x27;&quot;</span> + profession + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们直接打印对象时，就会打印出对象的各个属性值了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png" alt="image-20220921223249343"></p><p>注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p>基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    ...<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>    &#125;<br>  <br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>    ...<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，不同的子类，对于同一个方法会产生不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    person.exam();<br><br>    person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;小强&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    person.exam();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png" alt="image-20220921224525855"></p><p>这其实就是面向对象编程中多态特性的一种体现。</p><p>注意，我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png" alt="image-20220921224907373"></p><p>或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><p><img src="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png" alt="image-20220921225651487"></p><p>虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p>还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.exam();   <span class="hljs-comment">//调用父类的实现</span><br>    System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png" alt="image-20220921225234226"></p><p>因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//将可见性提升为public </span><br>    System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png" alt="image-20220921225840122"></p><p>可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;我是考试方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p>要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;   <span class="hljs-comment">//通过添加abstract关键字，表示这个类是一个抽象类</span><br>    <span class="hljs-keyword">protected</span> String name;   <span class="hljs-comment">//大体内容其实普通类差不多</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">protected</span> String sex;<br>    <span class="hljs-keyword">protected</span> String profession;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex, String profession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>        <span class="hljs-built_in">this</span>.profession = profession;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span>;   <span class="hljs-comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;工人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译</span><br>        System.out.println(<span class="hljs-string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><p><img src="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png" alt="image-20220921231744420"></p><p>要使用抽象类，我们只能去创建它的子类对象。</p><p>抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;   <span class="hljs-comment">//如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span>   <span class="hljs-comment">//抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exam</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，抽象方法的访问权限不能为<code>private</code>：</p><p><img src="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png" alt="image-20220921232435056"></p><p>因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p>咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p>比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;    <span class="hljs-comment">//使用interface表示这是一个接口</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;    <span class="hljs-comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以让类实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;   <span class="hljs-comment">//使用implements关键字来实现接口</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span><br>        System.out.println(<span class="hljs-string">&quot;我会学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Teacher</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;教师&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会加倍学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口不同于继承，接口可以同时实现多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>, A, B, C &#123;  <span class="hljs-comment">//多个接口的实现使用逗号隔开</span><br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p>接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：</p><p><img src="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png" alt="image-20220921234735828"></p><p>当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p>接口同样支持向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Study</span> <span class="hljs-variable">study</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;小王&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-keyword">if</span>(study <span class="hljs-keyword">instanceof</span> Teacher) &#123;   <span class="hljs-comment">//直接判断引用的对象是不是Teacher类型</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">teacher</span> <span class="hljs-operator">=</span> (Teacher) study;   <span class="hljs-comment">//强制类型转换</span><br>        teacher.study();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的使用其实跟之前的父类是差不多的，体现了多态的特性。</p><p>接口不同于类，正常情况下，接口中不允许存在成员变量和成员方法，它是一个非常纯粹的定义，所以它相比抽象类来说还要更抽象。不过和类一样，接口是可以继承自其他接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> exetnds B &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>并且接口没有继承数量限制，接口支持多继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> exetnds B, C, D &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>接口的继承相当于是对接口功能的融合罢了。</p><p>最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Cloneable</span> &#123;    <span class="hljs-comment">//这个接口中什么都没定义</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span>, Cloneable &#123;   <span class="hljs-comment">//首先实现Cloneable接口，表示这个类具有克隆的功能</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age, String sex)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name, age, sex, <span class="hljs-string">&quot;学生&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;   <span class="hljs-comment">//提升clone方法的访问权限</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();   <span class="hljs-comment">//因为底层是C++实现，我们直接调用父类的实现就可以了</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我会学习！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们来尝试一下，看看是不是会得到一个一模一样的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;  <span class="hljs-comment">//这里向上抛出一下异常，还没学异常，所以说照着写就行了</span><br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (Student) student.clone();   <span class="hljs-comment">//调用clone方法，得到一个克隆的对象</span><br>    System.out.println(student);<br>    System.out.println(clone);<br>    System.out.println(student == clone);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><p><img src="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png" alt="image-20220922110044636"></p><p>通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。</p><p><strong>注意：</strong> 以下内容为选学内容，在设计模式篇视频教程中有详细介绍。</p><blockquote><p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p><ul><li><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。 </li><li><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p>那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">clone</span> <span class="hljs-operator">=</span> (Student) student.clone();<br>    System.out.println(student.name == clone.name);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png" alt="image-20220922110750697"></p><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><h3 id="Java-8-接口默认和静态方法"><a href="#Java-8-接口默认和静态方法" class="headerlink" title="(Java 8) 接口默认和静态方法"></a>(Java 8) 接口默认和静态方法</h3><p>从Java8开始，接口中可以存在方法的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//使用default关键字为接口中的方法添加默认实现</span><br>        System.out.println(<span class="hljs-string">&quot;我是默认实现&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p>在之前接口中不允许存在任何实现的方法和和变量，从Java8开始，这些限制同样也放宽了，虽然还是不支持直接像抽象类那样写成员变量，但是静态变量和静态方法是可以写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;   <span class="hljs-comment">//接口中定义的静态变量可以是public static final的</span><br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;    <span class="hljs-comment">//接口中定义的静态方法只能是public的</span><br>        System.out.println(<span class="hljs-string">&quot;我是静态方法&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(Study.a);<br>    Study.test();<br>&#125;<br></code></pre></td></tr></table></figure><p>有了这些特性之后，接口似乎变得也不是那么完全纯粹的抽象了。</p><h3 id="Java-9-接口中的private方法"><a href="#Java-9-接口中的private方法" class="headerlink" title="(Java 9) 接口中的private方法"></a>(Java 9) 接口中的private方法</h3><p>Java8为接口提供的默认方法和静态方法虽然已经很方便，但是有些时候我们可能希望接口中有一些不愿意暴露出去的私有实现，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我要狠狠学习&quot;</span>);<br>        inner();   <span class="hljs-comment">//调用内部私有操作</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是由于接口中只能存在<code>public</code>的方法，这种需要内部封装的操作就无法实现，从Java9开始，接口中允许存在<code>private</code>访问权限的方法，此方法仅用于被默认方法使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我要狠狠学习&quot;</span>);<br>        inner();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//Java 9开始支持使用private声明了，仅供接口内部使用</span><br>        System.out.println(<span class="hljs-string">&quot;我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，包括静态方法在内，也可以使用<code>private</code>访问权限进行声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Study</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我要狠狠学习&quot;</span>);<br>        inner();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inner</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是私有的内部实现，不要让外部直接访问我，我不想让别人知道我私底下怎么学习的&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在外面使用接口对应的对象时，跟类一样无法访问到私有成员。</p><hr><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Study</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String status;   <span class="hljs-comment">//状态，可以是跑步、学习、睡觉这三个之中的其中一种</span><br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> status;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(String status)</span> &#123;<br>        <span class="hljs-built_in">this</span>.status = status;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;   <span class="hljs-comment">//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样</span><br>    RUNNING, STUDY, SLEEP;    <span class="hljs-comment">//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举类也非常方便，就像使用普通类型那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Status status;   <span class="hljs-comment">//类型变成刚刚定义的枚举类</span><br><br><span class="hljs-keyword">public</span> Status <span class="hljs-title function_">getStatus</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatus</span><span class="hljs-params">(Status status)</span> &#123;<br>    <span class="hljs-built_in">this</span>.status = status;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，别人在使用时，就能很清楚地知道我们支持哪些了：</p><p><img src="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png" alt="image-20220922111426974"></p><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这里使用javap命令对class文件进行反编译得到 Compiled from &quot;Status.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.test.Status <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status RUNNING;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status STUDY;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> com.test.Status SLEEP;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status[] values();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> com.test.Status <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;<br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Status</span> &#123;<br>    RUNNING(<span class="hljs-string">&quot;睡觉&quot;</span>), STUDY(<span class="hljs-string">&quot;学习&quot;</span>), SLEEP(<span class="hljs-string">&quot;睡觉&quot;</span>);   <span class="hljs-comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;    <span class="hljs-comment">//枚举的成员变量</span><br>    Status(String name)&#123;    <span class="hljs-comment">//覆盖原有构造方法（默认private，只能内部使用！）</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//获取封装的成员变量</span><br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，枚举就可以按照我们想要的中文名称打印了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;男&quot;</span>);<br>    student.setStatus(Status.RUNNING);<br>    System.out.println(student.getStatus().getName());<br>&#125;<br></code></pre></td></tr></table></figure><p>枚举类还自带一些继承下来的实用方法，比如获取枚举类中的所有枚举，只不过这里用到了数组，我们会在下一章进行介绍。</p><h3 id="Java-16-记录类型"><a href="#Java-16-记录类型" class="headerlink" title="(Java 16) 记录类型"></a>(Java 16) 记录类型</h3><p>在Java 14中，官方重磅推出了一种全新的类型，叫做<strong>记录类型</strong>，它专用于一些保存不可变的数据的类。记录类需要使用<code>record</code>而非<code>class</code>关键字声明，我们可以在IDEA中创建一个记录类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TestData</span><span class="hljs-params">()</span> &#123;   <span class="hljs-comment">//记录类型的写法与普通类也不太一样，类名后面需要带一个括号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>记录类型与前面说的枚举类型类似，本质上在编译之后也是一个普通的类，不过是final且继承自<code>java.lang.Record</code>抽象类的，它会在编译时，会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法。</p><p>要为记录类型添加成员变量，我们可以直接在类型名称后面的括号中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TestData</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String string)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 类中是可以自由编写方法的，和普通class一样，但是有些特殊方法会自动生成，下面会提到。</p><p>接着，我们可以像使用普通类一样，创建这个记录类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestData</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br></code></pre></td></tr></table></figure><p>乍一看好像没啥区别，别急，我们看看它内置了些什么方法：</p><p><img src="https://s2.loli.net/2025/07/08/MXnHf92ACcOojDR.png" alt="image-20250708222002003"></p><p>可以看到，它本身直接自带了获取内部成员数据的同名方法。我们再来尝试打印一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestData</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(data);<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/08/YpmUV7uZlwnezEr.png" alt="image-20250708222100663"></p><p>其中<code>toString()</code>方法也自动帮我们重写成了打印数据的样子。包括对其数据的比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TestData</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestData</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-type">TestData</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestData</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(data1.equals(data2));<br></code></pre></td></tr></table></figure><p>可以看到<code>equals</code>方法也自动重写了，并且是自动比较我们设置的成员。如果我们不需要它的默认实现，也可以直接对其方法进行手动重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TestData</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String string)</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以这种类型就是专门为了承载数据的类而生的。此外，记录类型也可以像普通类那样去实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TestData</span><span class="hljs-params">(<span class="hljs-type">int</span> number, String string)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是无法继承，因为前面说了，默认自动继承<code>java.lang.Record</code>抽象类。注意，记录类型在Java 16中才实装，在Java 17中才能作为局部内部类（下一章介绍）编写。</p><h3 id="Java-17-密封类型"><a href="#Java-17-密封类型" class="headerlink" title="(Java 17) 密封类型"></a>(Java 17) 密封类型</h3><p>密封类型可以说是Java 17正式推出的又一重磅类型，它在Java 15首次提出并测试了两个版本。</p><p>我们之前介绍过，类可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p><p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;   <span class="hljs-comment">//添加final关键字后，不允许对此类继承</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，这时该咋写？在Java 17之前想要实现就很麻烦。</p><p>但是现在我们可以使用密封类型来实现这个功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">permits</span> B&#123;   <br><span class="hljs-comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>密封类型有以下要求：</p><ul><li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li><li>必须有子类继承，且不能是匿名内部类或是lambda的形式（这些内容会在下一章介绍）</li><li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li><li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li></ul><p>标准的声明格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> [<span class="hljs-keyword">abstract</span>] [class/interface] 类名 [extends 父类] [implements 接口, ...] <span class="hljs-keyword">permits</span> [子类, ...]&#123;<br><span class="hljs-comment">//里面的该咋写咋写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意子类格式必须为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> [<span class="hljs-keyword">final</span>/<span class="hljs-keyword">sealed</span>/<span class="hljs-keyword">non-sealed</span>] class 子类 extends 父类 &#123;   <span class="hljs-comment">//必须继承自父类</span><br><span class="hljs-comment">//final类型：任何类不能再继承当前类，到此为止，已经封死了。</span><br>  <span class="hljs-comment">//sealed类型：同父类，需要指定由哪些类继承。</span><br>  <span class="hljs-comment">//non-sealed类型：重新开放为普通类，任何类都可以继承。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们写了这些类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <span class="hljs-keyword">permits</span> B&#123;   <span class="hljs-comment">//指定B继承A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;   <span class="hljs-comment">//在子类final，彻底封死</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到其他的类无论是继承A还是继承B都无法通过编译：</p><p><img src="https://s2.loli.net/2025/07/08/VXtiNou3vjrCkw2.png" alt="image-20250708223238812"></p><p><img src="https://s2.loli.net/2025/07/08/yPdlXTWUmztnhY1.png" alt="image-20250708223246820"></p><p>但是如果此时我们主动将B设定为<code>non-sealed</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">non-sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以正常继承了，因为B指定了<code>non-sealed</code>主动放弃了密封特性，这样就显得非常灵活了。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/eldst1fgrbdkmfs7">https://www.itbaima.cn/zh-CN/document/eldst1fgrbdkmfs7</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（二）面向过程编程</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/07/07/Bw79W6q8zEyXmUR.png" alt="image-20250707174514052"></p><h1 id="面向过程篇"><a href="#面向过程篇" class="headerlink" title="面向过程篇"></a>面向过程篇</h1><p>前面我们已经认识了Java语言的相关特性，并且已经成功配置好了开发环境，从这节课开始，我们就可以正式进入到Java语言的学习当中了。Java语言是一门面向对象的语言，但是在面向对象之前，我们还得先学会如何面向过程编程。</p><h2 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h2><p>首先我们还是从最基本的Java程序基础开始讲解。</p><h3 id="程序代码基本结构"><a href="#程序代码基本结构" class="headerlink" title="程序代码基本结构"></a>程序代码基本结构</h3><p>还记得我们之前使用的示例代码吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码要实现的功能很简单，就是将 Hello World 输出到控制台就行。</p><p>由于我们还没有学习到类的相关性质，所以在第二章之前，各位小伙伴直接记住固定模式即可，首先我们创建的源文件名称需要为<code>Main.java</code>然后编写的代码第一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>注意需要区分大小写，Java语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：</p><p><img src="https://s2.loli.net/2022/09/16/5mpBD1JyjCMGgnO.png" alt="image-20220916213529426"></p><p>只要源代码中存在报错的地方，就无法正常完成编译得到二进制文件，会提示构建失败：</p><p><img src="https://s2.loli.net/2022/09/16/x5PjR9OAGMCQtS6.png" alt="image-20220916213641899"></p><p>注意最后还有一个花括号，并且此花括号是成对出现的，一一对应。</p><p>所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这是我们整个Java程序的入口点，我们称为主方法（如果你学习过C肯定能够联想到主函数，只不过Java中不叫函数，叫方法）最后也会有一个花括号成对出现，而在主方法的花括号中编写的代码，就是按照从上往下的顺序依次执行的。</p><p>比如我们之前编写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><p>这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上，可以看到最后还加上了一个<code>;</code>符号，表示这一句代码结束。我们每一段代码结束时都需要加上一个分号表示这一句的结束，就像我们写作文一样。</p><p>比如下面的代码，我们就可以实现先打印Hello World!，然后再打印YYDS!到控制台。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;YYDS!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://s2.loli.net/2022/09/16/GLZdxf6B3Agu98N.png" alt="image-20220916214557378"></p><p>如果两段代码没有加上分号分割，那么编译器会认为这两段代码是同一句代码中的，即使出现换行或者是空格：</p><p><img src="https://s2.loli.net/2022/09/16/ErQnpo2DVw7mJks.png" alt="image-20220916214736541"></p><p>这里IDEA很聪明，会提醒我们这里少加了分号，所以说这个IDEA能够在初期尽可能地帮助新手。</p><p>再比如下面的代码：</p><p><img src="https://s2.loli.net/2022/09/16/sDcuan8MJ92l3P1.png" alt="image-20220916214822072"></p><p><img src="https://s2.loli.net/2022/09/16/i1VFk6RUtp8XfMr.png" alt="image-20220916214929651"></p><p>这里我们尝试在中途换行和添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意进行换行编写或者是添加没必要的空格。</p><p>同样的，如果添加了分号，即使在同一行，也会被认为是两句代码：</p><p><img src="https://s2.loli.net/2022/09/16/XopC59keJiMWjmd.png" alt="image-20220916221833145"></p><p>如果在同一行就是从左往右的顺序，得到的结果跟上面是一样的。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思：</p><p><img src="https://s2.loli.net/2022/09/16/8Mzo36BbYVuRgm9.png" alt="image-20220916221711430"></p><p>但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。</p><p>这种情况，我们就可以告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了：</p><p><img src="https://s2.loli.net/2022/09/16/N4rZHt6onGfXuhg.png" alt="image-20220916222035778"></p><p>添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了：</p><p><img src="https://s2.loli.net/2022/09/16/GiUMCmXewanWJSN.png" alt="image-20220916222225047"></p><p>那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            这里面的内容</span><br><span class="hljs-comment">            无论多少行</span><br><span class="hljs-comment">            都可以</span><br><span class="hljs-comment">         */</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多行可以使用<code>/*</code>和<code>*/</code>的组合来囊括需要编写的注释内容。</p><p>当然还有一种方式就是使用<code>/**</code>来进行更加详细的文档注释：</p><p><img src="https://s2.loli.net/2022/09/16/sFhkS2ezONjZvMK.png" alt="image-20220916222636943"></p><p>这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。</p><p>当然，如果你更喜欢编写Markdown格式的注释，在Java 23之后，我们也可以使用三斜杠来表示这是一个Markdown格式的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/// # 这个是主类</span><br><span class="hljs-comment">/// - 主类是执行程序的入口</span><br><span class="hljs-comment">/// - 主类里面有主方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123; <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/07/09/yJCnG2o1KEe3dZq.png" alt="image-20250709184634286"></p><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><p>我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。</p><p>那么，什么是变量呢？我们在数学中其实已经学习过变量了：</p><blockquote><p>变量，指值可以变的量。变量以非<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97/6204?fromModule=lemma_inlink">数字</a>的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。</p></blockquote><p>比如一个公式 $x^2 + 6 &#x3D; 22$ 此时<code>x</code>就是一个变量，变量往往代表着某个值，比如这里的<code>x</code>就代表的是4这个值。在Java中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的。</p><p>要声明一个变量，我们需要使用以下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[数据类型] [变量名称];<br></code></pre></td></tr></table></figure><p>这里的数据类型我们会在下节课开始逐步讲解，比如整数就是<code>int</code>类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像<code>x</code>一样，这个名称我们可以随便起一个，但是注意要满足以下要求：</p><ul><li>标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。</li><li>不能有空格、@、#、+、-、&#x2F; 等符号。</li><li>应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。</li><li>不可以是 true 和 false。</li><li>不能与Java语言的关键字或是基本数据类型重名，关键字列表如下：</li></ul><p><img src="https://s2.loli.net/2023/03/01/I6nCh49qzyvoZBm.png" alt="image-20230301113525814"></p><p>当然各位小伙伴没必要刻意去进行记忆，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如：</p><p><img src="https://s2.loli.net/2022/09/16/qtsjIhSGQoxBYVM.png" alt="image-20220916224129597"></p><p>深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。</p><p> 比如现在我们想要定义一个变量<code>a</code>，那么就可以这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> a;    <span class="hljs-comment">//声明一个整数类型变量a</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;   <span class="hljs-comment">//直接在定义变量后面添加 = 10，表示这个变量的初始值为10，这里的10就是一个常量数字</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以在使用时再对其进行赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//使用时再赋值也可以</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。</p><p>我们可以一次性定义多个变量，比如现在我们想定义两个<code>int</code>类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> a, b;   <span class="hljs-comment">//定义变量a和变量b，中间使用逗号隔开就行了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者两个变量单独声明也可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> a;   <span class="hljs-comment">//分两句进行声明</span><br>    <span class="hljs-type">int</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;<br>    System.out.println(a);    <span class="hljs-comment">//之前我们在小括号写的是&quot;&quot;，现在我们直接将变量给进去就可以打印变量的值了</span><br>  System.out.println(<span class="hljs-number">888</span>);   <span class="hljs-comment">//甚至直接输出一个常量值都可以</span><br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果：</p><p><img src="https://s2.loli.net/2022/09/16/3nUAHINdXMmlxvJ.png" alt="image-20220916225037221"></p><p>变量的值也可以在中途进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;<br>    a = <span class="hljs-number">777</span>;<br>    System.out.println(a);   <span class="hljs-comment">//这里打印得到的值就是777了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量的值也可以直接指定为其他变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;   <span class="hljs-comment">//直接让b等于a，那么a的值就会给到b</span><br>    System.out.println(b);   <span class="hljs-comment">//这里输出的就是10了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;   <span class="hljs-comment">//a初始值为9</span><br>    a = a + <span class="hljs-number">1</span>;   <span class="hljs-comment">//a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧</span><br>    System.out.println(a);   <span class="hljs-comment">//最后得到的结果就是10了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有时候我们希望变量的值一直保持不变，我们就可以将其指定为常量，这里我们介绍Java中第一个需要认识的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;   <span class="hljs-comment">//在变量前面添加final关键字，表示这是一个常量</span><br>    a = <span class="hljs-number">777</span>;    <span class="hljs-comment">//常量的值不允许发生修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译时出现：</p><p><img src="https://s2.loli.net/2022/09/16/kT46yi8KNOLWlp3.png" alt="image-20220916225429474"></p><p>常量的值只有第一次赋值可以修改，其他任何情况下都不行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>    a = <span class="hljs-number">777</span>;   <span class="hljs-comment">//第一次赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Java的基础语法部分介绍完毕，下一部分我们将开始介绍Java中的几大基本数据类型。</p><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们的程序中可能需要表示各种各样的数据，比如整数、小数、字符等等，这一部分我们将探索Java中的八大基本数据类型。只不过在开始之前，我们还需要先补充一点简单的计算机小知识。</p><h3 id="计算机中的二进制表示"><a href="#计算机中的二进制表示" class="headerlink" title="计算机中的二进制表示"></a>计算机中的二进制表示</h3><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>111 &#x3D; 7</p><p>注意这里的bit跟我们生活中的网速MB&#x2F;s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit &#x3D; 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100&#x2F;8 &#x3D; 12.5 MB&#x2F;s了。</p><blockquote><p>十进制的7 -&gt; 在二进制中为 111 &#x3D; 2^2 + 2^1 + 2^0</p></blockquote><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 &#x3D;&gt; 0</li><li>最大：1111 &#x3D;&gt; 23+22+21+20 &#x3D;&gt; 8 + 4 + 2 + 1 &#x3D; 15</li></ul><p>在Java中，无论是小数还是整数，他们都要带有符号（和C语言不同，C语言有无符号数）所以，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 &#x3D;&gt; -(22+21+2^0) &#x3D;&gt; -7</li><li>最大：0111 &#x3D;&gt; +(22+21+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p></blockquote><p>我们得创造一种更好的表示方式！于是我们引入了<strong>反码</strong>：</p><ul><li>正数的反码是其原码本身 </li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 （直接相加，这样就简单多了！）</p></blockquote><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li><li>对补码再求一次补码就可得该补码对应的原码。</li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 （现在无论你怎么算，也不会有-0了！）</p></blockquote><p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Java使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。</p><h3 id="老鼠试药问题"><a href="#老鼠试药问题" class="headerlink" title="老鼠试药问题"></a>老鼠试药问题</h3><p>现在实验室有1000瓶药水，其中999瓶是无毒的，只有1瓶是有毒的，但是从外观上看无法分辨。喝下毒药的小白鼠，在一星期后会突然死亡，但在这之前一点症状都没有。现在需要你能够在一星期之后找出哪一瓶是毒药，请问至少需要多少只小白鼠参与实验？</p><p>这个问题可以转化为二进制编码问题。</p><ul><li><strong>每一瓶药水用一个唯一的二进制编号</strong>，编号范围从1到1000（共1000瓶）</li><li><strong>每只小白鼠对应二进制中的一位</strong>。</li><li><strong>设计实验</strong>：每只小白鼠喝那些在其对应位为1的编号的药水。</li></ul><p><img src="https://s2.loli.net/2025/07/08/o9SlyRZKm8HjMAp.png" alt="image-20250708114912279"></p><p>由于药水只喂给了对应二进制位置为1的小白鼠，一周后，哪些位置上的小白鼠死了，那么其对应的十进制编号的药水就是毒药了。比如2、3号小白鼠死亡，其二进制为 0 0 0 0 0 0 0 1 1 0 对应的十进制数字为 6，判定6号药水有毒。</p><h3 id="整数类形"><a href="#整数类形" class="headerlink" title="整数类形"></a>整数类形</h3><p>整数类型是最容易理解的类型！既然我们知道了计算机中的二进制数字是如何表示的，那么我们就可以很轻松的以二进制的形式来表达我们十进制的内容了。</p><p>在Java中，整数类型包括以下几个：</p><ul><li>byte 字节型 （8个bit，也就是1个字节）范围：-128~+127</li><li>short 短整形（16个bit，也就是2个字节）范围：-32768~+32767</li><li>int 整形（32个bit，也就是4个字节）最常用的类型：-2147483648 ~ +2147483647</li><li>long 长整形（64个bit，也就是8个字节）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><p>这里我们来使用一下，其实这几种变量都可以正常表示整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为都可以表示整数，所以说我们可以将小的整数类型值传递给大的整数类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;   <span class="hljs-comment">//小的类型可以直接传递给表示范围更大的类型</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>反之会出现报错：</p><p><img src="https://s2.loli.net/2022/09/16/NLZlDgxz3ci5Idr.png" alt="image-20220916231650085"></p><p>这是由于我们在将小的整数类型传递给大的整数类型时发生了<strong>隐式类型转换</strong>，只要是从存储范围小的类型到存储范围大的类型，都支持隐式类型转换，它可以自动将某种类型的值，转换为另一种类型，比如上面就是将short类型的值转换为了int类型的值。</p><p>隐式类型转换不仅可以发生在整数之间，也可以是其他基本数据类型之间，我们后面会逐步介绍。</p><p>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照<code>long</code>类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是<code>int</code>类型，这么大肯定是表示不下的，如果需要将其表示为一个long类型的常量数字，那么需要在后面添加大写或是小写的<code>L</code>才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">922337203685477580L</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>   <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1_000_000</span>;    <span class="hljs-comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以以8进制或是16进制表示一个常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">0xA</span>);<br>    System.out.println(<span class="hljs-number">012</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>十六进制：</strong> 以<code>0x</code>开头的都是十六进制表示法，十六进制满16进一，但是由于我们的数学只提供了0-9这十个数字，10、11、12…15该如何表示呢，我们使用英文字母A按照顺序开始表示，A表示10、B表示11…F表示15。比如上面的0xA实际上就是我们十进制中的10。</li><li><strong>八进制：</strong> 以0开头的都是八进制表示法，八进制就是满8进一，所以说只能使用0-7这几个数字，比如上面的012实际上就是十进制的10。</li></ul><p>我们最后再来看一个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2147483647</span>;   <span class="hljs-comment">//int最大值</span><br>    a = a + <span class="hljs-number">1</span>;   <span class="hljs-comment">//继续加</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时a的值已经来到了<code>int</code>类型所能表示的最大值了，那么如果此时再继续<code>+1</code>，各位小伙伴觉得会发生什么？可以看到结果很奇怪：</p><p><img src="https://s2.loli.net/2022/09/16/YztefPIvLE6y94u.png" alt="image-20220916234540720"></p><p>什么情况？？？怎么正数加1还变成负数了？请各位小伙伴回想一下我们之前讲解的原码、反码和补码。</p><p>我们先来看看，当int为最大值时，二进制表示形式为什么：</p><ul><li>2147483647 &#x3D; 01111111 11111111 11111111 11111111（第一个是符号位0，其他的全部为1，就是正数的最大值）</li></ul><p>那么此时如果加1，会进位成：</p><ul><li>10000000 00000000 00000000 00000000</li></ul><p>各位想一想，符号位为1，那么此时表示的不就是一个负数了吗？我们回想一下负数的补码表示规则，瞬间就能明白了，这不就是补码形式下的最小值了吗？</p><p>所以说最后的结果就是<code>int</code>类型的最小值：-2147483648，是不是感觉了解底层原理会更容易理解这是为什么。</p><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>前面我们介绍了整数类型，我们接着来看看浮点类型，在Java中也可以轻松地使用小数。</p><p>首先来看看Java中的小数类型包含哪些：</p><ul><li>float 单精度浮点型 （32bit，4字节）</li><li>double 双精度浮点型（64bit，8字节）</li></ul><p>那么小数在计算机中又是如何存放的呢？</p><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：<br>$$<br>V &#x3D; (-1)^S \times M \times 2^E<br>$$</p><ul><li>$(-1)^S$ 表示符号位，当 S&#x3D;0，V 为正数；当 S&#x3D;1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为1111010，那么M实际上就是1.111010，尾数首位必须是1，1后面紧跟小数点，如果出现0001111这样的情况，去掉前面的0，移动1到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为1，故为了能够存放更多数据，就舍去了第一位，比如保存1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>$2^E$ 表示指数位（用于移动小数点，所以说才称为浮点型），指数默认存储需要添加127的偏移量，便于同时处理正负指数的情况。</li></ul><p>比如， 对于十进制的 5.25 对应的二进制为：101.01，相当于：$1.0101 \times 2^2$。所以，S 为 0，M 为 0101，E 为 2。因此，对于浮点类型，最大值和最小值不仅取决于符号和尾数，还有它的阶码，所以浮点类型的大致取值范围：</p><ul><li>单精度：$±3.40282347 \times 10^{38}$</li><li>双精度：$±1.79769313486231570 \times 10^{308}$</li></ul><p>我们可以直接创建浮点类型的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.5</span>, b = <span class="hljs-number">66</span>;   <span class="hljs-comment">//整数类型常量也可以隐式转换到浮点类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的F来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.9F</span>;   <span class="hljs-comment">//这样就可以正常编译通过了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是反之，由于<code>double</code>精度更大，所以说可以直接接收<code>float</code>类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">9.9F</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> f;    <span class="hljs-comment">//隐式类型转换为double值</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>只不过由于精度问题，最后的打印结果：</p><p><img src="https://s2.loli.net/2022/09/17/1JqHY2so6Qwz4WX.png" alt="image-20220917105849862"></p><p>这种情况是正常的，因为浮点类型并不保证能够精确计算，我们会在下一章介绍 BigDecimal 和 BigInteger，其中BigDecimal更适合需要精确计算的场景。</p><p>我们最后来看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">21731371236768L</span>;<br>    <span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> l;   <span class="hljs-comment">//这里能编译通过吗？</span><br>    System.out.println(f);<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们发现，<code>long</code>类型的值居然可以直接丢给<code>float</code>类型隐式类型转换，很明显<code>float</code>只有32个bit位，而<code>long</code>有足足64个，这是什么情况？怎么大的还可以隐式转换为小的？这是因为虽然<code>float</code>空间没有那么大，但是由于是浮点类型，指数可以变化，最大的数值表示范围实际上是大于<code>long</code>类型的，虽然会丢失精度，但是确实可以表示这么大的数。</p><p>所以说我们来总结一下隐式类型转换规则：byte→short(char)→int→long→float→double</p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li></ul><p>可以看到char类型依然存储的是数字，那么它是如何表示每一个字符的呢？实际上每个数字在计算机中都会对应一个字符，首先我们需要介绍ASCII码：</p><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，所以说当char为65时，打印出来的结果就是大写的字母A了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">65</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/dvizHYa2fCOKhA3.png" alt="image-20220917110854266"></p><p>或者我们也可以直接写一个字符常量值赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;    <span class="hljs-comment">//字符常量值需要使用单引号囊括，并且内部只能有一个字符</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法效果与上面是一样的。</p><p>不过，我们回过来想想，这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文。这时，我们就需要扩展字符集了。</p><blockquote><p>我们可以使用两个甚至多个字节来表示一个中文字符，这样我们能够表示的数量就大大增加了，GB2132方案规定当连续出现两个大于127的字节时（注意不考虑符号位，此时相当于是第一个bit位一直为1了），表示这是一个中文字符（所以为什么常常有人说一个英文字符占一字节，一个中文字符占两个字节），这样我们就可以表示出超过7000种字符了，不仅仅是中文，甚至中文标点、数学符号等，都可以被正确的表示出来。</p><p>不过这样能够表示的内容还是不太够，除了那些常见的汉字之外，还有很多的生僻字，比如龘、錕、釿、拷这类的汉字，后来干脆直接只要第一个字节大于127，就表示这是一个汉字的开始，无论下一个字节是什么内容（甚至原来的128个字符也被编到新的表中），这就是Windows至今一直在使用的默认GBK编码格式。</p><p>虽然这种编码方式能够很好的解决中文无法表示的问题，但是由于全球还有很多很多的国家以及很多很多种语言，所以我们的最终目标是能够创造一种可以表示全球所有字符的编码方式，整个世界都使用同一种编码格式，这样就可以同时表示全球的语言了。所以这时就出现了一个叫做ISO的（国际标准化组织）组织，来定义一套编码方案来解决所有国家的编码问题，这个新的编码方案就叫做Unicode（准确的说应该是规定的字符集，包含了几乎全世界所有语言的字符），规定每个字符必须使用两个字节，即用16个bit位来表示所有的字符（也就是说原来的那128个字符也要强行用两位来表示）</p><p>但是这样的话实际上是很浪费资源的，因为这样很多字符都不会用到两字节来保存，肯定不能直接就这样去表示，这会导致某些字符浪费了很多空间，我们需要一个更加好用的具体的字符编码方式。所以最后就有了UTF-8编码格式（它是Unicode字符集的一个编码规则），区分每个字符的开始是根据字符的高位字节来区分的，比如用一个字节表示的字符，第一个字节高位以“0”开头；用两个字节表示的字符，第一个字节的高位为以“110”开头，后面一个字节以“10开头”；用三个字节表示的字符，第一个字节以“1110”开头，后面俩字节以“10”开头；用四个字节表示的字符，第一个字节以“11110”开头，后面的三个字节以“10”开头：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10000011 </span><span class="hljs-number">10000110</span>    //这就是一个连续出现都大于<span class="hljs-number">127</span>的字节（注意这里是不考虑符号位的）<br></code></pre></td></tr></table></figure><p>所以如果我们的程序需要表示多种语言，最好采用UTF-8编码格式，它最多可以表示4个字节的内容。随着编码规则的演进，后来又有了UTF-16编码格式，采用BMP字符节省空间，它大量对于中文字符的应用效果更好，Java在运行时采用的就是UTF-16，几乎全世界的语言用到的字符都可以表示出来。</p></blockquote><table><thead><tr><th>Unicode符号范围（十六进制）</th><th>UTF-8编码方式(二进制)</th></tr></thead><tbody><tr><td>0000 0000 ~ 0000 007F</td><td>0xxxxxxx</td></tr><tr><td>0000 0080 ~ 0000 07FF</td><td>110xxxxx 10xxxxxx</td></tr><tr><td>0000 0800 ~ 0000 FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr><tr><td>0001 0000 ~ 0010 FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr></tbody></table><p><strong>注意：</strong> Unicode 是“字符集”，也就是有哪些字符，而UTF-8、UTF-16 是“编码规则”，也就是怎么对这些字符编码，怎么以二进制的形式保存，千万不要搞混了。</p><p>简而言之，char实际上需要两个字节才能表示更多种类的字符，所以，<code>char</code>类型可以直接表示一个中文字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;淦&#x27;</span>;   <span class="hljs-comment">//使用int类型接收字符类型常量值可以直接转换为对应的编码</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/ZgzMUafmYAKoOXt.png" alt="image-20220917111838629"></p><p>Java程序在编译为<code>.class</code>文件之后，会采用UTF-8的编码格式，支持的字符也非常多，所以你甚至可以直接把变量名写成中文，依然可以编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/vAnPCgx5ThEUBHe.png" alt="image-20220917112033102"></p><p>介绍完了字符之后，我们接着来看看字符串，其实字符串我们在一开始就已经接触到了。字符虽然可以表示一个中文，但是它没办法表示多个字符：</p><p><img src="https://s2.loli.net/2022/09/17/JmdQkSw2qc4ZTuW.png" alt="image-20220917114628564"></p><p>但是实际上我们使用率最高的还是多个字符的情况，我们需要打印一连串的字符。这个时候，我们就可以使用字符串了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;啊这&quot;</span>;    <span class="hljs-comment">//字符串需要使用双引号囊括，字符串中可以包含0-N个字符</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这里使用的类型是<code>String</code>类型，这种类型并<strong>不是基本数据类型</strong>，它是对象类型，我们会在下一章继续对其进行介绍，这里我们只需要简单了解一下就可以了。</p><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>布尔类型是Java中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;   <span class="hljs-comment">//值只能是true或false</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果给一个其他的值，会无法编译通过：</p><p><img src="https://s2.loli.net/2022/09/17/1TtJdKcvRWPfAI2.png" alt="image-20220917115424504"></p><p>至此，基本数据类型的介绍就结束了。</p><h3 id="Java-10-局部变量类型推断"><a href="#Java-10-局部变量类型推断" class="headerlink" title="(Java 10) 局部变量类型推断"></a>(Java 10) 局部变量类型推断</h3><p>Java 10 引入了 <code>var</code> 关键字，可以在局部变量声明时自动推断变量类型，从而简化代码。</p><p>例如我们现在想要创建一个整形变量，我们之前是这样编写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//如果需要改成其他类型，前面的int也得跟着改</span><br></code></pre></td></tr></table></figure><p>在Java10之后，我们可以使用<code>var</code>关键字来根据后面的结果自动识别类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>此时，无论我们修改后面的变量值为什么类型的值，都可以自动进行推断：</p><p><img src="https://s2.loli.net/2025/07/07/JKZYc2uUHswqhEF.png" alt="image-20250707180952852"></p><p>实际上这个特性很多语言都有，Java选择在Java10才上线此功能，有点为时已晚。由于Java社区普遍较为保守，很多开发者在刚推出时倾向于继续使用显式类型声明，特别是在代码稳定性和可读性方面。所以，这种用法在很多项目里面并不常见，这里只做了解即可。</p><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>前面我们介绍了多种多样的基本数据类型，但是光有这些基本数据类型还不够，我们还需要让这些数据之间进行运算，才可以真正意义上发挥计算机的作用。</p><p>要完成计算，我们需要借助运算符来完成，实际上我们在数学中就已经接触过多种多样的运算符了。</p><blockquote><p>比如：+   -    ×    ÷</p></blockquote><p>这些运算符都是我们在初等数学中学习的，而使用规则也很简单，我们只需要将需要进行运算的两个数放到运算符的两边就可以了：</p><blockquote><p>比如：10 ÷ 2</p></blockquote><p>上面运算的结果就是5了，而在Java中，我们同样可以使用这样的方式来进行运算。</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>首先我们还是来回顾一下之前认识的老朋友：赋值运算符。</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">666</span>;   <span class="hljs-comment">//使用等号进行赋值运算</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用规则为：</strong> 赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p><p>当然，赋值运算符并不只是单纯的赋值，它是有结果的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a = <span class="hljs-number">777</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当出现连续使用赋值运算符时，按照从右往左的顺序进行计算，首先是<code>a = 777</code>，计算完成后，a的值就变成了777，计算完成后，会得到计算结果（赋值运算的计算结果就是赋的值本身，就像1 + 1的结果是2一样，a &#x3D; 1的结果就是1）此时继续进行赋值计算，那么b就被赋值为<code>a = 777</code>的计算结果，同样的也是 777 了。</p><p>所以，使用连等可以将一连串变量都赋值为最右边的值。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算符也就是我们初等数学中认识的这些运算符，包括加减乘除，当然Java还支持取模运算，算术运算同样需要左右两边都有一个拿来计算的目标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到a赋值为1+1的结果，所以说最后a就是2了。</p><p>当然变量也是可以参与到算术运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a - <span class="hljs-number">10</span>;<br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>不同类型之间也可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;   <br>  <span class="hljs-comment">//使用整数进行运算，小类型需要转换为大类型，short、byte、char一律转换为int再进行计算（无论算式中有无int，都会自动转换）结果也是int；如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为运算时会发生隐式类型转换，所以说这里b自动转换为了int类型进行计算，所以说最后得到结果也一定是转换后的类型：</p><p><img src="https://s2.loli.net/2022/09/17/KovME45pl2sPiBN.png" alt="image-20220917141359260"></p><p>小数和整数一起计算同样会发生隐式类型转换：</p><p><img src="https://s2.loli.net/2022/09/17/jxW3KfwBACidyMY.png" alt="image-20220917141955891"></p><p>因为小数表示范围更广，所以说整数会被转换为小数再进行计算，而最后的结果也肯定是小数了。</p><p>我们也可以将加减号作为正负符号使用，比如我们现在需要让a变成自己的相反数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    a = -a;   <span class="hljs-comment">//减号此时作为负号运算符在使用，会将右边紧跟的目标变成相反数</span><br>    System.out.println(a);   <span class="hljs-comment">//这里就会得到-10了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，正号也可以使用，但是似乎没什么卵用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    a = +a;   <span class="hljs-comment">//正号本身在数学中就是可以省略的存在，所以Java中同样如此</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意加法支持对字符串的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;伞兵&quot;</span> + <span class="hljs-string">&quot;lbw&quot;</span>;   <span class="hljs-comment">//我们可以使用加号来拼接两个字符串</span><br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后这个字符串就变成了拼接后的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/TeUCBM9ZzINuoa8.png" alt="image-20220917145901135"></p><p>字符串不仅可以跟字符串拼接，也可以跟基本数据类型拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;伞兵&quot;</span> + <span class="hljs-literal">true</span> + <span class="hljs-number">1.5</span> + <span class="hljs-string">&#x27;A&#x27;</span>;<br>    System.out.println(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后就可以得到对应的结果了：</p><p><img src="https://s2.loli.net/2022/09/17/URJxsgXvzYMQh8t.png" alt="image-20220917150010919"></p><p>当然，除了加减法之外乘除法也是支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">2</span>;<br>    System.out.println(a * b);   <span class="hljs-comment">//乘法使用*表示乘号</span><br>  System.out.println(a / b);   <span class="hljs-comment">//除法就是一个/表示除号</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面是两个int类型的值进行的除法运算，正常情况下8除以5应该得到1.6，但是由于结果也是整数，所以说最后小数部分被丢弃：</p><p><img src="https://s2.loli.net/2022/09/17/TdhHPN64UnyFozq.png" alt="image-20220917141816599"></p><p>但是如果是两个小数一起计算的话，因为结果也是小数，所以说就可以准确得到结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8.0</span>, b = <span class="hljs-number">5.0</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/17/3zjJoeL6bgdRqNA.png" alt="image-20220917142201392"></p><p>同样的，整数和小数一起计算，由于所有的整数范围都比小数小，根据我们上一部分介绍的转换规则，整数和小数一起计算时，所有的整数都会变成小数参与运算，所以说最后的结果也就是小数了，同样可以得到正确的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8.0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    System.out.println(a / b);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么问题来了，现在我们有两个整数需要进行计算，但是我们就是希望可以得到一个小数的结果该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a;   <span class="hljs-comment">//我们可以将其先隐式转换为小数类型，再那转换后的小数变量去参与计算</span><br>    System.out.println(c / b);   <span class="hljs-comment">//同样可以得到正确结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在下一节，我们将介绍强制类型转换，通过使用强制类型转换，我们可以更轻松地让整数计算出小数的结果。</p><p>除了最基本的加减乘除操作，我们也可以进行取模操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    System.out.println(a % <span class="hljs-number">3</span>);   <span class="hljs-comment">//比如这里对a进行取模操作，实际上就是计算除以3的余数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如上面的是 10 % 3 得到的结果就是10除以3最后的余数1，取模操作也是非常好用的。</p><p>比如我们查看某个数是否为双数，只需要将其对2进行取模操作即可，因为如果是双数一定是可以整除的，如果是单数一定会余1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">17</span> % <span class="hljs-number">2</span>);   <span class="hljs-comment">//17不是双数，所以说最后会得到1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，运算符之间是有优先级之分的，比如乘除法优先级高于加减法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">10</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的算式按照数学中的规则，应该先计算3 * 4，然后再进行加法计算，而Java中同样遵循这样的规律。我们来总结一下到目前为止所有学习到的运算符相关性质：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性（出现同优先级运算符时）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">-(负号)  +(正号)</td><td align="center">从右向左</td></tr><tr><td align="center">2</td><td align="center">*   &#x2F;  %</td><td align="center">从左往右</td></tr><tr><td align="center">3</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左往右</td></tr><tr><td align="center">4</td><td align="center">&#x3D;</td><td align="center">从右向左</td></tr></tbody></table><p>比如下面的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a = <span class="hljs-number">8</span> * -a + <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 正负号优先级最高，所有首先计算的是-a，得到-10</span><br><span class="hljs-comment">        2. 其次是乘除号优先级更高，所以说这里计算 8 * -10，得到 -80</span><br><span class="hljs-comment">        3. 然后是加减法，-80 + 10 = -70</span><br><span class="hljs-comment">        4. 最后是赋值运算，因为等号运算符从右往左结合，先算a = -70的结果就是 -70</span><br><span class="hljs-comment">        5. 最后b就是 -70</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过使用这些基本算术运算符，我们就可以更加快速地计算我们想要的结果了。</p><h3 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h3><p>前面我们介绍了算术运算符，我们接着来看括号运算符。</p><p>我们常常在数学中使用括号提升某些运算的优先级，比如：</p><blockquote><p>(1 + 7) × (3 - 6) &#x3D; -24</p></blockquote><p>虽然加法优先级比乘法要低但是我们给其添加括号之后，相当于提升了内部加法运算的优先级，所以说需要先计算括号中的再去计算括号外的，Java同样满足这个要求。</p><p>我们可以通过添加括号的方式来提升某些运算的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (a = <span class="hljs-number">8</span>) * (-a + <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1. 括号的优先级是最高的，我们需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span><br><span class="hljs-comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span><br><span class="hljs-comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span><br><span class="hljs-comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span><br><span class="hljs-comment">     */</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以，通过添加括号，就可以更加灵活的控制计算。</p><p>当然，括号是可以嵌套的，这一点跟数学中也是一样的，只不过我们不需要使用方括号和花括号，一律使用小括号就行了。</p><p>在嵌套的情况下，会优先计算最内层括号中的算式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-number">2</span> + (<span class="hljs-number">3</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>) * <span class="hljs-number">2</span>;<br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里会优先计算 3 + 1的结果，然后由于第二层都在一个括号中，所以说按照正常优先级计算，2 + 4 * 3  &#x3D; 14，最后来到最外层14*2 &#x3D; 28，计算结束。</p><p>括号除了可以用来提升运算优先级，也可以用作<strong>强制类型转换</strong>，前面我们介绍了隐式类型转换，但是隐式类型转换存在局限性，比如此时我们希望将一个大的类型转换为一个小的类型：</p><p><img src="https://s2.loli.net/2022/09/17/En2uzTl5PFgKeNX.png" alt="image-20220917150256987"></p><p>正常情况下无法编译通过，但是实际上a的值并没有超出<code>short</code>的范围，理论上是可以直接给到b存放的，此时我们就可以使用强制类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>) a;   <span class="hljs-comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只不过强制类型转换存在一定的风险，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;   <span class="hljs-comment">//已经超出byte的范围了</span><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>) a;  <span class="hljs-comment">//此时强制类型转换为byte类型，那么只会保留byte能够表示的bit位</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如这里的128：</p><ul><li>00000000 00000000 00000000 10000000  -&gt;  byte只有一个字节，所以说只保留最后8位 -&gt; 10000000</li></ul><p>这里的10000000，由于第一个位置是符号位，导致此时直接变成了byte的最小值：</p><p><img src="https://s2.loli.net/2022/09/17/Kt6rfkYE1HSvNnl.png" alt="image-20220917151028191"></p><p>所以说强制类型转换只有在明确不会出现问题的情况下，才可以使用。当然，强制类型转换也可以用在后面的类中，我们将会在下一章继续探讨。</p><p>有了强制类型转换，我们就可以很轻松地让两个整数计算出小数的结果了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a/(<span class="hljs-type">double</span>)b;  <br>  <span class="hljs-comment">//强制类型转换的优先级跟正负号一样</span><br>  <span class="hljs-comment">//计算时，只需要将其中一者转换为double类型，此时按照隐式类型转换规则，全都会变成double参与运算，所以结果也就是小数了</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>各位思考一下下面的这种情况可以正确得到小数的结果吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>, b = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) (a/b);<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>不能得到，因为括号将a&#x2F;b的运算优先进行了，此时得到的结果已经是一个整数结果，再转换为double毫无意义。</p><p>最后我们还是来总结一下目前遇到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   &#x2F;  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&#x3D;</td><td align="center">从右向左</td></tr></tbody></table><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p><strong>注意：</strong> 这一节很容易搞晕，请务必记清楚顺序！</p><p>有时候我们可能需要让变量自己进行增加操作，比如我们现在想要进行跳绳计数，每转动一圈，计数+1，当我们想要对一个变量进行这样的自增操作时，可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a = a + <span class="hljs-number">1</span>;    <span class="hljs-comment">//让a等于a本身+1，相当于自增了1</span><br>    System.out.println(a);   <span class="hljs-comment">//得到9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，除了这种方式，我们也可以使用自增自减运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a++;   <span class="hljs-comment">//自增运算符就是两个加号连在一起，效果跟上面是一样的，a都会自增1</span><br>  a--;   <span class="hljs-comment">//自减不用我多说了吧</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>自增自减运算符可以放到操作数的前后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    ++a;   <span class="hljs-comment">//自增运算符在前在后最终效果都是让a自增1，是一样的</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>自增自减操作同样是有结果的，注意，这两种方式自增操作的结果不一样，我们来看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a++;   <span class="hljs-comment">//先出结果，再自增</span><br>    System.out.println(b);  <span class="hljs-comment">//b得到的是a自增前的值</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ++a;   <span class="hljs-comment">//先自增，再出结果</span><br>    System.out.println(b);   <span class="hljs-comment">//b得到的是a自增之后的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一个结果为8，而第二个结果却是9，这是因为，自增运算符放在前面，是先自增再得到结果，而自增运算符放到后面，是先出结果再自增（自减同理），这个新手很容易记混，所以说一定要分清楚。</p><p>自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> -a++ + ++a; <br>  <span class="hljs-comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span><br>  <span class="hljs-comment">//a++的结果还是8，然后是负号，得到-8</span><br>  <span class="hljs-comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span><br>  <span class="hljs-comment">//最后得到的结果为 -8 + 10 = 2</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，除了考试为了考察各位小伙伴对运算符的优先级和结合性的理解，会出现这种恶心人的写法之外，各位小伙伴尽量不要去写这种难以阅读的东西。</p><p>当然，有些时候我们并不是希望以1进行自增，可能希望以其他的数进行自增操作，除了按照之前的方式老老实实写之外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a = a + <span class="hljs-number">4</span>;<br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以将其缩写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//加号和等号连在一起，与a = a + 4效果完全一样</span><br>    System.out.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><p>并且结果也是操作之后的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a += <span class="hljs-number">4</span>;   <span class="hljs-comment">//+=的运算结果就是自增之后的结果</span><br>    System.out.println(b);  <span class="hljs-comment">//所以b就是12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不止加法，包括我们前面介绍的全部算术运算符，都是支持这种缩写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    a *= <span class="hljs-number">9</span>;   <span class="hljs-comment">//跟 a = a * 9 等价</span><br>    System.out.println(a);   <span class="hljs-comment">//得到72</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉能够编写更简洁的代码了？</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">-  +  (强制类型转换)  ++ –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   &#x2F;  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+(加法，包括字符串)   -(减法)</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;   &#x2F;&#x3D;   %&#x3D;</td><td align="center">从右向左</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>我们接着来看位运算符，它比较偏向于底层，但是只要各位小伙伴前面的计算机二进制表示听明白了，这里就不是问题。</p><p>我们可以使用位运算符直接以二进制形式操作目标，位运算符包括：&amp;    |    ^    ~</p><p>我们先来看按位与&amp;，比如下面的两个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &amp; b;    <span class="hljs-comment">//进行按位与运算</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D; 1 &#x3D; 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul><p>同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a | b;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;11&#x3D; 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul><p>按位异或符号很多小伙伴会以为是乘方运算，但是Java中并没有乘方运算符，<code>^</code>是按位异或运算符，不要记错了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>, b = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a ^ b;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;10&#x3D; 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul><p>按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ~<span class="hljs-number">127</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>127 &#x3D; 01111111</li><li>-128 &#x3D; 10000000</li></ul><p>所以说计算的结果就是-128了。</p><p>除了以上的四个运算符之外，还有位移运算符，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;    <span class="hljs-comment">//两个连续的小于符号，表示左移运算</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1 &#x3D; 00000001 </li><li>4 &#x3D; 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li></ul><p>我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用<code>*</code>进行乘2的运算之外，我们也可以使用左移操作来完成。</p><p>同样的，右移操作就是向右移动每一位咯：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span> &gt;&gt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>8 &#x3D; 00001000</li><li>2 &#x3D; 00000010（右移两位之后，1跑到后面去了，头部使用<strong>符号位数字</strong>填充，此时变成2）</li></ul><p>跟上面一样，右移操作可以快速进行除以2的计算。</p><p>对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>-4   &#x3D; 11111100</li><li>-2   &#x3D; 11111110（前面这一长串1都被推到后面一位了，因为是负数，头部需要使用<strong>符号位数字</strong>来进行填充）</li></ul><p>我们来总结一下：</p><ul><li><strong>左移操作&lt;&lt;：</strong> 高位直接丢弃，低位补0</li><li><strong>右移操作&gt;&gt;：</strong> 低位直接丢弃，符号位是什么高位补什么</li></ul><p>我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//正常的右移操作，高位补1，所以说移了还是-1</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;   <span class="hljs-comment">//无符号右移是三个大于符号连在一起，移动会直接考虑符号位</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><ul><li>-1    &#x3D;   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移。</p><p>位移操作也可以缩写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    c = c &lt;&lt; <span class="hljs-number">2</span>;<br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以缩写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    c &lt;&lt;= <span class="hljs-number">2</span>;    <span class="hljs-comment">//直接运算符连上等号即可，跟上面是一样的</span><br>    System.out.println(c);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后我们还是来总结一下优先级：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   &#x2F;  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;   &#x2F;&#x3D;   %&#x3D;   &amp;&#x3D;   |&#x3D;   ^&#x3D;   &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &gt;&gt;&gt;&#x3D;</td><td align="center">从右向左</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>到目前为止，我们发现有一个基本数据类型很低调，在前面的计算中<code>boolean</code>类型一直都没有机会出场，而接下来就是它的主场。</p><p>我们可以对某些事物进行判断，比如我们想判断两个变量谁更大，我们可以使用关系运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &gt; b;   <span class="hljs-comment">//进行判断，如果a &gt; b那么就会得到true，否则会得到false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</p><p>关系判断运算符包括：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&gt;   大于<br>&lt;   小于<br><span class="hljs-section">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br>!=  不等于<br>&gt;=  大于等于<br>&lt;=  小于等于<br></code></pre></td></tr></table></figure><p>关系运算符的计算还是比较简单的。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>前面我们介绍了简单的关系运算符，我们可以通过对关系的判断得到真或是假的结果，但是只能进行简单的判断，如果此时我们想要判断a是否小于等于100且大于等于60，就没办法了：</p><p><img src="https://s2.loli.net/2022/09/17/Z1yAPOKe8IVvFUt.png" alt="image-20220917223047110"></p><p>注意不能像这样进行判断，这是错误的语法，同时只能使用其中一种关系判断运算符。</p><p>为了解决这种问题，我们可以使用逻辑运算符，逻辑运算符包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&amp;&amp;     与运算，要求两边同时为<span class="hljs-literal">true</span>才能返回<span class="hljs-literal">true</span><br>||     或运算，要求两边至少要有一个为<span class="hljs-literal">true</span>才能返回<span class="hljs-literal">true</span><br>!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转<br></code></pre></td></tr></table></figure><p>现在，我们就可以使用逻辑运算符进行复杂条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="hljs-number">60</span>;   <span class="hljs-comment">//我们可以使用与运算符连接两个判断表达式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，上面的判断虽然满足第一个判断表达式，但是不满足第二个，所以说得到的结果就是<code>false</code>。</p><p>我们再来看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span> &gt;= a &amp;&amp; a &gt;= <span class="hljs-number">60</span>;  <span class="hljs-comment">//此时上来就不满足条件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，第一个判断表达式就得到了<code>false</code>，此时不会再继续运行第二个表达式，而是直接得到结果<code>false</code>（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）</p><p>同样的，比如我们现在要判断a要么大于10，要么小于0，这种关系就是一个或的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a &lt; <span class="hljs-number">0</span> || a &gt; <span class="hljs-number">10</span>;   <span class="hljs-comment">//或运算要求两边只要有至少一边满足，结果就为true，如果都不满足，那么就是false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或运算同样会出现短路的情况，比如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> -<span class="hljs-number">9</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a &lt; <span class="hljs-number">0</span> || a &gt; <span class="hljs-number">10</span>;  <span class="hljs-comment">//此时上来就满足条件</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为第一个判断表达式就直接得到了<code>true</code>，那么第二个表达式无论是真还是假，结果都一定是<code>true</code>，所以说没必要继续向后进行判断了，直接得到结果<code>true</code>。</p><p>我们来看看下面的结果是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a++ &gt; <span class="hljs-number">10</span> &amp;&amp; ++a == <span class="hljs-number">12</span>;<br>    System.out.println(<span class="hljs-string">&quot;a = &quot;</span>+a + <span class="hljs-string">&quot;, b = &quot;</span>+b);<br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://s2.loli.net/2022/09/17/tJQxnace7y4VdlY.png" alt="image-20220917224320699"></p><p>这是为什么呢？很明显我们的判断中a进行了两次自增操作，但是最后a的结果却是11，这是因为第一个表达式判断的结果为<code>false</code>，由于此时进行的是与运算，所以说直接短路，不会再继续判断了，因此第二个表达式就不会执行。</p><p>当然，除了与运算和或运算，还有一个非运算，这个就比较简单了，它可以将结果变成相反的样子，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> !(a &gt; <span class="hljs-number">5</span>);   <span class="hljs-comment">//对a&gt;5的判断结果，进行非运算</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为上面的a &gt; 5判断为真，此时进行非运算会得到相反的结果，所以说最后b就是<code>false</code>了。</p><p>最后我们还需要介绍一个叫做三元运算符的东西，三元运算符可以根据判断条件，返回不同的结果，比如我们想要判断：</p><ul><li>当a &gt; 10时，给b赋值’A’</li><li>当a &lt;&#x3D; 10时，给b赋值’B’</li></ul><p>我们就可以使用三元运算符来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a &gt; <span class="hljs-number">10</span> ? <span class="hljs-string">&#x27;A&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>;   <span class="hljs-comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span><br>    System.out.println(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">判断语句 ? 结果<span class="hljs-number">1</span> : 结果2<br></code></pre></td></tr></table></figure><p>因此，上面的判断为假，所以说返回的是结果2，那么最后b得到的就是<code>B</code>这个字符了。</p><p>最后，我们来总结整个运算符板块学习到的所有运算符：</p><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th><th align="center">结合性</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">( )</td><td align="center">从左向右</td></tr><tr><td align="center">2</td><td align="center">! ~   -   +  (强制类型转换)  ++   –</td><td align="center">从右向左</td></tr><tr><td align="center">3</td><td align="center">*   &#x2F;  %</td><td align="center">从左向右</td></tr><tr><td align="center">4</td><td align="center">+   -</td><td align="center">从左向右</td></tr><tr><td align="center">5</td><td align="center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td align="center">从左向右</td></tr><tr><td align="center">6</td><td align="center">&gt;   &lt;   &gt;&#x3D;   &gt;&#x3D;</td><td align="center">从左向右</td></tr><tr><td align="center">7</td><td align="center">&#x3D;&#x3D;     !&#x3D;</td><td align="center">从左向右</td></tr><tr><td align="center">8</td><td align="center">&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">9</td><td align="center">^</td><td align="center">从左向右</td></tr><tr><td align="center">10</td><td align="center">|</td><td align="center">从左向右</td></tr><tr><td align="center">11</td><td align="center">&amp;&amp;</td><td align="center">从左向右</td></tr><tr><td align="center">12</td><td align="center">||</td><td align="center">从左向右</td></tr><tr><td align="center">13</td><td align="center">? :</td><td align="center">从右向左</td></tr><tr><td align="center">14</td><td align="center">&#x3D;  +&#x3D;  -&#x3D;  *&#x3D;   &#x2F;&#x3D;   %&#x3D;   &amp;&#x3D;   |&#x3D;   ^&#x3D;   &lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &gt;&gt;&gt;&#x3D;</td><td align="center">从右向左</td></tr></tbody></table><p>至此，我们已经学习了Java基础部分中所有的运算符。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>我们的程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。学习过C语言就很轻松！</p><p>在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断。</p><h3 id="代码块与作用域"><a href="#代码块与作用域" class="headerlink" title="代码块与作用域"></a>代码块与作用域</h3><p>在开始流程控制语句之前，我们先来介绍一下代码块和作用域。</p><p>不知道各位小伙伴是否在一开始就注意到了，为什么程序中会有一些成对出现的花括号？这些花括号代表什么意思呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;   <span class="hljs-comment">//外层花括号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <span class="hljs-comment">//内层花括号开始</span><br>       <br>    &#125;  <span class="hljs-comment">//内层花括号结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在花括号中编写一句又一句的代码，实际上这些被大括号囊括起来的内容，我们就称为<strong>块</strong>（代码块），一个代码块中可以包含多行代码，我们可以在里面做各种各样的事情，比如定义变量、进行计算等等。</p><p>我们可以自由地创建代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;   <span class="hljs-comment">//现目前这个阶段，我们还是在主方法中编写代码，不要跑去外面写</span><br>    System.out.println(<span class="hljs-string">&quot;外层&quot;</span>);<br>    &#123;   <span class="hljs-comment">//自由创建代码块</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然创建了代码块，但实际上程序依然是按照从上到下的顺序在进行的，所以说这里还是在逐行运行，即使使用花括号囊括。那咋一看这不就是没什么卵用吗？我们来看看变量。</p><p>我们创建的变量，实际上是有作用域的，并不是在任何地方都可以使用，比如：</p><p><img src="https://s2.loli.net/2022/09/17/DdvU3aQmE25KbxM.png" alt="image-20220917231014796"></p><p>变量的使用范围，仅限于其定义时所处的代码块，一旦超出对应的代码块区域，那么就相当于没有这个变量了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;   <span class="hljs-comment">//此时变量在最外层定义</span><br>    &#123;<br>        System.out.println(a);   <span class="hljs-comment">//处于其作用域内部的代码块可以使用</span><br>    &#125;<br>    System.out.println(a);   <span class="hljs-comment">//这里肯定也可以使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们目前所创建的变量都是局部变量（有范围限制），后面我们会介绍更多种类型的变量，了解了代码块及作用域之后，我们就可以正式开启流程控制语句的学习了。</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下<code>if</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件判断) 判断成功执行的代码;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">15</span>)    <span class="hljs-comment">//只有当a判断等于15时，才会执行下面的打印语句</span><br>      System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>  System.out.println(<span class="hljs-string">&quot;我是外层&quot;</span>);   <span class="hljs-comment">//if只会对紧跟着的一行代码生效，后续的内容无效</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>if</code>会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) &#123;    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">&quot;a大于10&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a的值为：&quot;</span>+a);<br>    &#125;<br>  System.out.println(<span class="hljs-string">&quot;我是外层&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">if</span>(a &gt; <span class="hljs-number">10</span>) &#123;    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        System.out.println(<span class="hljs-string">&quot;a大于10&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a的值为：&quot;</span>+a);<br>    &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//当判断不成功时，会执行else代码块中的代码</span><br>        System.out.println(<span class="hljs-string">&quot;a小于10&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;a的值为：&quot;</span>+a);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;我是外层&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p><p>那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span>  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &gt;= <span class="hljs-number">90</span>)    <span class="hljs-comment">//90分以上才是优秀</span><br>        System.out.println(<span class="hljs-string">&quot;优秀&quot;</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>)    <span class="hljs-comment">//当上一级if判断失败时，会继续判断这一级</span><br>        System.out.println(<span class="hljs-string">&quot;良好&quot;</span>);<br>     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>        System.out.println(<span class="hljs-string">&quot;及格&quot;</span>);<br>     <span class="hljs-keyword">else</span>    <span class="hljs-comment">//当之前所有的if都判断失败时，才会进入到最后的else语句中</span><br>        System.out.println(<span class="hljs-string">&quot;不及格&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，<code>if</code>分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span>  <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(score &lt; <span class="hljs-number">60</span>) &#123;   <span class="hljs-comment">//先判断不及格</span><br>        <span class="hljs-keyword">if</span>(score &gt; <span class="hljs-number">30</span>)    <span class="hljs-comment">//在内层再嵌套一个if语句进行进一步的判断</span><br>            System.out.println(<span class="hljs-string">&quot;学习C++&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            System.out.println(<span class="hljs-string">&quot;学习Java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用<code>if</code>来进行各种条件判断了。</p><p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用<code>switch</code>语句来实现，它更适用于多分支的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) &#123;   <span class="hljs-comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span><br>  <span class="hljs-keyword">case</span> 匹配值:    <span class="hljs-comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span><br>    代码...<br>    <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;  <span class="hljs-comment">//这里目标就是变量c</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:    <span class="hljs-comment">//分别指定ABC三个匹配值，并且执行不同的代码</span><br>            System.out.println(<span class="hljs-string">&quot;去尖子班！准备冲刺985大学！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//执行完之后一定记得break，否则会继续向下执行下一个case中的代码</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！准备冲刺一本！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去职高深造。&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>switch</code>可以精准匹配某个值，但是它不能进行范围判断，比如我们要判断分数段，这时用switch就很鸡肋了。</p><p>当然除了精准匹配之外，其他的情况我们可以用default来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span> (目标) &#123;<br>    <span class="hljs-keyword">case</span>: ...<br>    <span class="hljs-keyword">default</span>:<br>    其他情况下执行的代码<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还是以刚才那个例子为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去尖子班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去差生班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:   <span class="hljs-comment">//其他情况一律就是下面的代码了</span><br>            System.out.println(<span class="hljs-string">&quot;去读职高，分流&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然switch中可以继续嵌套其他的流程控制语句，比如if：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">switch</span> (c) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;A&#x27;</span>) &#123;    <span class="hljs-comment">//嵌套一个if语句</span><br>                System.out.println(<span class="hljs-string">&quot;去尖子班！&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>            System.out.println(<span class="hljs-string">&quot;去平行班！&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>目前，我们已经认识了两种选择分支结构语句。</p><h3 id="Java-14-Switch表达式"><a href="#Java-14-Switch表达式" class="headerlink" title="(Java 14) Switch表达式"></a>(Java 14) Switch表达式</h3><p>在Java 12中，官方对switch进行了增强，它提供了更加简洁和表达力强的方式来替代传统的switch语句，最终在Java 14中正式上线。假设现在我们要给不同分数的学生打等级（学生满分10分）我们之前学习的传统<code>switch</code>语句像这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br><span class="hljs-type">char</span> grade;<br><span class="hljs-keyword">switch</span> (score) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        grade = <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        grade = <span class="hljs-string">&#x27;B&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>        grade = <span class="hljs-string">&#x27;C&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        grade = <span class="hljs-string">&#x27;D&#x27;</span>;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;学生等级为: &quot;</span> + grade);<br></code></pre></td></tr></table></figure><p>这是在是太累了，每一种情况都要单独编写<code>case</code>和<code>break</code>语句，从现在开始，我们可以使用新的<code>switch</code>语法了，它的分支结果可以直接作为返回结果给到前面的变量，或是在后续课程中用做方法返回值使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>;<br><span class="hljs-comment">//直接让grade接受switch的结果</span><br><span class="hljs-type">char</span> <span class="hljs-variable">grade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (score) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&#x27;A&#x27;</span>;   <span class="hljs-comment">//case后面直接使用-&gt;来指定返回结果</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span> -&gt; <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -&gt; <span class="hljs-string">&#x27;C&#x27;</span>;  <span class="hljs-comment">//当存在多个匹配条件时，使用逗号分隔</span><br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&#x27;D&#x27;</span>;<br>&#125;;  <span class="hljs-comment">//别忘了这种写法相当于赋值，最后需要加分号</span><br>System.out.println(<span class="hljs-string">&quot;学生等级为: &quot;</span> + grade);<br></code></pre></td></tr></table></figure><p>是不是看起来简单多了？其中<code>grade</code>得到的就是每一个<code>case</code>语句<code>-&gt;</code>符号后的结果，不需要任何<code>break</code>操作，分支会自动结束，不会出现之前的向下继续移动的情况。详细语法规则如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (obj) &#123;   <span class="hljs-comment">//这里和之前的switch语句是一样的，但是注意这样的switch是有返回值的，所以可以被变量接收</span><br>    <span class="hljs-keyword">case</span> [匹配值, ...] -&gt; <span class="hljs-string">&quot;优秀&quot;</span>;   <span class="hljs-comment">//case后直接添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</span><br>    <span class="hljs-keyword">case</span> ...   <span class="hljs-comment">//根据不同的分支，可以存在多个case</span><br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&quot;不及格&quot;</span>;   <span class="hljs-comment">//注意，表达式要求必须涵盖所有的可能，所以是需要添加default的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>不过，有些时候可能我们并不能直接指定返回的结果，比如存在前置操作的情况下，我们可以像这样编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">grade</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (score) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">9</span> -&gt; <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">8</span> -&gt; <span class="hljs-string">&#x27;B&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span> -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是额外操作&quot;</span>);   <span class="hljs-comment">//存在前置操作，无法直接指定结果</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;C&#x27;</span>;   <span class="hljs-comment">//在最后使用yield关键字来指定结果</span><br>    &#125;<br>    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">&#x27;D&#x27;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>yield</code>关键字来指定延迟返回的结果，同样的，不需要任何<code>break</code>操作，分支会自动结束（注意<code>yield</code>执行之后，后续不能再有任何代码了，因为已经结束了）</p><p>这种全新的语法，可以说极大地方便了我们的编码，不仅代码简短，而且语义明确。但是注意，箭头语法和传统语法在Java 21之前是不允许混用的，Java 21之后可以相互混用。</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。</p><p>我们在某些时候，可能需要批量执行某些代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>);   <span class="hljs-comment">//把这句话给我打印三遍</span><br>    System.out.println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？</p><p>现在，要解决这种问题，我们可以使用for循环语句来多次执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>) 循环体;<br></code></pre></td></tr></table></figure><p>介绍一下详细规则：</p><ul><li>表达式1：在循环开始时仅执行一次。</li><li>表达式2：每次循环开始前会执行一次，要求为判断语句，用于判断是否可以结束循环，若结果为真，那么继续循环，否则结束循环。</li><li>表达式3：每次循环完成后会执行一次。</li><li>循环体：每次循环都会执行一次循环体。</li></ul><p>一个标准的for循环语句写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-comment">//比如我们希望让刚刚的打印执行3次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    <span class="hljs-comment">//这里我们在for语句中定义一个变量i，然后每一轮i都会自增，直到变成3为止</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);   <span class="hljs-comment">//这样，就会执行三轮循环，每轮循环都会执行紧跟着的这一句打印</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值：</p><p><img src="https://s2.loli.net/2022/09/18/A8lRmNZCqxLStwQ.png" alt="image-20220918112006020"></p><p>调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug）</p><p><img src="https://s2.loli.net/2022/09/18/VKMGoJazvXAnh2k.png" alt="image-20220918112101677"></p><p>调试开始时，我们可以看到程序在断点位置暂停了：</p><p><img src="https://s2.loli.net/2022/09/18/Cdq1ifFvHwMuO29.png" alt="image-20220918112227207"></p><p>此时我们可以观察到当前的局部变量<code>i</code>的值，也可以直接在下方的调试窗口中查看：</p><p><img src="https://s2.loli.net/2022/09/18/e6AODRMCgqmGwTy.png" alt="image-20220918112409944"></p><p>随着循环的进行，i的值也会逐渐自增：</p><p><img src="https://s2.loli.net/2022/09/18/bS1DxpgwOfWhujy.png" alt="image-20220918112628585"></p><p>当<code>i</code>增长到2时，此时来到最后一轮循环，再继续向下运行，就不再满足循环条件了，所以说此时就会结束循环。</p><p>当然，如果要执行多条语句的话，只需要使用花括号囊括就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的<code>i</code>仅仅是for循环语句中创建的变量，所以说其作用域被限制在了循环体中，一旦离开循环体，那么就无法使用了：</p><p><img src="https://s2.loli.net/2022/09/18/2aO9Ro5yfMUvhNc.png" alt="image-20220918112923978"></p><p>但是我们可以将<code>i</code>的创建放到外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//在外面创建变量i，这样全部范围内都可以使用了</span><br>    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">3</span>; i++) &#123;   <span class="hljs-comment">//for循环的三个表达式并不一定需要编写</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>&#125;<br></code></pre></td></tr></table></figure><p>和之前的<code>if</code>一样，for循环同样支持嵌套使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)    <span class="hljs-comment">//外层循环执行3次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)    <span class="hljs-comment">//内层循环也执行3次</span><br>            System.out.println(<span class="hljs-string">&quot;1！5！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。</p><p>实际上，for循环的三个表达式并不一定需要编写，我们甚至可以三个都不写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;)   <span class="hljs-comment">//如果什么都不写，相当于没有结束条件，这将会导致无限循环</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有表达式2，那么整个for循环就没有结束条件，默认会判定为真，此时就会出现无限循环的情况（无限循环是很危险的，因为它会疯狂地消耗CPU资源来执行循环，可能很快你的CPU就满载了，一定要避免）</p><p>当然，我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;   <span class="hljs-comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span><br>        System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行<code>continue</code>进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。</p><p>在某些情况下，我们可能希望提前结束循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;   <span class="hljs-comment">//我们希望当i等于1时提前结束</span><br>    System.out.println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;当前i的值为：&quot;</span>+i);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">//当i == j时加速循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span>;    <span class="hljs-comment">//当i == j时终止循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;   <span class="hljs-comment">//在循环语句前，添加 标签: 来进行标记</span><br>    inner: <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>        <span class="hljs-keyword">if</span>(i == j) <span class="hljs-keyword">break</span> outer;    <span class="hljs-comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span><br>        System.out.println(i+<span class="hljs-string">&quot;, &quot;</span>+j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个代码块中存在多个循环，那么直接对当前代码块的标记执行<code>break</code>时会直接跳出整个代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">outer: &#123;    <span class="hljs-comment">//直接对整个代码块打标签</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;Test&quot;</span>);<br>            <span class="hljs-keyword">break</span> outer;   <span class="hljs-comment">//执行break时，会直接跳出整个代码块，而不是第一个循环</span><br>        &#125;<br>    &#125;<br><br>    System.out.println(<span class="hljs-string">&quot;？？？&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然效果挺奇特的，但是一般情况下没人这么玩，所以说了解就行了。</p><p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们填写三个表达式，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(循环条件) 循环体;<br></code></pre></td></tr></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;   <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span><br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;   <span class="hljs-comment">//每次循环都除以2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况就非常适合使用while循环。</p><p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>        System.out.println(i);<br>        i /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">//无论满不满足循环条件，先执行循环体里面的内容</span><br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        i++;<br>    &#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>);   <span class="hljs-comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，面向过程相关的内容就讲解完毕了，从下一章开始，我们将进入面向对象编程的学习（类、数组、字符串）</p><h3 id="Java-9-交互式编程"><a href="#Java-9-交互式编程" class="headerlink" title="(Java 9) 交互式编程"></a>(Java 9) 交互式编程</h3><p>如果各位小伙伴学习过其他语言，比如Python、JavaScript这类解释型语言，应该能够体验到命令行交互编程的快捷。而Java9同样推出了相似的功能，让我们能够在命令行中直接编写和运行Java代码，我们可以使用<code>jshell</code>命令打开交互式编程工具：</p><p><img src="https://s2.loli.net/2025/07/07/rxw9BcNRTPpgIm6.png" alt="image-20250707201630991"></p><p>我们可以尝试在其中编写Java代码，比如打印HelloWorld，在敲击过程中，可以使用<code>Tab</code>键进行代码补全操作：</p><p><img src="https://s2.loli.net/2025/07/07/YncSrxbGpdPOD3E.png" alt="image-20250707201736343"></p><p>编写完成后输入回车即可执行：</p><p><img src="https://s2.loli.net/2025/07/07/iyeVHrOKcRvgBMw.png" alt="image-20250707201831042"></p><p>当然我们还可以提前创建一个变量，在后续代码中使用也是没有问题的：</p><p><img src="https://s2.loli.net/2025/07/07/jX2hmE8kPxAJUMF.png" alt="image-20250707202005720"></p><p>包括我们在编写<code>if</code>或是<code>for</code>这种结构性代码（包括后面会学习的类声明等）的时候，会自动进入多行编辑状态：</p><p><img src="https://s2.loli.net/2025/07/07/OaVCdpK8nRztxbB.png" alt="image-20250707202135192"></p><p>直到我们输入完成整个<code>if</code>代码块的结尾花括号，对于一些简单的计算操作，可以尝试使用此交互式编程工具来完成。</p><p>当不需要使用时，输入<code>/exit</code>指令即可退出：</p><p><img src="https://s2.loli.net/2025/07/07/aWF92KYwqhPDgcz.png" alt="image-20250707202517718"></p><hr><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><p>面向过程的内容全部学习完成，我们来做几个练习题吧！</p><h3 id="寻找水仙花数"><a href="#寻找水仙花数" class="headerlink" title="寻找水仙花数"></a>寻找水仙花数</h3><blockquote><p>“水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指<strong>一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身。</strong>例如：1^3 + 5^3+ 3^3 &#x3D; 153。”</p></blockquote><p>现在请你设计一个Java程序，打印出所有1000以内的水仙花数。</p><h3 id="打印九九乘法表"><a href="#打印九九乘法表" class="headerlink" title="打印九九乘法表"></a>打印九九乘法表</h3><p><img src="https://s2.loli.net/2022/09/18/zy1wuvj6gfHmAZS.jpg" alt="img"></p><p>现在我们要做的是在我们的程序中，也打印出这样的一个乘法表出来，请你设计一个Java程序来实现它。</p><p><img src="https://s2.loli.net/2022/09/18/Iek7OnbRoTw46Cl.jpg" alt="img"></p><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><blockquote><p>斐波那契数列（Fibonacci sequence），又称<a href="https://baike.baidu.com/item/%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2/115896">黄金分割</a>数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：<strong>1、1、2、3、5、8、13、21、34、……</strong>在数学上，斐波那契数列以如下被以递推的方法定义：<em>F</em>(0)&#x3D;0，<em>F</em>(1)&#x3D;1, <em>F</em>(n)&#x3D;<em>F</em>(n - 1)+<em>F</em>(n - 2)（<em>n</em> ≥ 2，<em>n</em> ∈ N*）在现代物理、准<a href="https://baike.baidu.com/item/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84/10401467">晶体结构</a>、化学等领域，斐波纳契数列都有直接的应用，为此，美国数学会从 1963 年起出版了以《斐波纳契数列季刊》为名的一份数学杂志，用于专门刊载这方面的研究成果。</p></blockquote><p>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89…，不难发现一个规律，实际上从第三个数开始，每个数字的值都是前两个数字的和，现在请你设计一个Java程序，可以获取斐波那契数列上任意一位的数字，比如获取第5个数，那么就是5。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>, result;  <span class="hljs-comment">//target是要获取的数，result是结果</span><br><br>    <span class="hljs-comment">//请在这里实现算法</span><br><br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/pew6po6wrou23pk3">https://www.itbaima.cn/zh-CN/document/pew6po6wrou23pk3</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaSE 核心内容 - JavaSE 笔记（一）走进Java语言</title>
    <link href="/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%B0%E8%BF%9BJava%E8%AF%AD%E8%A8%80/"/>
    <url>/2025/08/24/JavaSE%20%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%20-%20JavaSE%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E8%B5%B0%E8%BF%9BJava%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p><img src="https://s2.loli.net/2025/07/07/bCPfDWe5oy1JEt4.png" alt="image-20250707161444454"></p><h1 id="新手入门篇"><a href="#新手入门篇" class="headerlink" title="新手入门篇"></a>新手入门篇</h1><p><strong>注意：</strong> 开始学习JavaSE之前建议学习的前置课程《C语言程序设计》《数据结构》《操作系统》《计算机组成原理》这些前置课程对于你接下来学习JavaSE有着非常重要的帮助。</p><p>欢迎各位小伙伴进入到JavaSE阶段的学习之旅，这是整个Java学习路线的第一站，期待与各位小伙伴共度这一旅程！视频中所有的文档、资料，都可以直接在视频下方简介中找到，视频非培训机构出品，纯个人录制，不需要加任何公众号、小程序，直接自取即可。</p><p>教程开始之前，提醒各位小伙伴：</p><ul><li>如果你对某样东西不熟悉，请务必保证跟视频中使用一模一样的环境、一模一样的操作方式去使用，不要自作主张，否则出现某些奇怪的问题又不知道怎么办，就会浪费很多时间。</li><li>不要认为<strong>不看视频只看文档就行</strong>，文档笔记只是方便你快速回顾视频知识点的东西，真要靠看文档学会建议直接去看Java官方文档，内容差不多一本书那么多。</li><li>本视频基于Java 25（是2025年发布的又一作为长期支持的LTS版本）进行讲解，包含所有新特性和语法讲解，基本可以保证未来几年不会轻易淘汰，请放心食用。同时，Java 8之后的新特性，文档会特别标注</li><li>在学习过程中，尽可能避免出现中文文件夹，包括后面的环境安装、项目创建，都尽量不要放在中文路径下（因为使用中文常常出现奇奇怪怪的问题）建议使用对应的英文单词代替，或者是用拼音都可以，最好只出现英文字母和数字。</li><li>本教程使用 IDEA社区版（免费）即可，不需要申请终极版，但是从下一阶段开始将强制要求使用终极版，如果你打算完整学习整条路线，请尽快完成终极版的申请。</li></ul><p>如果觉得本视频对你有帮助，请一键三连支持一下UP主。</p><p><strong>JavaSE 学习方案计划：</strong></p><ol><li><strong>只想通过学校考试的同学：</strong> 知识点可以大概理解，对于细节内容可以跳过，由于很多学校考的都是远古版本，Java 8及其之后新特性可以跳过。</li><li><strong>想学习Java路线就业的同学：</strong> 务必保证每个知识点都理解到位，课后需要自行尝试编码练习，前一个知识点没学会不建议继续往后看，不应该也不能够跳过任何一个地方，因为全是细节，工作中很重要。</li><li><strong>想学习Java路线就业但是很急的同学：</strong> 可以选择跳过Java 8及其之后新特性讲解，只学习核心内容，但是同样的不能跳着看，全是细节，全是基础，后面JavaWeb阶段跳着学都没跳JavaSE亏得多，工作中很重要。到了后续阶段一定要记得回来补上，而不是直接抛弃。</li><li><strong>想学习Java路线就业但是很急真的没时间的同学：</strong> 想办法抽时间出来学，不要抱着考试的心态来学，就业不是你考试通过了就万事大吉了，而是你要真的会做，该花的时间必须花。社会很残酷，你会就是会不会就是不会，同样的工作人家基础扎实一个小时做完，而你基础不牢要做一天。</li></ol><h2 id="计算机思维导论"><a href="#计算机思维导论" class="headerlink" title="计算机思维导论"></a>计算机思维导论</h2><p>计算机自1946年问世以来，几乎改变了整个世界。</p><p>现在我们可以通过电脑来做很多事情，比如我们常常听到的什么人工智能、电子竞技、大数据等等，都和计算机息息相关，包括我们现在的手机、平板等智能设备，也是计算机转变而来的。各位可以看看最顶上的这张图片，如果你在小时候接触过计算机，那么一定对这张图片（照片拍摄于1996年，在美国加利福尼亚州加利福尼亚州的锁诺玛县）印象深刻，这张壁纸作为WindowsXP系统的默认壁纸，曾经展示在千家万户的电脑屏幕上。</p><p>也许你没有接触过计算机，也许你唯一接触计算机就是用来打游戏，也有可能你曾经捣鼓过计算机，在学习C语言之前，先让我们来了解一下计算机的世界。</p><h3 id="计算机的世界"><a href="#计算机的世界" class="headerlink" title="计算机的世界"></a>计算机的世界</h3><p><strong>注意：</strong> 此内容在前置课程中已经介绍过，如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>计算机虽然名字听着很高级，不过它也是由一个个简单电路组成的。</p><p><img src="https://s2.loli.net/2025/07/07/Iym8FTvPsiCLlEr.png" alt="image-20230228214034266"></p><p>这是我们在初中就学习过的电路图，不过这种电路太过简单，只能完成一些很基础的的操作，比如点亮小灯泡等。</p><p>很明显想要实现计算机怎么高级的运算机器，肯定是做不到的，这时我们就需要引入更加强大的数字电路了。</p><blockquote><p>用数字信号完成对数字量进行<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97/3118202">算术运算</a>和<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/7224729">逻辑运算</a>的电路称为数字电路，或数字系统。由于它具有逻辑运算和逻辑处理功能，所以又称数字逻辑电路。现代的数字电路由半导体工艺制成的若干数字集成器件构造而成。逻辑门是数字逻辑电路的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83/5246264">基本单元</a>。</p></blockquote><p>计算机专业一般会在大一开放《数字电路》这门课程，会对计算机底层的数字电路实现原理进行详细介绍。</p><p>数字电路引入了逻辑判断，我们来看看简单的数字电路：</p><p><img src="https://s2.loli.net/2025/07/07/vLBA8Wqnp7xoK6k.png" alt="image-20230228214109516"></p><p>数字电路中，用电压的高低来区分出两种信号，低电压表示0，高电压表示1，由于只能通过这种方式表示出两种类型的信号，所以计算机采用的是二进制。</p><blockquote><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457">二进制</a>是计算技术中广泛采用的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E5%88%B6/217113">数制</a>。二进制数据是用0和1两个数码来表示的数。它的<a href="https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0/4260">基数</a>为2，进位规则是“逢二进一”，借位规则是“借一当二”。</p><p>比如我们一般采用的都是十进制表示，比如9再继续加1的话，就需要进位了，变成10，在二进制中，因为只有0和1，所以当1继续加1时，就需要进位了，就变成10了（注意这不是十，读成一零就行了）</p></blockquote><p>当然，仅仅有两种信号还不够，我们还需要逻辑门来辅助我们完成更多的计算，最基本的逻辑关系是与、或、非，而逻辑门就有相应的是<a href="https://baike.baidu.com/item/%E4%B8%8E%E9%97%A8">与门</a>、<a href="https://baike.baidu.com/item/%E6%88%96%E9%97%A8">或门</a>和<a href="https://baike.baidu.com/item/%E9%9D%9E%E9%97%A8">非门</a>，可以用电阻、电容、二极管、三极管等分立原件构成（具体咋构成的咱这里就不说了）</p><p>比如与操作，因为只有两种类型，我们一般将1表示为真，0表示为假，与操作（用&amp;表示）要求两个数参与进来，比如：</p><ul><li>1 &amp; 1 &#x3D; 1 必须两边都是真，结果才为真。</li><li>1 &amp; 0 &#x3D; 0 两边任意一个或者都不是真，结果为假。</li></ul><p>或运算（用 | 表示）：</p><ul><li>1 | 0 &#x3D; 1 两边只要有一个为真，结果就为真</li><li>0 | 0 &#x3D; 0 两边同时为假，结果才是假</li></ul><p>非运算实际上就是取反操作（可以是 ! 表示）</p><ul><li>!1 &#x3D; 0</li><li>!0 &#x3D; 1 非运算会将真变成假，假变成真</li></ul><p>有了这些运算之后，我们的电路不仅仅可以实现计算，也可以实现各种各样的逻辑判断，最终才能发展成我们的计算机。</p><p>前面我们大概介绍一下计算机的底层操作原理，接着我们来看看计算机的基本组成。</p><p><img src="https://s2.loli.net/2025/07/07/RCq28imOKsuaV49.png" alt="image-20230228214242283"></p><p>相信各位熟知的计算机都是一个屏幕+一个主机的形式，然后配上我们的键盘鼠标，就可以开始使用了，但是实际上标准的计算机结构并没有这么简单，我们来看看：</p><p><img src="https://s2.loli.net/2025/07/07/shx9aNQgH7YlU4q.png" alt="image-20230228214255379">我们电脑最核心的部件，当属CPU，因为几乎所有的运算都是依靠CPU进行（各种各样的计算电路已经在CPU中安排好了，我们只需要发送对应的指令就可以进行对应的运算），它就像我们人的大脑一样，有了大脑才能进行思考。不过光有大脑还不行，还要有一些其他的部分来辅助工作，比如我们想向电脑里面打字，那么就需要连接一个键盘才能输入，我们想要点击桌面上的图标，那么就需要一个鼠标来操作光标，这些都是输入设备。我们的电脑开机之后显示器上会显示出画面，实际上显示器就是输出设备。</p><p>当然除了这些内容之外，我们的电脑还需要内存来保存运行时的一些数据，以及外存来保存文件（比如硬盘）等。我们常说的iPhone13 512G，这个512G并不是指的内存，而是指的外存，准确的说是用于存放文件硬盘大小，而真正的内存是我们常说的4G&#x2F;6G&#x2F;8G运行内存，内存的速度远高于外存的速度，所以1G内存的价格远超1G硬盘的价格。</p><p><img src="https://s2.loli.net/2025/07/07/RDG7iZwzHE13CIk.png" alt="image-20230228214446410"></p><p>计算机包括五大部件：运算器、控制器、存储器、输入和输出设备。有了这一套完整的硬件环境，我们的电脑才算是有了一个完整的身体。</p><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p><strong>注意：</strong> 此内容在前置课程中已经介绍过，如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>前面我们了解了一下计算机的大致原理和组成结构，但是光有这一套硬件可不行，如何让这一套硬件按照我们想要的方式运作起来，也是非常重要的，这时我们就需要介绍操作系统了。</p><blockquote><p>操作系统（operating system，简称OS）是管理<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5459592">计算机硬件</a>与<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>资源的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F/3220205">计算机程序</a>。操作系统需要处理如管理与<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE/2394679">配置</a><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98/103614">内存</a>、决定<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90/974435">系统资源</a>供需的优先次序、控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87/10823368">输入设备</a>与<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87/10823333">输出设备</a>、操作网络与管理<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4827215">文件系统</a>等基本事务。操作系统也提供一个让用户与系统<a href="https://baike.baidu.com/item/%E4%BA%A4%E4%BA%92/6964417">交互</a>操作的界面。</p><p>一般在计算机专业大二，会开放《操作系统》课程，会详细讲解操作系统的底层运作机制和调度。</p></blockquote><p>一般我们电脑上都安装了Windows操作系统（苹果笔记本安装的是MacOS操作系统），现在主流的电脑都已经预装Windows11了：</p><p><img src="https://s2.loli.net/2023/02/28/WcDxHTraFAK6t9p.png" alt="image-20230228214559098"></p><p>有了操作系统，我们的电脑才能真正运行起来，我们就可以轻松地通过键盘和鼠标来操作电脑了。</p><p>不过操作系统最开始并不是图形化界面，它类似于Windows中的命令提示符：</p><p><img src="https://s2.loli.net/2023/02/28/OlQp9n6ZY3qts1M.png" alt="image-20230228214618172"></p><p><img src="https://s2.loli.net/2023/02/28/ilDr1HwXomgBYSx.png" alt="image-20230228214721666"></p><p>没有什么图标这些概念，只有一个简简单单的黑框让我们进行操作，通过输入命令来进行一些简单的使用，程序的运行结果也会在黑框框（命令行）中打印出来，不过虽然仅仅是一个黑框，但是能运行的程序可是非常非常多的，只需要运行我们编写好的程序，就能完成各种各样复杂的计算任务，并且计算机的计算速度远超我们的人脑。</p><blockquote><p> 中国超级计算机系统天河二号，计算速度达到每秒5.49亿亿次。</p></blockquote><p>当然，除了我们常见的Windows和MacOS系统之外，还有我们以后需要经常打交道的Linux操作系统，这种操作系统是开源的，意思是所有的人都可以拿到源代码进行修改，于是就出现了很多发行版：</p><p><img src="https://s2.loli.net/2023/02/28/uYX84BNzl9FV1Mr.png" alt="image-20230228214754274"></p><p>这些发行版有带图形化界面的，也有不带图形化界面的，不带图形化界面的Linux将是我们以后学习的重点。</p><p>不同操作系统之间的软件并不是通用的，比如Windows下我们的软件一般是.exe后缀名称，而MacOS下则不是，并且也无法直接运行.exe文件，这是因为不同操作系统的具体实现会存在一些不同，程序编译（我们之后会介绍到）之后的格式也会不同，所以是无法做到软件通用的。</p><p>正是因为有了操作系统，才能够组织我们计算机的底层硬件（包括CPU、内存、输入输出设备等）进行有序工作，没有操作系统电脑就如同一堆废铁，只有躯壳没有灵魂。</p><h3 id="计算机编程语言"><a href="#计算机编程语言" class="headerlink" title="计算机编程语言"></a>计算机编程语言</h3><p><strong>注意：</strong> 此内容在前置课程中已经介绍过，如果你已经完成了《C语言程序设计》视频教程的学习，可以直接跳过此部分。</p><p>现在我们大致了解了我们的电脑的运作原理，实际上是一套完整的硬件+一个成形的操作系统共同存在的。接着我们就可以开始了解一下计算机的编程语言了。我们前面介绍的操作系统也是由编程语言写出来的，操作系统本身也算是一个软件。</p><p><img src="https://s2.loli.net/2023/02/28/cu8GVYZB24PvzIR.png" alt="image-20230228214817739"></p><p>那么操作系统是如何让底层硬件进行工作的呢？实际上就是通过向CPU发送指令来完成的。</p><blockquote><p>计算机指令就是指挥机器工作的指示和命令，程序就是一系列按一定顺序排列的指令，执行程序的过程就是计算机的工作过程。指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合，而每一种新型的CPU在设计时就规定了一系列与其他硬件电路相配合的指令系统。而指令集的先进与否，也关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p></blockquote><p>我们电脑中的CPU有多种多样的，不同的CPU之间可能也会存在不同的架构，比如现在最常用的是x86架构，还有我们手机平板这样的移动设备使用的arm架构，不同的架构指令集也会有不同。</p><p>我们知道，计算机底层硬件都是采用的0和1这样的二进制表示，所以指令也是一样的，比如（这里随便写的）：</p><ul><li><p>000001  -  代表开机</p></li><li><p>000010  -  代表关机</p></li><li><p>000011  -  代表进行加法运算</p></li></ul><p>当我们通过电路发送给CPU这样的二进制指令，CPU就能够根据我们的指令执行对应的任务，而我们编写的程序保存在硬盘中也是这样的二进制形式，我们只需要将这些指令组织好，按照我们的思路一条一条执行对应的命令，就能够让计算机计算任何我们需要的内容了，这其实就是机器语言。</p><p>不过随着时代的进步，指令集越来越大，CPU支持的运算类型也越来越多，这样的纯二进制编写实在是太累了，并且越来越多的命令我们根本记不住，于是就有了汇编语言。汇编语言将这些二进制的操作码通过助记符来替换：</p><ul><li><p>MOV  传送字或字节。</p></li><li><p>MOVSX  先符号扩展,再传送。</p></li><li><p>MOVZX  先零扩展,再传送。</p></li><li><p>PUSH  把字压入堆栈。</p></li></ul><p>把这些原有的二进制命令通过一个单词来代替，这样是不是就好记多了，在程序编写完成后，我们只需要最后将这些单词转换回二进制指令就可以了，这也是早期出现的低级编程语言。</p><p><img src="https://s2.loli.net/2023/02/28/ypHDg3XRNFuVtrc.png" alt="image-20230228214843558"></p><p>不过虽然通过这些助记符就能够很轻松地记住命令，但是还是不够方便，因为可能我们的程序需要完成一个很庞大的任务，但是如果还是这样一条一条指令进行编写，是不是太慢了点，有时候可能做一个简单的计算，都需要好几条指令来完成。于是，高级编程语言——C语言，终于诞生了。</p><blockquote><p>C语言诞生于美国的<a href="https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E5%AE%9E%E9%AA%8C%E5%AE%A4/686816">贝尔实验室</a>，由<a href="https://baike.baidu.com/item/%E4%B8%B9%E5%B0%BC%E6%96%AF%C2%B7%E9%87%8C%E5%A5%87/7267171">丹尼斯·里奇</a>（Dennis MacAlistair Ritchie）以肯尼斯·蓝·汤普森（Kenneth Lane Thompson）设计的<a href="https://baike.baidu.com/item/B%E8%AF%AD%E8%A8%80/1845842">B语言</a>为基础发展而来，在它的主体设计完成后，汤普森和里奇用它完全重写了UNIX操作系统，且随着UNIX操作系统的发展，C语言也得到了不断的完善。</p></blockquote><p>高级语言不同于低级语言，低级语言的主要操作对象是指令本身，而高级语言却更加符合我们人脑的认知，更像是通过我们人的思维，去告诉计算机你需要做什么，包括语法也会更加的简单易懂。下面是一段简单的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;   <span class="hljs-comment">//定义一个a等于10</span><br>  <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;   <span class="hljs-comment">//定义一个b等于10</span><br>  <span class="hljs-type">int</span> c = a + b;   <span class="hljs-comment">//语义非常明确，c就是a加上b计算出来的结果。</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过现在看不懂没关系，我们后面慢慢学。</p><p>C语言虽然支持按照我们更容易理解的方式去进行编程，但是最后还是会编译成汇编指令最后变成计算机可以直接执行的指令，不过具体的编译过程，我们不需要再关心了，我们只需要去写就可以了，而对我们代码进行编译的东西，称为编译器。</p><p><img src="https://s2.loli.net/2023/02/28/H8ZXlCwO3gyxTpz.png" alt="image-20230228214904604"></p><p>当然，除了C语言之外，还有很多其他的高级语言，比如Java、Python、C#、PHP等等，相比其他编程语言，C算是比较古老的一种了，但是时隔多年直至今日，其他编程语言也依然无法撼动它的王者地位：</p><p><img src="https://s2.loli.net/2023/02/28/73aeAcv2EOUqzHY.png" alt="image-20230228214946883"></p><p>可以看到在2021年9月，依然排在编程语言排行榜的<strong>第一名</strong>（Python和Java紧随其后），可见这门语言是多么的不可撼动，很多操作系统、高级编程语言底层实现，几乎都是依靠C语言去编写的（包括Java的底层也是C&#x2F;C++实现的）所以学习这一门语言，对于理工科尤其是计算机专业极为重要，学好C语言你甚至可以融汇贯通到其他语言，学起来也会轻松很多。</p><h3 id="走进Java语言"><a href="#走进Java语言" class="headerlink" title="走进Java语言"></a>走进Java语言</h3><p>前面我们介绍了C语言，它实际上就是通过编译，将我们可以看懂的代码，翻译为计算机能够直接执行的指令，这样计算机就可以按照我们想要的方式去进行计算了。当然，除了C语言之外，也有其他的语言，比如近几年也很火的Python，它跟C语言不同，它并不会先进行编译，而是直接交给解释器解释执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></p><p>可见，这种方式也可以让计算机按照我们的想法去进行工作。</p><p>一般来说，编程语言就分为两大类：</p><ul><li><strong>编译型语言：</strong> 需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如Windows下的exe程序在Mac上就无法运行。</li><li><strong>解释型语言：</strong> 只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</li></ul><p><img src="https://s2.loli.net/2022/09/16/phfUjyuXLIbR3gJ.png" alt="image-20220916151925672"></p><p>那么我们来看看我们今天要介绍的主角，Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。</p><p>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：</p><p><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li>诺基亚手机上的很多游戏都是使用Java编写的。</li><li>安卓系统中的各种应用程序也是使用Java编写的。</li><li>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</li><li>…</li></ul><p>（有关Java的详细发展历程，可以参考《Java核心技术·卷I》第一章）</p><p>可见，Java实际上早已在我们生活中的各个地方扎根。那么，Java语言是什么样的一个运行机制呢？</p><p>实际上我们的Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成<code>.class</code>结尾的二进制文件：</p><p><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"></p><p>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。</p><p><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"></p><p>JVM是个什么东西呢？简单来说，它就像我们前面介绍的解释器一样，我们可以将编译完成的<code>.class</code>文件直接交给JVM去运行，而程序中要做的事情，也都是由它来告诉计算机该如何去执行。</p><p>在不同的操作系统下，都有着对应的JVM实现，我们只需要安装好就可以了，而我们程序员只需要将Java程序编译为<code>.class</code>文件就可以直接交给JVM运行，无论是什么操作系统，JVM都采用的同一套标准读取和执行<code>.class</code>文件，所以说我们编译之后，在任何平台都可以运行，实现跨平台。</p><p>由于Java又需要编译同时还需要依靠JVM解释执行，所以说Java<strong>既是编译型语言，也是解释型语言。</strong></p><p>Java分为很多个版本：</p><ul><li><strong>JavaSE：</strong> 是我们本教程的主要学习目标，它是标准版的Java，也是整个Java的最核心内容，在开始后续课程之前，这是我们不得不越过的一道坎，这个阶段一定要认真扎实地将Java学好，不然到了后面的高级部分，会很头疼。</li><li><strong>JavaME：</strong> 微缩版Java，已经基本没人用了。</li><li><strong>JavaEE：</strong> 企业级Java，比如网站开发，它是JavaSE阶段之后的主要学习方向。</li></ul><p>从下节课开始，我们就正式地进行Java环境的安装和IDE的使用学习。</p><h2 id="环境安装与IDE使用"><a href="#环境安装与IDE使用" class="headerlink" title="环境安装与IDE使用"></a>环境安装与IDE使用</h2><p>前面我们介绍了Java语言，以及其本身的一些性质，这一部分我们就开始进行学习环境安装（这一部分请务必跟着操作，不要自作主张地去操作，一开始就出问题其实是最劝退新手的）</p><h3 id="JDK下载与安装"><a href="#JDK下载与安装" class="headerlink" title="JDK下载与安装"></a>JDK下载与安装</h3><p>首先我们来介绍一下JDK和JRE，各位小伙伴一定要能够区分这两者才可以。</p><ul><li><strong>JRE（Java Runtime Environment）</strong>：Java的运行环境，安装了运行环境之后，Java程序才可以运行，一般不做开发，只是需要运行Java程序直接按照JRE即可。</li><li><strong>JDK（Java Development Kit）</strong>：包含JRE，并且还附带了大量开发者工具，我们学习Java程序开发就使用JDK即可。</li></ul><p>它们的关系如下：</p><p><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></p><p>那么现在我们就去下载JDK吧，这里推荐安装免费的ZuluJDK：<a href="https://www.azul.com/downloads">https://www.azul.com/downloads</a> （由于视频录制时JDK25还未推出，配图暂时使用JDK24，各位小伙伴在下载时如果有JDK25可以直接下载哦）</p><p>在这里选择自己的操作系统对应的安装包：</p><p><img src="https://s2.loli.net/2025/07/07/bLxz4EDTiKm68wC.png" alt="image-20250707165305057"></p><p>比如Windows下，我们就选择<code>.msi</code>的安装包即可（MacOS、Linux下同样选择对应的即可）</p><p><img src="https://s2.loli.net/2025/07/07/feYVgEQ468FnwUJ.png" alt="image-20250707165319320"></p><p>下载完成后，我们直接双击安装，安装列表中的<code>Set JAVA_HOME variable</code>选项请设置为开启，这会自动帮你配置环境变量，不用再像其他教程那样还得手动配置。</p><p><img src="https://s2.loli.net/2025/07/07/WLMm6e4jYhX7vzG.png" alt="image-20250707165742132"></p><p>在选择安装路径的时候，尽量不要出现中文，如果有请自行修改：</p><p><img src="https://s2.loli.net/2025/07/07/zkFBdIA8Wp9qv4V.png" alt="image-20250707165915624"></p><p><strong>注意，这里不建议各位小伙伴去修改安装的位置！</strong>新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。</p><p>剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS或Linux下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以），我们这里直接输入<code>java --version</code>命令即可：</p><p><img src="https://s2.loli.net/2025/07/07/6vMmgihzlEXCGKB.png" alt="image-20250707170001992"></p><p>注意，如果提示出现<code>&#39;java&#39; 不是内部或外部命令，也不是可运行的程序</code>这类文本，可能是因为你在上一步未勾选自动配置环境变量的选项，请尝试重新安装或者手动配置环境变量：</p><p><img src="https://s2.loli.net/2025/07/07/YMtWE2b8JPnTgIA.png" alt="image-20250707165519054"></p><p>如果还是存在同样的问题，请尝试重新启动电脑。</p><p>这样我们就完成了Java环境的安装，我们可以来体验一下编写并且编译运行一个简单的Java程序，我们新建一个文本文档，命名为<code>Main.txt</code>（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在看不懂没关系，直接用就行，我们后面会一点一点讲解的。</p><p>编辑好之后，保存退出，接着我们将文件的后缀名称修改为<code>.java</code>这是Java源程序文件的后缀名称：</p><p><img src="https://s2.loli.net/2025/07/07/v5pN7ca93WVqXFL.png" alt="image-20220916161607822"></p><p>此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径：</p><p><img src="https://s2.loli.net/2025/07/07/DAPT1kEdWajg9zH.png" alt="image-20220916161720722"></p><p>我们使用<code>cd</code>命令先进入到这个目录下：</p><p><img src="https://s2.loli.net/2025/07/07/eBIMsGjDhw1YRZt.png" alt="image-20220916161802753"></p><p>要编译一个Java程序，我们需要使用<code>javac</code>命令来进行：</p><p><img src="https://s2.loli.net/2025/07/07/ucDoltF8nAEgZfr.png" alt="image-20220916161857278"></p><p>执行后，可以看到目录下多出来了一个<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2025/07/07/KIFJkR3DwU5pML7.png" alt="image-20220916161923814"></p><p>这样我们就成功编译了一个Java程序，然后我们就可以将其交给JVM运行了，我们直接使用<code>java</code>命令即可：</p><p><img src="https://s2.loli.net/2025/07/07/yeGWgnVMksF6Lzj.png" alt="image-20220916162048405"></p><p>注意不要加上后缀名称，直接输入文件名字即可，可以看到打印了一个 Hello World! 字样，我们的第一个Java程序就可以运行了。</p><h3 id="IDEA安装与使用"><a href="#IDEA安装与使用" class="headerlink" title="IDEA安装与使用"></a>IDEA安装与使用</h3><p>前面我们介绍了JDK开发环境的安装以及成功编译运行了我们的第一个Java程序。</p><p>但是我们发现，如果我们以后都使用记事本来进行Java程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：<strong>IntelliJ IDEA</strong>（这里不推荐各位小伙伴使用Eclipse或是其他软件，因为操作上没有IDEA这么友好）</p><p>IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。下载地址：<a href="https://www.jetbrains.com.cn/idea/">IntelliJ IDEA – 专业 Java 和 Kotlin 开发 IDE</a>（如果你之前学习C语言程序设计篇使用过CLion，你会发现界面一模一样，这样就能方便你快速上手）</p><p><img src="https://s2.loli.net/2025/07/07/kOyLapHtC5RSo8P.png" alt="image-20250707170456068"></p><p>我们直接点击下载即可，IDEA有两个版本，一种是社区版（免费），还有一种是终极版（一年约1500 RMB），其中社区版功能已完全足够我们学习JavaSE基础内容，这里向下滚动直接下载社区版即可：</p><p><img src="https://s2.loli.net/2025/07/07/QnG4OTjibaZYhgz.png" alt="image-20250707170754517"></p><p><strong>注意：</strong> 针对于在校大学生和教师，JetBrains可以直接免费申请一年的终极版非商业使用许可，并且每个学期都可以续一年，有条件的小伙伴建议直接申请终极版，因为后续JavaWeb阶段强制要求。</p><p><strong>注意：</strong> 针对于Java25，请使用 2025.2 及以上版本的 IntelliJ IDEA 软件，低版本对于新版本Java的支持非常有限，甚至直接不兼容，各位小伙伴下载IDEA工具尽可能选择最新版就好。</p><p>下载好之后，直接安装即可，这个安装位置自己随意，但是注意跟之前一样，路径中不要出现中文：</p><p><img src="https://s2.loli.net/2025/07/07/hy2NdAIG3Z1rFBl.png" alt="image-20250707171533101"></p><p>这里勾选一下创建桌面快捷方式就行：</p><p><img src="https://s2.loli.net/2025/07/07/CDvXMfesOpNErmU.png" alt="image-20250707171551791"></p><p>安装完成后，我们直接打开就可以了，这里推荐所有初学者直接选择中文：</p><p><img src="https://s2.loli.net/2025/07/07/jRDhGcPLE3ez1Um.png" alt="image-20250707171959257"></p><p>IDEA默认为黑色主题，如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题，如果勾选与操作系统同步，那么操作系统是浅色IDEA就是浅色，反之同理：</p><p><img src="https://s2.loli.net/2025/07/07/erHvzFOuPBbwXlA.png" alt="image-20250707172111617"></p><p>包括IDEA的字体、按键映射，以及刚刚选择的语言和区域，都可以在这里进行修改。</p><p>接下来，我们来看看如何使用IDEA编写Java程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目：</p><p><img src="https://s2.loli.net/2025/07/07/vPxnXDf5HJYrL3C.png" alt="image-20250707172327299"></p><p>此时来到创建页面，可以看到有很多的配置项：</p><p><img src="https://s2.loli.net/2025/07/07/GS1vXxYpT6CL7Ur.png" alt="image-20250707172353482"></p><ul><li><strong>名称：</strong> 你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。</li><li><strong>位置：</strong> 项目的存放位置，默认存放在用户目录下，可以自己根据情况修改，同样的，路径中不要出现中文。</li><li><strong>构建系统：</strong> 在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在后续JavaWeb之后进行讲解，Gradle会在Kotlin开发教程中介绍。</li><li><strong>JDK：</strong> 就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说安装位置不要随便去改，不然这些地方就很麻烦）可以看到就是我们刚刚安装的ZuluJDK。</li><li><strong>添加实例代码：</strong> IDEA会自动为我们添加用于演示的实例代码，由于我们是第一次接触IDEA，这里保持勾选就好。</li></ul><p>没问题之后，我们直接创建项目。进入之后，可以看到已经自动帮助我们创建好了一个<code>java</code>源文件，跟我们之前的例子是一样的。其中包含示例代码：</p><p><img src="https://s2.loli.net/2025/07/07/DtecaMi5o3uAgYK.png" alt="image-20250707173633143"></p><p>如果你的代码出现爆错边红的问题，请等待底部编制索引完成，如果还是存在同样的问题，请重启IDEA再查看：</p><p><img src="https://s2.loli.net/2025/07/07/GPrJ8cUasEC7FZu.png" alt="image-20250707173205542"></p><p>要编译运行我们的Java程序，只需要直接点击左边的三角形（启动按钮）即可：</p><p><img src="https://s2.loli.net/2025/07/07/3RzX5fDtnImv9aB.png" alt="image-20250707173737300"></p><p>点击之后，会在下方自动开始构建：</p><p><img src="https://s2.loli.net/2025/07/07/xU9PWZYFJC1j8ID.png" alt="image-20250707173903478"></p><p>构建完成之后，就会自动执行我们的程序，可以在控制台看到输出的内容了：</p><p><img src="https://s2.loli.net/2025/07/07/OpqSCNLkRmT4KGI.png" alt="image-20250707173935885"></p><p>我们可以看到新增加了一个<code>out</code>目录，这里面就是刚刚编译好的<code>.class</code>文件：</p><p><img src="https://s2.loli.net/2025/07/07/Fui5rMxcEYdBy8N.png" alt="image-20250707173954235"></p><p>IDEA非常强大，即使是编译之后的字节码文件，也可以反编译回原代码的样子：</p><p><img src="https://s2.loli.net/2025/07/07/zUrluI2cwoWYDfN.png" alt="image-20250707174023225"></p><p>IDEA是以项目为单位进行管理的，如果我们想写一个新的Java项目，可以退出当前项目重新创建：</p><p><img src="https://s2.loli.net/2025/07/07/deQhE2yYKiPmLa1.png" alt="image-20250707174127465"></p><p>此时项目列表中就有我们刚刚创建的Java项目了：</p><p><img src="https://s2.loli.net/2025/07/07/qjOcPmlA2TUaKt6.png" alt="image-20250707174145142"></p><p>如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习：</p><p><img src="https://s2.loli.net/2025/07/07/M85NCnvmJEzucxd.png" alt="image-20250707174158634"></p><p>届时会有一个专门的引导教程项目，来教你如何使用各项功能，不过对于新手来说内容有点过多，有耐心的小伙伴可以尝试看一下，学习IDEA使用的各项功能，我们也会在后续的学习过程中逐步为大家介绍IDEA的常用功能。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/8egfulw98v3h680j">https://www.itbaima.cn/zh-CN/document/8egfulw98v3h680j</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>程序设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo渲染器的部分语法以及移植注意事项</title>
    <link href="/2025/08/16/site/"/>
    <url>/2025/08/16/site/</url>
    
    <content type="html"><![CDATA[<h2 id="创建一个新的文件"><a href="#创建一个新的文件" class="headerlink" title="创建一个新的文件"></a>创建一个新的文件</h2><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p>post是默认的布局，但你也可以提供自己的布局。 您可以通过编辑 _config.yml 中的 default_layout 设置来更改默认布局。</p><h3 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局_Layout"></a>布局_Layout</h3><hr><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。 每个布局创建的文件会被保存到不同的路径。 新创建的帖子被保存到 <code>source/_post</code> 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><blockquote><p><strong>禁用布局</strong></p><p>如果你不希望一篇文章（post&#x2F;page）使用主题处理，请在它的 front-matter 中设置 <code>layout: false</code>。 </p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><hr><p>默认情况下，Hexo 使用帖子标题作为其文件名。 您可以编辑 <code>_config.yml</code> 中的 <code>new_post_name</code> 设置去更改默认文件名。 例如， <code>:year-:month-:day-:title.md</code> 将在文件名前加上创建日期。 你可以使用以下占位符：</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td><code>:title</code></td><td>标题（小写，空格将会被替换为短杠）</td></tr><tr><td><code>:year</code></td><td>建立的年份，比如， <code>2015</code></td></tr><tr><td><code>:month</code></td><td>建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td><code>:i_month</code></td><td>建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td><code>:day</code></td><td>建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td><code>:i_day</code></td><td>建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><hr><p>之前，我们在提到了 Hexo 中的一个特殊的布局：<code>draft</code>。 使用此布局初始化的帖子将被保存到 <code>source/_drafts</code> 文件夹中。 您可以使用 <code>发布</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹。 <code>publish</code> 工作方式类似于 <code>new</code> 命令。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>默认情况下不显示草稿 您可以在运行 Hexo 时添加 <code>--draft</code> 选项或在 <code>_config.yml</code> 启用 <code>render_draft</code> 设置来渲染草稿。</p><h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><hr><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件。 例如：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> photo <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章。 以下是您可以在模版中使用的变量：</p><table><thead><tr><th>占位符</th><th>描述</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td></tr><tr><td><code>title</code></td><td>标题</td></tr><tr><td><code>date</code></td><td>文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><hr><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。 如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p><h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><blockquote><p>Front-matter 是文件开头的 YAML 或 JSON 代码块，用于配置写作设置。</p></blockquote><p>Front-matter 是文件开头的 YAML 或 JSON 代码块，用于配置写作设置。 以 YAML 格式书写时，Front-matter 以三个破折号结束；以 JSON 格式书写时，Front-matter 以三个分号结束。</p><p><strong>YAML</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2013</span><span class="hljs-string">/7/13</span> <span class="hljs-number">20</span><span class="hljs-string">:46:25</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p><strong>JSON</strong></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Hello World&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-string">&quot;date&quot;</span>: <span class="hljs-string">&quot;2013/7/13 20:46:25&quot;</span><br><span class="hljs-comment">;;;</span><br></code></pre></td></tr></table></figure><h3 id="设置-默认值"><a href="#设置-默认值" class="headerlink" title="设置 &amp; 默认值"></a><a href="#%E8%AE%BE%E7%BD%AE-%E9%BB%98%E8%AE%A4%E5%80%BC" title="设置 &amp; 默认值"></a>设置 &amp; 默认值<a href="#%E8%AE%BE%E7%BD%AE-%E9%BB%98%E8%AE%A4%E5%80%BC"></a></h3><table><thead><tr><th>设置</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td><td><a href="https://hexo.io/docs/configuration#Writing"><code>config.default_layout</code></a></td></tr><tr><td><code>title</code></td><td>标题</td><td>文章的文件名</td></tr><tr><td><code>date</code></td><td>建立日期</td><td>文件建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td><td>文件更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td><td><code>true</code></td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td><td></td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td><td></td></tr><tr><td><code>permalink</code></td><td>覆盖文章的永久链接. 永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td><code>null</code></td></tr><tr><td><code>excerpt</code></td><td>纯文本的页面摘要。 使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td></td></tr><tr><td><code>disableNunjucks</code></td><td>启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td>false</td></tr><tr><td><code>lang</code></td><td>设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td>继承自 <code>_config.yml</code></td></tr><tr><td><code>published</code></td><td>文章是否发布</td><td>对于 <code>_posts</code> 下的文章为 <code>true</code>，对于 <code>_draft</code> 下的文章为 <code>false</code></td></tr></tbody></table><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a><a href="#%E5%B8%83%E5%B1%80" title="布局"></a>布局<a href="#%E5%B8%83%E5%B1%80"></a></h4><p>根据 <code>_config.yml</code> 中 <a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>default_layout</code></a> 的设置，默认布局是 <code>post</code> 。 当文章中的布局被禁用 (<code>layout: false</code>)，它将不会使用主题处理。 然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>)，它将被渲染成 HTML。</p><p>除非通过 <code>disableNunjucks</code> 设置或 <a href="https://hexo.io/zh-cn/api/renderer#%E7%A6%81%E7%94%A8-Nunjucks-%E6%A0%87%E7%AD%BE">渲染引擎</a> 禁用，否则无论布局如何，<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 总是被处理。</p><h4 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a><a href="#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE" title="分类和标签"></a>分类和标签<a href="#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE"></a></h4><p>只有文章支持分类和标签。 分类按顺序应用于文章，从而形成分类和子分类的层次结构。 标签是在相同的层次结构上定义的，因此它们的出现顺序不重要。</p><p><strong>示例</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit">categories:<br>  - Sports<br>  - Baseball<br><span class="hljs-keyword">tags:</span><br>  - Injury<br>  - Fight<br>  - Shocking<br></code></pre></td></tr></table></figure><p>如果你想应用多个分类层次结构，请使用一个名称列表而不是一个单个名称。 如果 Hexo 在帖子上看到像这种方式定义的分类，它会将该帖子的每个分类视为其自己的独立层次结构。</p><p><strong>示例</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">categories</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">[Sports, Baseball]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">[MLB, American League, Boston Red Sox]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">[MLB, American League, New York Yankees]</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Rivalries</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>浏览器Web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
      <tag>Nodejs</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin程序设计基础 - Kotlin（二）类与对象</title>
    <link href="/2025/08/12/Kotlin%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%20-%20Kotlin%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/08/12/Kotlin%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%20-%20Kotlin%EF%BC%88%E4%BA%8C%EF%BC%89%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/E3kQgAYecmSj7Jo.png" alt="image-20230730164654567"></p><h1 id="Kotlin程序设计中级篇"><a href="#Kotlin程序设计中级篇" class="headerlink" title="Kotlin程序设计中级篇"></a>Kotlin程序设计中级篇</h1><p>我们在前面已经学习了Kotlin程序设计的基础篇，本章我们将继续介绍更多Kotlin特性，以及面向对象编程。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>其实函数我们在一开始就在使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们程序的入口点就是<code>main</code>函数，我们只需要将我们的程序代码编写到主函数中就可以运行了，不过这个函数只是由我们来定义，而不是我们自己来调用。当然，除了主函数之外，我们一直在使用的<code>println</code>也是一个函数，不过这个函数是标准库中已经实现好了的，现在是我们在调用这个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;Hello World!&quot;</span>);    <span class="hljs-comment">//直接通过 函数名称(参数...) 的形式调用函数</span><br></code></pre></td></tr></table></figure><p>那么，函数的具体定义是什么呢？</p><blockquote><p>函数是完成特定任务的独立程序代码单元。</p></blockquote><p>其实简单来说，函数是为了完成某件任务而生的，可能我们要完成某个任务并不是一行代码就可以搞定的，但是现在可能会遇到这种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br><br>    println(<span class="hljs-string">&quot;H&quot;</span>) <span class="hljs-comment">//比如下面这三行代码就是我们要做的任务</span><br>    println(<span class="hljs-string">&quot;A&quot;</span>)<br>    a += <span class="hljs-number">10</span><br><br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">20</span>) &#123;<br>        println(<span class="hljs-string">&quot;H&quot;</span>) <span class="hljs-comment">//这里我们还需要执行这个任务</span><br>        println(<span class="hljs-string">&quot;A&quot;</span>)<br>        a += <span class="hljs-number">10</span><br>    &#125;<br><br>    <span class="hljs-keyword">when</span> (a) &#123;<br>        <span class="hljs-number">30</span> -&gt; &#123;<br>            println(<span class="hljs-string">&quot;H&quot;</span>) <span class="hljs-comment">//这里又要执行这个任务</span><br>            println(<span class="hljs-string">&quot;A&quot;</span>)<br>            a += <span class="hljs-number">10</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们每次要做这个任务时，都要完完整整地将任务的每一行代码都写下来，如果我们的程序中多处都需要执行这个任务，每个地方都完整地写一遍，实在是太臃肿了，有没有一种更好的办法能优化我们的代码呢？</p><p>这时我们就可以考虑使用函数了，我们可以将我们的程序逻辑代码全部编写到函数中，当我们执行函数时，实际上执行的就是函数中的全部内容，也就是按照我们制定的规则执行对应的任务，每次需要做这个任务时，只需要调用函数即可。</p><p>我们来看看，如何创建和使用函数。</p><h3 id="创建和使用函数"><a href="#创建和使用函数" class="headerlink" title="创建和使用函数"></a>创建和使用函数</h3><p>Kotlin函数使用<code>fun</code>关键字声明：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> 函数名称<span class="hljs-params">([函数参数...])</span></span>: 返回值类型 &#123;<br>    <span class="hljs-comment">//函数体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中函数名称也是有要求的，并不是所有的字符都可以用作函数名称，它的命名规则与变量的命名规则基本一致，所以这里就不一一列出了。函数不仅仅需要完成我们的任务，可能某些函数还需要告诉我们结果，我们同样可以将函数返回的结果赋值给变量或是参与运算等等，当然如果我们的函数只需要完成任务，不需要告诉我们结果，返回值类型可以不填，我们先从最简单的开始：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这个函数用于打印一段文本</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Unit</span> &#123;  <span class="hljs-comment">//本质上应该是返回Unit类型，这个类型表示空，类似于Java中的void，默认情况下可以省略</span><br>    println(<span class="hljs-string">&quot;PHP是世界上最好的语言.kt&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要调用这个函数也很简单，只需要像下面这样就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    hello()     <span class="hljs-comment">//调用函数只需使用 函数名() 即可</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过，有些时候，我们可能需要外部传入一些参数来使用，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">say</span><span class="hljs-params">(message: <span class="hljs-type">String</span>)</span></span>&#123;   <span class="hljs-comment">//在定义函数时，可以将参数写到</span><br>    println(<span class="hljs-string">&quot;我说：<span class="hljs-variable">$message</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们在函数的小括号中填入的就是形式参数，这代表调用函数时需要传入的数据，比如这里就是我们要打印的字符串，而实际在调用函数时，填入的内容就是实际参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//在调用带参数的函数时，必须填写实参，否则无法编译通过</span><br>  <span class="hljs-comment">//这里填入的内容就是实际参数</span><br>    say(<span class="hljs-string">&quot;你干嘛&quot;</span>)<br>  <span class="hljs-comment">//也可以将变量作为实际参数传入</span><br>  <span class="hljs-keyword">val</span> str: String = <span class="hljs-string">&quot;哎哟&quot;</span><br>    say(str)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些时候，我们的函数可能需要返回一个计算的结果给调用者，我们也可以设定函数的返回值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这个函数用于计算两个Int数之和</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sum</span><span class="hljs-params">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>)</span></span> : <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b  <span class="hljs-comment">//使用return语句将结果返回</span><br>&#125;<br></code></pre></td></tr></table></figure><p>带返回值的函数，调用之后得到的返回值，可以由变量接收，或是直接作为其他函数的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> result = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)   <span class="hljs-comment">//获取函数返回值</span><br>    println(result)<br>    println(sum(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment">//直接打印函数返回值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意这个<code>return</code>关键字在执行之后，是不会继续执行之后的内容的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(test(-<span class="hljs-number">2</span>))<br>    println(test(<span class="hljs-number">10</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>)</span></span>: String&#123;<br>    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span><br>  println(<span class="hljs-string">&quot;继续&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;World&quot;</span>   <span class="hljs-comment">//如果满足上面条件，在执行return之后，后续无论有没有执行完，都不会再往下了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候，我们也可以设计一些参数带有默认值的函数，如果在调用函数时不填入参数，那么就使用我们一开始设置好的默认值作为实际传入的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test()   <span class="hljs-comment">//调用函数时，如果对应参数有默认值，可以不填</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(text: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;我是默认值&quot;</span>)</span></span>&#123;<br>    println(text)<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用函数时，我们可以手动指定传入的参数对应的是哪一个形式参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(b = <span class="hljs-number">3</span>)  <span class="hljs-comment">//这里如果只想填写第二个参数b，我们可以直接指定吧实参给到哪一个形参</span><br>  test(<span class="hljs-number">3</span>)   <span class="hljs-comment">//这种情况就是只填入第一个实参</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span>, b: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure><p>对于一些内容比较简单的函数，比如上面仅仅是计算两个参数的和，我们可以直接省略掉花括号，像这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span>, b: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span>: <span class="hljs-built_in">Int</span> = a + b   <span class="hljs-comment">//函数的结果直接缩减为 = a + b 效果跟之前是一样的</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(a: <span class="hljs-type">Int</span> = <span class="hljs-number">6</span>, b: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span> = a + b  <span class="hljs-comment">//返回类型可以自动推断，这里可以吧返回类型省掉</span><br></code></pre></td></tr></table></figure><p>这里还需要注意一下，函数的形式参数默认情况下为常量，无法进行修改，只能使用：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/FELmoM7YeyuI5PC.png" alt="image-20230730215022812"></p><p>比较奇葩的是，函数内部也可以定义函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//函数内部定义的函数，无限套娃</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数内的函数作用域是受限的，我们只能在函数内部使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span>&#123;<br>    &#125;<br><br>    <span class="hljs-keyword">inner</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>内部函数可以访问外部函数中的变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span>&#123;<br>        println(a)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们不能同时编写多个同名函数，这会导致冲突：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/MWoR74TGleN58hx.png" alt="image-20231224002414385"></p><p>但是，如果多个同名函数的参数不一致，是允许的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span> = println(<span class="hljs-string">&quot;B&quot;</span>)  <span class="hljs-comment">//参数列表不一致</span><br></code></pre></td></tr></table></figure><p>我们在调用这个函数时，编译器会根据我们传入的实参自动匹配使用的函数是哪一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">...<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(<span class="hljs-string">&quot;&quot;</span>)  <span class="hljs-comment">//结果为B</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上适用于形参列表不同的情况，如果仅仅是返回值类型不同的情况，同样是不允许的：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/x42zKmkeBfdJAhQ.png" alt="image-20231224002803600"></p><p>像这种编写同名但不同参数的函数，我们称为<em>函数的重载</em>。</p><h3 id="再谈变量"><a href="#再谈变量" class="headerlink" title="再谈变量"></a>再谈变量</h3><p>前面我们学习了如何使用变量，只不过当时我们仅仅是在main函数中使用的局部变量，我们也可以将变量的作用域进行提升，将其直接变成一个顶级定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str: String = <span class="hljs-string">&quot;尊嘟假嘟&quot;</span>   <span class="hljs-comment">//跟定义函数一样，直接写在Kt文件中</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，这个变量可以被所有的函数使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str: String = <span class="hljs-string">&quot;尊嘟假嘟&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = println(str)  <span class="hljs-comment">//作用域的提升，使得变量可以被随意使用</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = println(str)<br></code></pre></td></tr></table></figure><p>以上也只是对变量的一些简单使用，现在变量的作用域被提升到顶层，它可以具有更多的一些特性，那么，我们就再来重新认识一下变量，声明一个变量的完整语法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]<br>    [&lt;getter&gt;]<br>    [&lt;setter&gt;]<br></code></pre></td></tr></table></figure><p>前面的我们知道，但是这个getter和setter是个什么鬼？对于这种顶层定义的变量（包括后面类中会用到的成员属性变量）可以具这两个可选的函数，它们本质上是一个get和set函数：</p><ul><li>getter：用于获取这个变量的值，默认情况下直接返回当前这个变量的值</li><li>setter：用于修改这个变量的值，默认情况下直接对这个变量的值进行修改</li></ul><p>我们在使用这种全局变量时，对于变量的获取和设定，本质上都是通过其getter和setter函数来完成的，只不过默认情况下不需要我们去编写，程序编译之后，有点像这样的结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;小明&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span> : String &#123;   <span class="hljs-comment">//编译时自动生成了对应变量的get函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<br>&#125;<br>  <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> &#123;  <span class="hljs-comment">//编译时自动生成了set函数</span><br>   <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>而对于其使用，在编译之后，会变成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(getName())   <span class="hljs-comment">//获取name时本质上是调用getName函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉好神奇，一个变量都能搞这么多花样，这其实是为了后续多态的一些性质而设计的（下一章讲解）</p><p>可以看到，在默认情况下，变量的获取就是直接返回，设置就是直接修改，不过有些时候我们可能希望修改这些变量获取或修改时执行的操作，我们可以手动编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str: String = <span class="hljs-string">&quot;尊嘟假嘟&quot;</span><br>    <span class="hljs-keyword">get</span>() = field + field   <span class="hljs-comment">//使用filed代表当前这个变量(字段)的值，这里返回值拼接的结果</span><br></code></pre></td></tr></table></figure><blockquote><p>这里使用的field准确的说应该是Kotlin提供的”后备字段”，因为我们使用getter和setter本质上替代了原有的获取和修改方式，使其变得更像是函数的调用，因此，为了能够继续像之前使用一个变量那样去操作它本身，就有了这个后备字段。</p></blockquote><p>最后得到的就是：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/5htXuoyN4SVYrIE.png" alt="image-20230823214656414"></p><p>甚至还可以写成这样，在获取的时候执行一些操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str: String = <span class="hljs-string">&quot;尊嘟假嘟&quot;</span><br>    <span class="hljs-keyword">get</span>() &#123;<br>        println(<span class="hljs-string">&quot;获取变量的值：&quot;</span>)   <span class="hljs-comment">//获取的时候打印一段文本</span><br>        <span class="hljs-keyword">return</span> field + <span class="hljs-string">&quot;666&quot;</span><br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = println(str)<br></code></pre></td></tr></table></figure><p>同样的，设置的时候也可以自定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> str: String = <span class="hljs-string">&quot;尊嘟假嘟&quot;</span><br>    <span class="hljs-keyword">get</span>() = field + field<br>    <span class="hljs-keyword">set</span>(value) &#123;    <span class="hljs-comment">//这里的value就是给过来的值</span><br>        println(<span class="hljs-string">&quot;设置变量的值&quot;</span>)<br>        field = value   <span class="hljs-comment">//注意，对于val类型的变量，没有set函数，因为不可变</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>因此，一个变量有些时候可能会写成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> str <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;你干嘛&quot;</span><br></code></pre></td></tr></table></figure><p>当然，默认情况下其实没有必要去重写get和set除非特殊需求。</p><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>我们前面学习了如何调用函数，实际上函数自己也可以调用自己。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    test()   <span class="hljs-comment">//我自己调用自己</span><br>&#125;<br></code></pre></td></tr></table></figure><p>肯定会有小伙伴疑问，函数自己调用自己有什么意义？反而还会导致函数无限的调用下去，无穷无尽，确实，如果不加限制地让函数自己调用自己：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/JhKSzY9TvfXBqGr.png" alt="image-20230821034317397"></p><p>就会出现这种<code>爆栈</code>的情况，这是因为程序的内存是有限的，不可能无限制的继续调用下去，因此，在自我调用到一定的深度时，会被强制终止。所以说这玩意有啥用呢？如果我们对递归函数加以一些限制，或许会有意想不到的发现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(<span class="hljs-number">5</span>)  <span class="hljs-comment">//计算0-5的和</span><br>&#125;<br><br><span class="hljs-comment">//这个函数实现了计算0-n的和的功能</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">//当n等于0的时候就不再向下，而是直接返回0</span><br>    <span class="hljs-keyword">return</span> n + test(n - <span class="hljs-number">1</span>)  <span class="hljs-comment">//n不为0就返回当前的n加上test参数n-1的和</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数最终调用起来就像这样：</p><blockquote><p>test(5) &#x3D; 5 + test(4) &#x3D; 5 + 4 + test(3) &#x3D;  …  &#x3D; 5 + 4 + 3 + 2 + 1 + 0</p></blockquote><p>可以看到，只要合理使用递归函数，加以一定的结束条件，反而能够让我们以非常简洁的形式实现一个需要循环来完成的操作。</p><p>我们可以再来看一个案例：</p><blockquote><p>斐波那契数列是一个非常经典的数列，它的定义是：前两个数是1和1，之后的每个数都是前两个数的和。</p><p>斐波那契数列的前几个数字依次是：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, …</p></blockquote><p>对于求解斐波那契数列第N个数这类问题，我们也可以使用递归来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(fib(<span class="hljs-number">5</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fib</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span>&#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>   <span class="hljs-comment">//我们知道前两个一定是1，所以直接返回</span><br>    <span class="hljs-keyword">return</span> fib(n - <span class="hljs-number">1</span>) + fib(n - <span class="hljs-number">2</span>)   <span class="hljs-comment">//当前fib(n)的结果就是前两个结果之和，直接递归继续找</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉递归函数非常神奇？它甚至可以解决一些动态规划问题、一些分治算法等。</p><p>不过，这种函数的效率就非常低了，相比循环来说，使用递归解决斐波那契问题，时间复杂度会呈指数倍增长，且n大于20时基本可以说很卡了（可以想象一下，每一个fib(n)都会分两个出去，实际上这个中间存在大量重复的计算）</p><p>那么，有没有办法可以将这种尾部作为返回值进行递归的操作优化一下呢？我们可以使用<code>tailrec</code>关键字来实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, sum: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> sum   <span class="hljs-comment">//到底时返回累加的结果</span><br>    <span class="hljs-keyword">return</span> test(n - <span class="hljs-number">1</span>, sum + n)  <span class="hljs-comment">//不断累加</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上在编译之后，会变成这样：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/5vpxkKcOHPBT6dI.png" alt="image-20230821040623152"></p><p>可以看到它变成了一个普通的循环操作，这也是编译器的功劳，同样的，对于斐波那契数列：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fib</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, prev: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, next: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) prev <span class="hljs-keyword">else</span> fib(n - <span class="hljs-number">1</span>, next, prev + next)  <span class="hljs-comment">//从0和1开始不断向后，直到n为0就返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实用库函数介绍"><a href="#实用库函数介绍" class="headerlink" title="实用库函数介绍"></a>实用库函数介绍</h3><p>Kotlin为我们内置了大量实用的库函数，我们可以使用这些库函数来快速完成某些操作。</p><p>比如我们前面使用的<code>println</code>就是Kotlin提供的库函数，我们可以使用这个函数快速进行数据打印：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Hello World&quot;</span>)  <span class="hljs-comment">//这里其实就是在调用函数，传入了一个String类型的参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那既然现在有输出，能不能让用户输入，然后我们来读取呢？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> text = readln()<br>    println(<span class="hljs-string">&quot;读取到用户输入：<span class="hljs-variable">$text</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在控制台输入一段文本，然后回车结束：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/7IOsxj4eqMPo8kc.png" alt="image-20230731011757655"></p><p>Kotlin提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> kotlin.math.*    <span class="hljs-comment">//我们需要使用import来引入某些库，这样才能使用库函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-number">1.0</span>.pow(<span class="hljs-number">4.0</span>)  <span class="hljs-comment">//我们可以使用pow方法直接计算a的b次方</span><br>    abs(-<span class="hljs-number">1</span>);    <span class="hljs-comment">//abs方法可以求绝对值</span><br>    max(<span class="hljs-number">19</span>, <span class="hljs-number">20</span>);    <span class="hljs-comment">//快速取两个数的最大值</span><br>    min(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);   <span class="hljs-comment">//快速取最小值</span><br>    sqrt(<span class="hljs-number">9.0</span>);    <span class="hljs-comment">//求一个数的算术平方根</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，三角函数肯定也是安排上了的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//这里我们可以直接使用库中预设好的PI</span><br>    sin(PI / <span class="hljs-number">2</span>);     <span class="hljs-comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span><br>    cos(PI);       <span class="hljs-comment">//求π的余弦值</span><br>    tan(PI / <span class="hljs-number">4</span>);    <span class="hljs-comment">//求π/4的正切值</span><br><br>    asin(<span class="hljs-number">1.0</span>);     <span class="hljs-comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span><br>    acos(<span class="hljs-number">1.0</span>);<br>    atan(<span class="hljs-number">0.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(sin(Math.PI));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/Nyn762CYBstz1TF.png" alt="image-20230731010301773"></p><p>正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li>1.2246467991473532×10−161.2246467991473532×10−16</li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>我们也可以计算对数函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ln(E)    <span class="hljs-comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span><br>    log10(<span class="hljs-number">100.0</span>)    <span class="hljs-comment">//10为底的对数函数</span><br>  log2(<span class="hljs-number">8.0</span>)    <span class="hljs-comment">//2为底的对数函数</span><br>    <span class="hljs-comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span><br>    <span class="hljs-keyword">val</span> a = ln(<span class="hljs-number">4.0</span>) / ln(<span class="hljs-number">2.0</span>) <span class="hljs-comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span><br>    println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ceil(<span class="hljs-number">4.5</span>) <span class="hljs-comment">//通过使用ceil来向上取整</span><br>    floor(<span class="hljs-number">5.6</span>) <span class="hljs-comment">//通过使用floor来向下取整</span><br>&#125;<br></code></pre></td></tr></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><h3 id="高阶函数与lambda表达式"><a href="#高阶函数与lambda表达式" class="headerlink" title="高阶函数与lambda表达式"></a>高阶函数与lambda表达式</h3><p><strong>注意：</strong>  这一部分比较难理解，如果看不懂可以后面回来看。</p><p>Kotlin中的函数属于一等公民，它支持很多高级特性，甚至可以被存储在变量中，可以作为参数传递给其他高阶函数并从中返回，就想使用普通变量一样。 为了实现这一特性，Kotlin作为一种静态类型的编程语言，使用了一系列函数类型来表示函数，并提供了一套特殊的语言结构，例如lambda表达式。</p><p>那么这里说的高阶函数是什么，lambda表达式又是什么呢？</p><blockquote><p>正是得益于函数可以作为变量的值进行存储，因此，如果一个函数接收另一个函数作为参数，或者返回值的类型就是一个函数，那么该函数称为高阶函数。</p></blockquote><p>要声明函数类型，需要按照以下规则：</p><ul><li>所有函数类型都有一个括号，并在括号中填写参数类型列表和一个返回类型，比如：<code>(A, B) -&gt; C </code> 表示一个函数类型，该类型表示接受类型<code>A</code>和<code>B</code>的两个参数并返回类型<code>C</code>的值的函数。参数类型列表可为空的，比如<code>() -&gt; A</code>，注意，即使是<code>Unit</code>返回类型也不能省略。</li></ul><p>我们可以像下面这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//典型的函数类型 (参数...) -&gt; 类型  小括号中间是一个剪头一样的符号，然后最后是返回类型</span><br><span class="hljs-keyword">var</span> func0: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>  <span class="hljs-comment">//这里的 (Int) -&gt; Unit 表示这个变量存储的是一个有一个int参数并且没有返回值的函数</span><br><span class="hljs-keyword">var</span> func1: (<span class="hljs-built_in">Double</span>, <span class="hljs-built_in">Double</span>) -&gt; String   <span class="hljs-comment">//同理，代表两个Double参数返回String类型的函数</span><br></code></pre></td></tr></table></figure><p>同样的，作为函数的参数也可以像这样表示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(other: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数类型的变量，我们可以将其当做一个普通的函数进行调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(other: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span>&#123;<br>    println(other(<span class="hljs-number">1</span>))  <span class="hljs-comment">//这里提供的函数接受一个Int参数返回string，那么我们可以像普通函数一样传入参数调用它</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数可以接受函数作为参数，所以说你看到这样的套娃场景也不奇怪：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> func: (<span class="hljs-built_in">Int</span>) -&gt; ((String) -&gt; <span class="hljs-built_in">Double</span>)<br></code></pre></td></tr></table></figure><p>不过这样写可能有些时候不太优雅，我们可以为类型起别名来缩短名称：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">typealias</span> HelloWorld = (String) -&gt; <span class="hljs-built_in">Double</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> func: HelloWorld<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，函数类型我们知道如何表示了，如何具体表示一个函数呢？我们前面都是通过<code>fun</code>来声明函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而现在我们的变量也可以直接表示这个函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//这个变量表示的也是(String) -&gt; Int这种类型的函数</span><br>    <span class="hljs-keyword">var</span> func: (String) -&gt; <span class="hljs-built_in">Int</span> = ::test   <span class="hljs-comment">//使用双冒号来引用一个现成的函数（包括我们后续会学习的成员函数、构造函数等）</span><br>&#125;<br><br><span class="hljs-comment">//这个函数正好与上面的变量表示的函数类型一致</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>&#125;<br></code></pre></td></tr></table></figure><p>除了引用现成的函数之外，我们也可以使用匿名函数，这是一种没有名称的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func: (String) -&gt; <span class="hljs-built_in">Int</span> = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;  <span class="hljs-comment">//这里写了fun关键字后，并没有编写函数名称，这种函数就是匿名函数，因为在这里也不需要什么名字，只需要参数列表函数体</span><br>        println(<span class="hljs-string">&quot;这是传入的内容<span class="hljs-variable">$str</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">666</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>匿名函数除了没名字之外，其他的用法跟函数是一样的。</p><p>最后，我们来看看今天的重量级嘉宾，不要小看了Kotlin的语法，我们也可以使用Lambda表达式来表示一个函数实例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> func: (String) -&gt; <span class="hljs-built_in">Int</span> = &#123;  <span class="hljs-comment">//一个Lambda表达式只需要直接在花括号中编写函数体即可</span><br>        println(<span class="hljs-string">&quot;这是传入的参数<span class="hljs-variable">$it</span>&quot;</span>)   <span class="hljs-comment">//默认情况下，如果函数只有一个参数，我们可以使用it代表传入的参数</span><br>        <span class="hljs-number">666</span>   <span class="hljs-comment">//跟之前的if表达式一样，默认最后一行为返回值</span><br>    &#125;<br>  func(<span class="hljs-string">&quot;HelloWorld!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉特别简便？</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/fsxB2UhpXZewk4Q.png" alt="image-20230730230512284"></p><p>对于参数有多个的情况，我们也可以这样进行编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func: (String, String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; a, b -&gt;   <span class="hljs-comment">//我们需要手动添加两个参数这里的形参名称，不然没法用他两</span><br>        println(<span class="hljs-string">&quot;这是传入的参数<span class="hljs-variable">$a</span>, 第二个参数<span class="hljs-variable">$b</span>&quot;</span>)   <span class="hljs-comment">//直接使用上面的形参即可</span><br>    &#125;<br>  <span class="hljs-keyword">val</span> func2: (String, String) -&gt; <span class="hljs-built_in">Unit</span> = &#123; _, b -&gt;<br>        println(<span class="hljs-string">&quot;这是传入的第二个参数<span class="hljs-variable">$b</span>&quot;</span>)   <span class="hljs-comment">//假如这里不使用第一个参数，也可以使用_下划线来表示不使用</span><br>    &#125;<br>    func(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/R9WjhIUinaP465p.png" alt="image-20230730230633880"></p><p>是不是感觉玩的非常高级？还有更高级的在后面呢！</p><p>我们接着来看，如果我们现在想要调用一个高阶函数，最直接的方式就是下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func: (<span class="hljs-built_in">Int</span>) -&gt; String = &#123; <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span> &#125;<br>    test(func)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(func(<span class="hljs-number">66</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>当然我们也可以直接把一个Lambda作为参数传入作为实际参数使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(&#123; <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span> &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>不过这样还不够简洁，在Kotlin中，如果函数的最后一个形式参数是一个函数类型，可以直接写在括号后面，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">test() &#123; <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span> &#125;<br></code></pre></td></tr></table></figure><p>由于小括号里面此时没有其他参数了，还能继续省，直接把小括号也给干掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">test &#123; <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span> &#125;   <span class="hljs-comment">//干脆连小括号都省了，这语法真的绝</span><br></code></pre></td></tr></table></figure><p>当然，如果在这之前有其他的参数，只能写成这样了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(<span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span> &#125;<br>&#125;<br><br><span class="hljs-comment">//这里两个参数，前面还有一个int类型参数，但是同样的最后一个参数是函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>, func: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(func(<span class="hljs-number">66</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这种语法也被称为 尾随lambda表达式，能省的东西都省了，不过只有在最后一个参数是函数类型的情况下才可以，如果不是最后一位，就没办法做到尾随了。</p><p>最后需要特别注意的是，在Lambda中没有办法直接使用<code>return</code>语句返回结果，而是需要用到之前我们学习流程控制时用到的标签：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> func: (<span class="hljs-built_in">Int</span>) -&gt; String = <span class="hljs-symbol">test@</span>&#123;<br>        <span class="hljs-comment">//比如这里判断到it大于10就提前返回结果</span><br>        <span class="hljs-keyword">if</span>(it &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@test</span> <span class="hljs-string">&quot;我是提前返回的结果&quot;</span><br>        println(<span class="hljs-string">&quot;我是正常情况&quot;</span>)<br>        <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span><br>    &#125;<br>    test(func)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(func(<span class="hljs-number">66</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是函数调用的尾随lambda表达式，默认的标签名字就是函数的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    testName &#123;  <span class="hljs-comment">//默认使用函数名称</span><br>        <span class="hljs-keyword">if</span>(it &gt; <span class="hljs-number">10</span>) <span class="hljs-keyword">return</span><span class="hljs-symbol">@testName</span> <span class="hljs-string">&quot;我是提前返回的结果&quot;</span><br>        println(<span class="hljs-string">&quot;我是正常情况&quot;</span>)<br>        <span class="hljs-string">&quot;收到的参数为<span class="hljs-variable">$it</span>&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">testName</span><span class="hljs-params">(func: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">String</span>)</span></span> &#123;<br>    println(func(<span class="hljs-number">66</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，为什么要这么麻烦呢，还要打标签才能返回，这不多此一举么？这个问题我们会在下一节内联函数中进行讲解。</p><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>使用高阶函数会可能会影响运行时的性能：每个函数都是一个对象，而且函数内可以访问一些局部变量，但是这可能会在内存分配（用于函数对象和类）和虚拟调用时造成额外开销。</p><p>为了优化性能，开销可以通过内联Lambda表达式来消除。使用<code>inline</code>关键字会影响函数本身和传递给它的lambdas，它能够让方法的调用在编译时，直接替换为方法的执行代码，什么意思呢？比如下面这段代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test()<br>&#125;<br><br><span class="hljs-comment">//添加inline表示内联函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>  println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>  println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于test函数是内联函数，在编译之后，会原封不动地把代码搬过去：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)   <span class="hljs-comment">//这里是test函数第一行，直接搬过来</span><br>  println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>  println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，如果是一个高阶函数，效果那就更好了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123; println(<span class="hljs-string">&quot;打印：<span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>&#125;<br><br><span class="hljs-comment">//添加inline表示内联函数</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>    func(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于test函数是内联的高阶函数，在编译之后，不仅会原封不动地把代码搬过去，还会自动将传入的函数参数贴到调用的位置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)   <span class="hljs-comment">//这里是test函数第一行</span><br>  <span class="hljs-keyword">val</span> it = <span class="hljs-string">&quot;HelloWorld&quot;</span>  <span class="hljs-comment">//这里是函数内传入的参数</span><br>    println(<span class="hljs-string">&quot;打印：<span class="hljs-variable">$it</span>&quot;</span>)  <span class="hljs-comment">//第二行是调用传入的函数，自动贴过来</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内联会导致编译出来的代码变多，但是同样的换来了性能上的提升，不过这种操作仅对于高阶函数有显著效果，普通函数实际上完全没有内联的必要，也提升不了多少性能。</p><p>注意，内联函数中的函数形参，无法作为值给到变量，只能调用：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/ufLoiIyGKTbYV9H.png" alt="image-20230731131403842"></p><p>同样的，由于内联，导致代码被直接搬运，所以Lambda中的return语句可以不带标签，这种情况会导致直接返回：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123; <span class="hljs-keyword">return</span> &#125;  <span class="hljs-comment">//内联高阶函数的Lambda参数可以直接写return不指定标签</span><br>    println(<span class="hljs-string">&quot;调用上面方法之后&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    func(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>    println(<span class="hljs-string">&quot;调用内联函数之后&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的运行结果就是，直接结束，两句println都不会打印，这种情况被称为<strong>非局部返回</strong>。</p><p>回到上一节最后我们提出的问题，实际上，在Kotlin中Lambda表达式支持一个叫做”标签返回”（labeled return）的特性，这使得你能够从一个Lambda表达式中返回一个值给外围函数，而不是简单地返回给Lambda表达式所在的最近的封闭函数，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123; <span class="hljs-keyword">return</span><span class="hljs-symbol">@main</span> &#125;  <span class="hljs-comment">//标签可以直接指定为外层函数名称main来提前终止整个外部函数</span><br>    println(<span class="hljs-string">&quot;调用上面方法之后&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    func(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>    println(<span class="hljs-string">&quot;调用内联函数之后&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果跟上面是完全一样的，为了避免这种情况，我们也可以像之前一样将标签写为@test来防止非局部返回。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test &#123; <span class="hljs-keyword">return</span><span class="hljs-symbol">@test</span> &#125;  <span class="hljs-comment">//这样就只会使test返回，而不会影响到外部函数了</span><br>    println(<span class="hljs-string">&quot;调用上面方法之后&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候，可能一个内联的高阶函数中存在好几个函数参数，但是我们希望其中的某一个函数参数不使用内联，能够跟之前一样随意当做变量使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    test(&#123; println(<span class="hljs-string">&quot;我是一号：<span class="hljs-variable">$it</span>&quot;</span>) &#125;, &#123; println(<span class="hljs-string">&quot;我是二号：<span class="hljs-variable">$it</span>&quot;</span>) &#125;)<br>&#125;<br><br><span class="hljs-comment">//在不需要内联的函数形参上添加noinline关键字，来防止此函数的调用内联</span><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(func: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Unit</span>, <span class="hljs-keyword">noinline</span> func2: (<span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Unit</span>)</span></span>&#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>    func(<span class="hljs-string">&quot;HelloWorld&quot;</span>)<br>  <span class="hljs-keyword">var</span> a = func2  <span class="hljs-comment">//这样就不会报错，但是不会内联了</span><br>    func2(<span class="hljs-number">666</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后编译出来的结果，类似于：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;这是一个内联函数&quot;</span>)<br>    <span class="hljs-keyword">val</span> it = <span class="hljs-string">&quot;HelloWorld&quot;</span><br>    println(<span class="hljs-string">&quot;打印：<span class="hljs-variable">$it</span>&quot;</span>)<br>  <span class="hljs-comment">//第二个参数由于不是内联，这里依然作为Lambda使用</span><br>    <span class="hljs-keyword">val</span> func2: (<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span> = &#123; println(<span class="hljs-string">&quot;我是二号：<span class="hljs-variable">$it</span>&quot;</span>) &#125;<br>    func2(<span class="hljs-number">666</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于目前知识的学习还不太够，函数我们只能先暂时告一段落，在后续的学习中我们会继续认识更多函数的特性。</p><hr><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>在之前，我们一直在使用顶层定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">20</span>   <span class="hljs-comment">//直接在kt文件中定义变量</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-comment">//直接在kt文件中定义函数</span><br>    println(<span class="hljs-string">&quot;我是测试方法&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>而学习了类之后，这些内容也可以定义到类中，作为类的属性存在。</p><p>类的概念我们在生活中其实已经听说过很多了。</p><p>人类、鸟类、鱼类… 所谓类，就是对一类事物的描述，是抽象的、概念上的定义，比如鸟类，就泛指所有具有鸟类特征的动物。比如人类，不同的人，有着不同的性格、不同的爱好、不同的样貌等等，但是他们根本上都是人，所以说可以将他们抽象描述为人类。</p><p>对象是某一类事物实际存在的每个个体，因而也被称为实例（instance）我们每个人都是人类的一个实际存在的个体。</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/19/U2P7qWOtRz5bhFY.png" alt="image-20220919203119479"></p><p>所以说，类就是抽象概念的人，而对象，就是具体的某一个人。</p><ul><li>A：是谁拿走了我的手机？</li><li>B：是个人。（某一个类型）</li><li>A：我还知道是个人呢，具体是谁呢？</li><li>B：是XXX。（具体某个对象）</li></ul><p>而在Kotlin中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象，像这种编程方式，我们称为<strong>面向对象编程</strong>，我们除了去使用Kotlin给我们提供的类型之外，我们也可以使用自己定义的类。</p><h3 id="类的定义与对象创建"><a href="#类的定义与对象创建" class="headerlink" title="类的定义与对象创建"></a>类的定义与对象创建</h3><p>前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p>Kotlin中的类使用关键字<code>class</code>声明，我们可以直接在默认的Main.kt文件中编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//在没有任何内容时，花括号可以省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p>除了直接在某个.kt文件中直接编写之外，为了规范，我们一般将一个类单独创建一个文件，我们可以右键<code>src</code>目录：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/hHwPDdyGv1jBUkZ.png" alt="image-20230730165458965"></p><p>这里选择新建，然后选择Kotlin类&#x2F;文件选项，然后创建一个类：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/JyILfdRTBVPteQw.png" alt="image-20230730165447840"></p><p>文件创建完成后，默认也会为我们生成类的定义，并且类名称与创建的类文件是一模一样的：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/IqKNH6iyzWhak9R.png" alt="image-20230730165605898"></p><p>这是一个非常简单的类，但是肯定远远不够。</p><p>既然是学生类，那么肯定有学生相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？我们需要指定类的构造函数，构造函数也是函数的一种，但是它是专用于对象的创建，Kotlin中的类可以添加一个<em>主构造函数</em>和一个或多个<em>次要构造函数</em>。主构造函数是类定义的一部分，像下面这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-comment">//比如学生有name和age属性，那么我们可以在类名后面constructor的括号中编写，并用逗号隔开</span><br>  <span class="hljs-comment">//这里跟定义变量差不多，也是变量名称:类型，这些作为类的成员属性，后续可以在类中使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果主构造函数没有任何注释或可见性修饰符，则可以省略<code>constructor</code>关键字，如果类中没有其他内容要写，可以直接省略花括号，最后就变成这样了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><p>但是，这里仅仅是定义了构造函数的参数，这还不是类的属性，那么我们要怎么才能定义为类的属性呢？我们可以为这些属性添加<code>var</code>或<code>val</code>关键字来表示这个属性是可变还是不变的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>)<br></code></pre></td></tr></table></figure><p>这跟我们之前使用变量基本一致：</p><ul><li><code>val</code>：不可变属性</li><li><code>var</code>：可变属性</li></ul><p>这样才算是定义了类的属性，我们也可以给这些属性设置初始值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">18</span>)  <span class="hljs-comment">//默认每个学生18岁</span><br></code></pre></td></tr></table></figure><p>除了将属性添加到构造函数中，我们也可以将这些属性直接作为类的成员变量写到类中，但是这种情况必须要配一个默认值，否则无法通过编译：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;&quot;</span>   <span class="hljs-comment">//必须配一个默认值</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以不编写主构造函数也能定义属性，但是这里仍然会隐式生成一个无参的构造函数，为了构造函数能够方便地传值初始化，也可以像这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">var</span> name: String = name   <span class="hljs-comment">//通过构造函数传递过来</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = age<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果各位不希望这些属性在一开始就有初始值，而是之后某一个时刻去设定初始值，我们也可以为其添加懒加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> name: String   <span class="hljs-comment">//懒加载的属性可以不用在一开始赋值，但是在下一次使用之前一定要先完成赋值，否则报错</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>并且，像这样编写的类成员变量，也可以自定义对应的getter和setter属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span>(<span class="hljs-keyword">var</span> width: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> height: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">val</span> area <span class="hljs-keyword">get</span>() = width * height<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，现在我们定义了主构造函数之后，该怎么去使用它呢？</p><p>跟我们调用普通函数一样，这里的函数名称就是类的名称，如果一个类没有编写构造函数，那么这个类默认情况下使用一个无参构造函数创建：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//我们可以直接使用 类名() 的形式创建对象</span><br>    Student()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是有构造函数的类，我们只需要填写需要的参数即可，调用之后，类的属性就是这里我们给进去的参数了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//我们可以直接使用 类名(参数, 参数...) 的形式创建</span><br>    Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就成功创建出了一个名字为小明的学生类型对象，但是这个对象仅仅是创建出来还不行，我们肯定需要去使用它。</p><p>实际上，我们可以像之前使用基本类型一样，使用对象，我们也可以使用一个变量去接收生成出来的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//使用Student类型的变量接收构造方法得到的对象</span><br>    <span class="hljs-keyword">var</span> stu: Student = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有一个我们需要注意的点，这里的stu存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> p1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> p2 = p1<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/19/GBPaNZsr2MSKvCq.png" alt="image-20220919211443657"></p><p>我们可以来测试一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> s2 = s1<br>    println(s1 === s2)  <span class="hljs-comment">//使用 === 可以判断两个变量引用的是不是同一个对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果我们像这样去编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> s1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> s2 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)   <span class="hljs-comment">//即使名字和年龄一样，但是由于这里重新创建了一次对象</span><br>    println(s1 === s2)  <span class="hljs-comment">//这里比较的就不是同一个对象了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>.</code>运算符来访问对象的属性，比如我们要访问小明这个学生对象的属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(<span class="hljs-string">&quot;对象的name = <span class="hljs-subst">$&#123;stu.name&#125;</span>, age = <span class="hljs-subst">$&#123;stu.age&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>获取和修改都是可以的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    stu.name = <span class="hljs-string">&quot;大明&quot;</span><br>    stu.age = <span class="hljs-number">10</span>   <span class="hljs-comment">//由于age属性是val，所以说无法修改，只能读取</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，不同对象的属性是分开独立存放的，虽然都是统一由类完成定义，但是每个对象都有一个自己的空间，修改一个对象的属性并不会影响到另一个相同类型的对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> stu2 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    stu1.name = <span class="hljs-string">&quot;小红&quot;</span><br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;stu1.name&#125;</span>, <span class="hljs-subst">$&#123;stu2.name&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>除了直接使用主构造函数创建对象外，我们也可以添加一些次要构造函数，比如我们的学生可以只需要一个名字就能完成创建，我们可以直接在类中编写一个次要构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String) : <span class="hljs-keyword">this</span>(name, <span class="hljs-number">18</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果该类有一个主构造函数，则每个次要构造函数需要通过另一个次要构造函数直接或间接委托给主构造函数。委托到同一类的另一个构造函数是<code>this</code>关键字完成的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>  <span class="hljs-comment">//这里可以使用constructor关键字继续声明次要构造函数</span><br>  <span class="hljs-comment">//次要构造函数中的参数仅仅是表示传入的参数，不能像主构造函数那样定义属性</span><br>  <span class="hljs-comment">//这里的this表示是当前这个类，this()就是调用当前类的构造函数</span><br>    <span class="hljs-keyword">constructor</span>(name: String) : <span class="hljs-keyword">this</span>(name, <span class="hljs-number">18</span>)  <span class="hljs-comment">//这里其实是调用主构造函数，并且参数只有name，年龄直接给个默认值18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果一个类没有主构造函数，那么我们也可以直接在在类中编写次要构造函数，但是不需要主动委托一次主构造函数，他这里会隐式包含，所以说我们直接写就行了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String)  <span class="hljs-comment">//注意，这里的参数不是类属性，仅仅是一个形参！</span><br>&#125;<br></code></pre></td></tr></table></figure><p>次要构造函数和主构造函数一样，都可以用于对象的创建：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu1 = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> stu2 = Student(<span class="hljs-string">&quot;小红&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>并且次要构造函数可以编写自定义的函数体：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) &#123;   <span class="hljs-comment">//在使用辅助构造函数初始化对象时，会执行里面的内容</span><br>        println(<span class="hljs-string">&quot;我的名字是: <span class="hljs-variable">$str</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，主构造函数相比次要（辅助）构造函数：</p><ul><li><strong>主构造函数：</strong> 可以直接在主构造函数中定义类属性，使用更方便，但是主构造函数只能存在一个，并且无法编写函数体，只有为类属性做初始化赋值的效果。</li><li><strong>辅助（次要）构造函数：</strong> 可以存在多个，并且可以自定义函数体，但是无法像主构造函数那样定义类属性，并且当类具有主构造函数时，所有次要构造函数必须直接或间接地调用主构造函数。</li></ul><p>Kotlin语言本身比较灵活，类中并不是一定需要主构造函数，全部写辅助构造函数也是可以的，但是再怎么都得有构造函数。</p><p>下一部分我们接着来讨论对象的初始化。</p><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><p>在对象创建时，我们可能需要做一些初始化工作，我们可以使用初始化代码块来完成，初始化代码块使用init关键字来完成。假如我们希望对象在创建的时候，如果年龄不足18岁，那么就设定为18岁：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;  <span class="hljs-comment">//由于主构造函数无法编写函数体</span><br>  <span class="hljs-comment">//因此我们可以在init的花括号中编写初始化代码</span><br>  <span class="hljs-comment">//注意这段初始化代码块，是在上面的类属性被赋值之后才执行的，所以说能拿到已经赋值的age属性</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;我是初始化操作&quot;</span>)<br>        <span class="hljs-keyword">if</span>(age &lt; <span class="hljs-number">18</span>) age = <span class="hljs-number">18</span><br>        println(<span class="hljs-string">&quot;初始化操作结束&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们在创建对象的时候，就会在创建的时候自动执行初始化代码块里面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">15</span>)<br>    println(stu.age)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到初始化操作开始执行了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/3CEnew5rgsTSlud.png" alt="image-20230731181721090"></p><p>初始化操作不仅仅可以有一个，也可以有很多个：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//注意，多个初始化操作时，从上往下按顺序执行</span><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;我是一号初始化操作&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;我是二号初始化操作&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于将成员属性写到类中的情况，同样是按照顺序向下执行，比如：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/Bk56AGpSq28E4Y7.png" alt="image-20230731195222026"></p><p>因为成员变量a是在初始化代码块的后面才初始化的，这里会报错。</p><p>如果一个类具有次要构造函数，那么我们也可以直接在次要构造函数中编写一些初始化代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String) : <span class="hljs-keyword">this</span>(name, <span class="hljs-number">18</span>) &#123;<br>        println(<span class="hljs-string">&quot;我是次要构造函数中的语句&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用对应的次要构造函数时，就会执行次要构造函数中的初始化代码了。</p><p>这里需要注意一下，次要构造函数实际上需要先执行主构造函数，而在执行主构造函数时，会优先将之前我们讲解的初始化代码块执行，比如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;我是初始化代码块&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">constructor</span>(name: String) : <span class="hljs-keyword">this</span>(name, <span class="hljs-number">18</span>) &#123;<br>        println(<span class="hljs-string">&quot;我是次要构造函数&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>无论是有主构造函数还是没有主构造函数（会生成一个默认的无参构造函数）都会先执行。</p><h3 id="类的成员函数"><a href="#类的成员函数" class="headerlink" title="类的成员函数"></a>类的成员函数</h3><p>现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p>而对象也可以做出一些行为，我们可以通过定义函数来实现，类的函数和我们之前编写的函数有一些区别，它是属于这个类的，我们之前使用的函数都是直接编写在Kt文件中，它们都是顶级函数。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-comment">//这个函用于跟大家打招呼</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;大家好啊&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要使用类的成员函数，我们只能通过对象来进行调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>  <span class="hljs-comment">//调用类中的成员方法，同样使用.运算符即可</span><br>    stu.hello()  <span class="hljs-comment">//让小明这个对象给大家打招呼</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是稍微有一些体会了？好像真的是我们在让对象执行一个动作一样。在类的成员函数中，我们可以直接访问当前类对象中的一些属性，比如我们这里的用户名和年龄：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;<br>        println(<span class="hljs-string">&quot;大家好啊，我叫<span class="hljs-variable">$name</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，这里我们访问的name和age属性，是当前这个对象的name和age属性。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    stu.hello()  <span class="hljs-comment">//让小明这个对象给大家打招呼</span><br><br>    <span class="hljs-keyword">val</span> stu2 = Student(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">17</span>)<br>    stu2.hello()  <span class="hljs-comment">//让小红这个对象给大家打招呼</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/20/2vmhsCRXpPzojiD.png" alt="image-20220920101033325"></p><p>注意，下面这种情况，我们需要特殊处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-comment">//此时函数的参数也有一个name变量，而类的成员也有一个name属性</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>&#123;<br>        <span class="hljs-comment">//这里得到的name是哪一个？</span><br>        println(<span class="hljs-string">&quot;大家好啊，我叫<span class="hljs-variable">$name</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果函数中的变量存在歧义，那么优先使用作用域最近的一个，比如函数形参的name作用域更近，那么这里的name拿到的一个是形参name，而不是类的成员属性name。</p><p>如果我们需要获取的是类中的成员属性，需要使用<code>this</code>关键字来表示当前类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>&#123;<br>    <span class="hljs-comment">//使用this关键字表示当前对象，这样就可以指定这里是类中的this了</span><br>    println(<span class="hljs-string">&quot;大家好啊，我叫<span class="hljs-subst">$&#123;this.name&#125;</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，如果作用域不冲突，使用类中属性<code>this</code>可以省略。</p><p>在类中，我们同样可以定义多个同名但不同参数的函数实现重载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;大家好啊，我叫<span class="hljs-subst">$&#123;this.name&#125;</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了&quot;</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">(gender: <span class="hljs-type">String</span>)</span></span> = println(<span class="hljs-string">&quot;大家好啊，我叫<span class="hljs-subst">$&#123;this.name&#125;</span>，今年<span class="hljs-subst">$&#123;age&#125;</span>岁了，性别<span class="hljs-subst">$&#123;gender&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上类中的函数使用起来跟我们之前定义的大差不差，只不过多了更多用法而已。</p><h3 id="再谈基本类型"><a href="#再谈基本类型" class="headerlink" title="再谈基本类型"></a>再谈基本类型</h3><p>在Kotlin中，万物皆为对象，实际上我们在上一章学习的全部基本类型，都是官方为我们提供的类。</p><p>现在我们学习了类与对象的知识，就可以来重新认识一下这些基本类型，实际上这些基本类型同样是类，也具有一些属性，以及一些类中的成员函数。实际上在上一章中，我们就已经开始使用类和对象了，我们对这些基本类型的操作同样是在操作对象：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>   <span class="hljs-comment">//这里其实是一个Int类型的对象，值为10，而a持有的是对这个Int对象的引用</span><br>    <span class="hljs-keyword">var</span> b = a    <span class="hljs-comment">//这里的b复制了对上面Int类型对象的引用</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>特别说明：</strong>  在Kotlin中，虽然编码时万物皆对象，但是在最终编译时，会根据上下文进行优化性能，大部分情况下会优先编译为Java原生基本数据类型（不是对象）而另一部分情况下才会编译为Java中的Integer包装类型。因此很容易出现以下迷惑行为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">12345</span><br><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Int</span> = <span class="hljs-number">12345</span><br>println(a === b)   <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">12345</span><br><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Int</span>? = <span class="hljs-number">12345</span><br>println(a === b)   <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>各位小伙伴可以在完整学习Java和后续Kotlin内容之后再来探究这个问题。</p></blockquote><p>既然这些基本类型也是类，那么肯定同样具有成员属性和成员函数，我们可以使用这些成员方法方便我们的项目开发，比如我们之前遇到的一个很麻烦的问题，不同类型的数无法相互转换：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/gQAek7htrqdTxja.png" alt="image-20230731233455602"></p><p>这些时候可能我们需要将对应类型的数据转换为其他类型，那么该怎么办呢，实际上，在这些基本类型中都提供了对应类型转换成员函数，这里我们可以使用<code>toInt</code>来直接将Double类型的数据转换为Int类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1.25</span>.toInt()  <span class="hljs-comment">//使用类中的类型转换函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以编译通过了。同样的，每个基本类型都有对应的类型转换函数，而且非常全面，比如Int类型：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/31/fEKUqiO5PmXBzdv.png" alt="image-20230731233807465"></p><p>有了这些成员函数，就大幅度方便了我们的类型转换，再比如我们常见的String类型，也有很多函数可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;HelloWorld&quot;</span><br>  <span class="hljs-comment">//使用lowercase和uppercase可以快速将字符串中的字母进行大小写转换</span><br>    println(a.lowercase())<br>    println(a.uppercase())<br>&#125;<br></code></pre></td></tr></table></figure><p>不过需要注意的是，我们在前面就说过，字符串一旦创建就是不可变的，因此，字符串中所有的函数得到的新字符串，都是重新创建的一个新的对象，而不是在原本的字符串上进行修改。</p><p>我们继续来看看一些有意思的函数，比如我们想批量替换字符串中的某些内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Hello World!&quot;</span><br>    println(a.replace(<span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>将字符串中所有的字母<code>o</code>替换为<code>a</code>，直接使用replace函数就能直接生成替换之后的字符串了。又比如我们要判断某个字符串是否以指定文本开头：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Hello World!&quot;</span><br>    println(a.startsWith(<span class="hljs-string">&quot;Hel&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这里经过判断得到了一个Boolean类型的结果，还有很多用于判断字符串是否为空、是否有空格等等的函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;Hello World!&quot;</span><br>    a.isBlank()<br>    a.isEmpty()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们还发现，这些基本类型中有一些比较特殊的函数，比如<code>plus</code>函数：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/Ax4VjEs2IJpadXy.png" alt="image-20230801000753879"></p><p>这个函数在类中定义长这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other: <span class="hljs-type">Long</span>)</span></span>: <span class="hljs-built_in">Long</span><br></code></pre></td></tr></table></figure><p>这个函数添加了一个<code>operator</code>关键字，这个是什么呢？这其实是运算符重载，能够自定义运算符实现的功能，我们之前使用这些数字进行运算，比如加减乘除，实际上都是这些基本类型在类中重载了运算符实现的，下一部分，我们就来介绍一下运算符重载函数。</p><h3 id="运算符重载函数"><a href="#运算符重载函数" class="headerlink" title="运算符重载函数"></a>运算符重载函数</h3><p>Kotlin支持为程序中已知的运算符集提供自定义实现，这些运算符具有固定的符号表示（如<code>+</code>或<code>*</code>）以及对应的优先级，要实现运算符重载，请为相应类型提供具有对应运算符指定名称的成员函数，而当前的类对象，则直接作为对应运算符左边的操作数，如果是一元运算符（比如++自增运算符，只需要本事）则直接作为操作数参与运算。</p><p>比如，现在我们想要为我们自定义的类型支持加法运算：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/kixuKBhcSawGHYX.png" alt="image-20230801001740893"></p><p>我们可以直接在类定义中添加一个固定名称（名称是预设好的，不能自己想写什么写什么）的函数，这里的加法运算就是<code>plus</code>函数，我们直接开始编写就可以了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-comment">//注意，二元运算符必须带一个形参，表示右侧的操作数，返回值为计算出来的结果</span><br>  <span class="hljs-comment">//形参和结果可以是任意类型，我们还可以提供多次编写同名的运算符重载函数来适配不同的类型</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(another: <span class="hljs-type">Student</span>)</span></span>: Student&#123;<br>        <span class="hljs-comment">//比如这里我们希望两个学生对象相加，得到的结果为名字相加，年龄相加的一个新学生</span><br>        <span class="hljs-keyword">return</span> Student(<span class="hljs-keyword">this</span>.name + another.name, <span class="hljs-keyword">this</span>.age + another.age)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们就成功重载了加法运算符，可以直接上手使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = Student(<span class="hljs-string">&quot;小米&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> b = Student(<span class="hljs-string">&quot;华为&quot;</span>, <span class="hljs-number">19</span>)<br>    <span class="hljs-keyword">val</span> c = a + b<br>    println(<span class="hljs-string">&quot;运算之后得到的新学生，名称：<span class="hljs-subst">$&#123;c.name&#125;</span>，年龄：<span class="hljs-subst">$&#123;c.age&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉很简单？只需要将我们需要的对应运算符直接重载，编写好对应的计算规则，就可以直接使用对应的运算符进行计算。</p><p>我们也可以试试看重载一些一元运算符，比如取反运算符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-comment">//比如取反操作就是把当前学生的名字反过来</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">not</span><span class="hljs-params">()</span></span> : Student &#123;<br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-keyword">this</span>.name.reversed()<br>        <span class="hljs-comment">//这里可以直接在当前对象上进行操作，然后返回当前对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来尝试使用一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//直接在这里使用!运算符</span><br>    <span class="hljs-keyword">val</span> a = !Student(<span class="hljs-string">&quot;小米&quot;</span>, <span class="hljs-number">18</span>)<br>    println(<span class="hljs-string">&quot;运算之后得到的新学生，名称：<span class="hljs-subst">$&#123;a.name&#125;</span>，年龄：<span class="hljs-subst">$&#123;a.age&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们列出常见的一些运算符对应的函数名称，首先是一元运算符：</p><table><thead><tr><th>符号</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>+a</code></td><td><code>a.unaryPlus()</code></td></tr><tr><td><code>-a</code></td><td><code>a.unaryMinus()</code></td></tr><tr><td><code>!a</code></td><td><code>a.not()</code></td></tr><tr><td><code>a--</code></td><td><code>a.dec()</code>+见下文</td></tr><tr><td><code>a++</code></td><td><code>a.inc()</code>+见下文</td></tr></tbody></table><p>其中<code>inc()</code>和<code>dec()</code>函数比较特殊，它们必须返回一个值，该值将分配给使用<code>++</code>或<code>--</code>操作的变量，而不是改变执行<code>inc</code>或<code>dec</code>操作的对象，意思就是执行后应该得到一个新生成的对象，然后变量的值直接引用到这个新的对象，因为Int类型就是这样的，比如<code>a++</code>的操作步骤如下：</p><ul><li>将<code>a</code>的初始值存储到临时存储<code>a0</code>。</li><li>将<code>a0.inc()</code>的结果分配给<code>a</code>。</li><li>返回<code>a0</code>作为表达式的结果。</li></ul><p>同样的，<code>++a</code>的操作步骤如下：</p><ul><li>将<code>a.inc()</code>的结果分配给<code>a</code>。</li><li>作为表达式的结果返回<code>a</code>的新值。</li></ul><p>认识完了一元运算符，我们接着来看一些基本二元运算符：</p><table><thead><tr><th>符号</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a + b</code></td><td><code>a.plus(b)</code></td></tr><tr><td><code>a - b</code></td><td><code>a.minus(b)</code></td></tr><tr><td><code>a * b</code></td><td><code>a.times(b)</code></td></tr><tr><td><code>a / b</code></td><td><code>a.div(b)</code></td></tr><tr><td><code>a % b</code></td><td><code>a.rem(b)</code></td></tr><tr><td><code>a..b</code></td><td><code>a.rangeTo(b)</code></td></tr><tr><td><code>a..&lt;b</code></td><td><code>a.rangeUntil(b)</code></td></tr></tbody></table><table><thead><tr><th>符号</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a in b</code></td><td><code>b.contains(a)</code></td></tr><tr><td><code>a !in b</code></td><td><code>!b.contains(a)</code></td></tr></tbody></table><p>对于<code>in</code>这种运算，必须返回Boolean类型的结果。</p><p>还有一些自增简化运算符：</p><table><thead><tr><th>符号</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a += b</code></td><td><code>a.plusAssign(b)</code></td></tr><tr><td><code>a -= b</code></td><td><code>a.minusAssign(b)</code></td></tr><tr><td><code>a *= b</code></td><td><code>a.timesAssign(b)</code></td></tr><tr><td><code>a /= b</code></td><td><code>a.divAssign(b)</code></td></tr><tr><td><code>a %= b</code></td><td><code>a.remAssign(b)</code></td></tr></tbody></table><p>这类运算符都是将运算结果赋值给左边的操作数，比如<code>a = a + b</code>等价于<code>a += b</code>，这种情况可能会与上面的基本操作产生歧义，比如下面的情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br><span class="hljs-comment">//同时定义plus和plusAssign</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(another: <span class="hljs-type">Student</span>)</span></span> : Student &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plusAssign</span><span class="hljs-params">(another: <span class="hljs-type">Student</span>)</span></span> : <span class="hljs-built_in">Unit</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，上面的函数中，<code>plus</code>运算符在重载之后，运算结果与当前类型是相同的，这种情况下，就会出现一个问题：</p><ul><li>plus： 算式 a &#x3D; a + b 可以成立，因为返回类型相同，可以重新赋值给a</li><li>plusAssign：为算式 a &#x3D; a + b 的缩写，与plus的功能完全一致</li></ul><p>此时，两个函数都匹配这里的运算符使用，编译器不知道该用哪一个了，因此就会出现歧义：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/y9caS62ediVC8Ar.png" alt="image-20230801004754437"></p><p>比较运算符只需要实现一个函数即可：</p><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a &gt; b</code></td><td><code>a.compareTo(b) &gt; 0</code></td></tr><tr><td><code>a &lt; b</code></td><td><code>a.compareTo(b) &lt; 0</code></td></tr><tr><td><code>a &gt;= b</code></td><td><code>a.compareTo(b) &gt;= 0</code></td></tr><tr><td><code>a &lt;= b</code></td><td><code>a.compareTo(b) &lt;= 0</code></td></tr></tbody></table><p>所有比较都会转换为<code>compareTo</code>函数调用，此函数返回<code>Int</code>值，这个值用于判断是否满足条件。</p><p>Kotlin非常强大，甚至连小括号都能重载：</p><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a()</code></td><td><code>a.invoke()</code></td></tr><tr><td><code>a(i)</code></td><td><code>a.invoke(i)</code></td></tr><tr><td><code>a(i, j)</code></td><td><code>a.invoke(i, j)</code></td></tr><tr><td><code>a(i_1, ..., i_n)</code></td><td><code>a.invoke(i_1, ..., i_n)</code></td></tr></tbody></table><p>直接使用变量名称+<code>()</code>来进行使用，感觉很像函数的调用，但是又不是，就很奇怪，不过确实很强大就是了。</p><p>还有一些运算符，以我们目前所学知识还无法进行讲解，后续在各位小伙伴学习之后，可以回顾一下：</p><table><thead><tr><th>运算符</th><th>对应的函数名称</th></tr></thead><tbody><tr><td><code>a[i]</code></td><td><code>a.get(i)</code></td></tr><tr><td><code>a[i, j]</code></td><td><code>a.get(i, j)</code></td></tr><tr><td><code>a[i_1, ..., i_n]</code></td><td><code>a.get(i_1, ..., i_n)</code></td></tr><tr><td><code>a[i] = b</code></td><td><code>a.set(i, b)</code></td></tr><tr><td><code>a[i, j] = b</code></td><td><code>a.set(i, j, b)</code></td></tr><tr><td><code>a[i_1, ..., i_n] = b</code></td><td><code>a.set(i_1, ..., i_n, b)</code></td></tr></tbody></table><p>这是索引访问运算符，使用方括号进行表示。</p><h3 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h3><p>实际上中缀函数在我们之前很多时候都有出现，比如位运算：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(i shl <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里的<code>shl</code>并不是一个运算符，而是一段自定义的英文单词，像这种运算符是怎么做到的呢？</p><p>这其实是中缀函数，用<code>infix</code>关键字标记的函数被称为中缀函数，在使用时，可以省略调用的点和括号进行调用，Infix函数必须满足以下要求：</p><ul><li>必须是成员函数。</li><li>只能有一个参数。</li><li>参数不能有默认值。</li></ul><p>我们可以像下面这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>  <span class="hljs-comment">//这个中缀函数实现了将给定字符串与当前对象的名字拼接并返回</span><br>    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">(string: <span class="hljs-type">String</span>)</span></span> : String&#123;<br>        <span class="hljs-keyword">return</span> name + string<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在使用时，也非常方便，真的就像在使用一个运算符一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(student test <span class="hljs-string">&quot;我爱你&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>得到的结果显而易见：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/L83otAYKWMEHmw1.png" alt="image-20230821023203951"></p><p>当然，我们也可以把它当做一个普通的函数进行调用，效果是完全等价的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(student.test(<span class="hljs-string">&quot;崴泥&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意一下：</p><blockquote><p>中缀函数调用的优先级低于算术运算符、类型转换和<code>rangeTo</code>运算符，例如以下表达式就是等效的：</p><ul><li><code>1 shl 2 + 3</code>相当于<code>1 shl (2 + 3)</code></li><li><code>0 until n * 2</code>相当于<code>0 until (n * 2)</code></li><li><code>xs union ys as Set&lt;*&gt;</code>相当于<code>xs union (ys as Set&lt;*&gt;)</code>（类型转换会在下一章多态进行介绍）</li></ul><p>另一方面，infix函数调用的优先级高于布尔运算符<code>&amp;&amp;</code>和<code>||</code>、<code>is</code>-和<code>in</code>-checks以及其他一些运算符的优先级。这些表达式也是等价的：</p><ul><li><code>a &amp;&amp; b xor c</code>相当于<code>a &amp;&amp; (b xor c)</code></li><li><code>a xor b in c</code>相当于<code>(a xor b) in c</code></li></ul></blockquote><p>同时，如果需在类中使用中缀函数，必须明确函数的调用方（接收器）比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStringCollection</span> &#123;<br>    <span class="hljs-keyword">infix</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(s: <span class="hljs-type">String</span>)</span></span> &#123; <span class="hljs-comment">/*...*/</span> &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">build</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">this</span> add <span class="hljs-string">&quot;abc&quot;</span>   <span class="hljs-comment">// 正确</span><br>        add(<span class="hljs-string">&quot;abc&quot;</span>)       <span class="hljs-comment">// 正确</span><br>        <span class="hljs-comment">//add &quot;abc&quot;        // 错误: 没有指定调用方或无法隐式表达</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于中缀函数的使用还是比较简单的。</p><h3 id="空值和空类型"><a href="#空值和空类型" class="headerlink" title="空值和空类型"></a>空值和空类型</h3><p>所有的变量除了引用一个具体的值之外，还有一种特殊的值可以使用，那就是<code>null</code>，它代表空值，也就是不引用任何对象。</p><p>在其他语言中，比如Java中<code>null</code>是一个非常常见的值，因为在某些情况下，引用类型的变量默认值就是null，这就经常会导致程序中出现一些空指针导致的异常，在Kotlin中，对空值处理是非常严格的，正常情况下，我们的变量是不能直接赋值为<code>null</code>的，否则会报错，无法编译通过：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/4iWgGokCl9BmAjZ.png" alt="image-20230801010807824"></p><p>这是因为所有的类型默认都是非空类型，非空类型的变量是不允许被赋值为null的，这直接在编译阶段就避免了其他语言中经常存在的<em>空指针</em>问题。</p><p>那么，如果我们希望某个变量在初始情况下使用<code>null</code>而不去引用某一个具体对象，该怎么做呢，此时我们需要将变量的类型修改为可空类型，只需在类型名称的后面添加一个<code>?</code>即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>既然现在是可空类型，那么很多问题就会出现了，比如当一个变量为<code>null</code>时，此时如果使用类中的一些成员方法或是获取成员属性时，会出现一些问题：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/3Jjom5xSuRXFVzK.png" alt="image-20230801011417154"></p><p>这里由于我们操作的是一个空类型，它有可能值为<code>null</code>，我们可以想象一下，如果一个变量不引用任何对象，此时我们又去让对象做一些事情（执行函数）这不是在搞笑吗，压根就没这个对象，难道让空气去执行操作吗？这显然是不对的，这样就会导致我们上面所说的空指针异常。</p><p>此时，为了安全，我们就需要对变量进行判断，看看其是否为<code>null</code>然后才能去做一些正常情况下该做的事情：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//这里直接通过if语句判断str变量是否为null，如果不是才执行</span><br>    <span class="hljs-keyword">if</span> (str != <span class="hljs-literal">null</span>) &#123;<br>        println(str.length)  <span class="hljs-comment">//现在就可以编译通过了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们只要能确保某个空类型变量的值不为空，那么就可以正常执行操作。当然，实际上在这个if内部，因为已经判断不为null了，所以str被智能类型转换为非空类型，这也是Kotlin语言非常人性化的地方。</p><p>不过在有些情况下，我们可能已经非常清楚，这里的str一定不为null，即使它是一个可空类型变量，我们可以像这样做，来告诉编译器，我们这里一定是安全的，只管执行就好：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//使用非空断言操作符!!.来明确不会出现null问题</span><br>    println(str!!.length)<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然使用非空断言操作符能够进行强制操作，但是这样实际上并不安全，它同样存在安全问题，也许我们有没考虑到的情况会导致这里为null呢，也说不定吧？对于一些我们拿不定具体会不会出现null的情况，有没有更好的解决办法呢？</p><p>Kotlin为我们提供了一种更安全的空类型操作，要安全地访问可能包含<code>null</code>值的对象的属性，请使用安全调用运算符<code>?.</code>，如果对象的属性为<code>null</code>则安全调用运算符返回<code>null</code>，像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> str: String? = <span class="hljs-literal">null</span><br>    println(str?.length)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的调用结果存在两种情况：</p><ul><li>如果str为null，那么这里得到的结果就是null，并且不会正常执行后面的操作</li><li>如果str不为null，那就正常返回这里本应该得到的结果</li></ul><p>因此，使用安全调用运算符后，如果遇到null的情况，那么这里不会正常进行原本的操作，而是直接返回<code>null</code>作为结果，这在有些时候非常好用，比如我们希望一个学生类型的变量在为<code>null</code>时就不执行对应的语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu: Student? = <span class="hljs-literal">null</span><br>    stu?.hello()<br>&#125;<br></code></pre></td></tr></table></figure><p>不过在有些时候，可能我们希望如果变量为null，在使用安全调用运算符时，返回一个我们自定义的结果，而不是null，这时该怎么做呢？我们可以使用Elvis运算符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> str: String? = <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//Elvis运算符 ?: 左侧为空值检测目标，右侧为检测到null时返回的结果</span><br>    <span class="hljs-keyword">val</span> len: <span class="hljs-built_in">Int</span> = str?.length ?: <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们使用了Elvis运算符来判断左侧是否为null，如果左侧为null，那么这里直接得到右侧的自定义值，这个运算符长得巨像其他语言里面的三元运算符，Kotlin拿来干这事了。</p><h3 id="解构声明"><a href="#解构声明" class="headerlink" title="解构声明"></a>解构声明</h3><p>有时候，我们在使用对象时可能需要访问它们内部的一些属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(student.name)  <span class="hljs-comment">//访问name属性</span><br>    println(student.age)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看起来不太优雅，有没有更好的方式呢，比如这里能不能直接得到Student对象内部的name和age熟悉作为变量使用？当然是可以的，我们可以直接像下面这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> (a, b) = student   <span class="hljs-comment">//从Student对象中将其属性解构出来，很优雅</span><br>    println(<span class="hljs-string">&quot;名字: <span class="hljs-variable">$a</span>, 年龄: <span class="hljs-variable">$b</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>要让一个类的属性支持解构，我们只需添加约定的函数即可，在Kotlin中，我们可以自定义解构出来的结果，而具体如何获取，需要定义一个componentN函数并通过返回值的形式返回解构的结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component1</span><span class="hljs-params">()</span></span> = name   <span class="hljs-comment">//使用component1表示解构出来的第一个参数</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">component2</span><span class="hljs-params">()</span></span> = age    <span class="hljs-comment">//使用component2表示解构出来的第二个参数</span><br>  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> component3...  //以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>添加用于解构的函数在之后，我们就可以使用解构操作了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> (a, b) = student   <span class="hljs-comment">//解构出来的参数按顺序就是componentN的结果了</span><br></code></pre></td></tr></table></figure><p>如果我们只想要使用第二个参数，而第一个参数不需要，可以直接使用<code>_</code>来忽略掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> (_, b) = student<br>println(<span class="hljs-string">&quot;年龄: <span class="hljs-variable">$b</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>解构同样可以用在Lambda表达式中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> func: (Student) -&gt; <span class="hljs-built_in">Unit</span> = &#123; (a, b) -&gt;  <span class="hljs-comment">//使用括号包括结构出来的两个参数</span><br>    println(<span class="hljs-string">&quot;名字: <span class="hljs-variable">$a</span>, 年龄: <span class="hljs-variable">$b</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">val</span> func2: (Student, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span> = &#123; (a, b), i -&gt;<br>    println(<span class="hljs-string">&quot;名字: <span class="hljs-variable">$a</span>, 年龄: <span class="hljs-variable">$b</span>&quot;</span>)<br>    println(i)<br>&#125;<br><br><span class="hljs-keyword">val</span> func3: (Student, <span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span> = &#123; (_, b), i -&gt;<br>    println(<span class="hljs-string">&quot;名字: <span class="hljs-variable">$a</span>, 年龄: <span class="hljs-variable">$b</span>&quot;</span>)<br>    println(i)<br>&#125;<br></code></pre></td></tr></table></figure><p>解构语法在遍历集合类和数组时同样适用，我们会在后面进行讲解。</p><h3 id="包和导入"><a href="#包和导入" class="headerlink" title="包和导入"></a>包和导入</h3><p>在之前，无论我们创建的是Kotlin源文件还是Kotlin类文件，都是在默认的包下进行的，也就是直接在kotlin&#x2F;src目录创建的。</p><p>但是有些时候，我们可能希望将一些模块按功能进行归类，而不是所有的kt文件都挤在一起，这个时候我们就需要用到包了。</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/iKuehJVcaDPBm82.png" alt="image-20230821025349332"></p><p>我们可以直接右键新建一个软件包，软件包的包名建议以域名格式进行命名，例如：</p><ul><li>com.baidu</li><li>cn.itbaima</li></ul><p>这类似于我们平时在浏览器中访问的网站地址，只不过是反过来的，这样就能很明确是哪一家公司或哪一个人制作的产品了。</p><p>这里我们随便创建一个：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/lOSupYdZo6ViKTF.png" alt="image-20230821025656614"></p><p>我们可以将kt文件直接创建在这个包中：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/eysHtBYJUOuxFcZ.png" alt="image-20230821025738398"></p><p>所有不在默认包下kt文件，必须在顶部声明所属的包，比如这里的Test.kt就放在<code>com.test</code>这个包中，因此顶部必须使用package关键字进行包声明，IDEA非常智能，在创建时就自动帮助我们生成好了。我们可以继续像之前一样，编写类或是函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.test<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;我是测试方法&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <br></code></pre></td></tr></table></figure><p>不过，由于现在kt文件存放在了一个明确的包中，如果我们要在这个包以外的其他地方使用，会出现一些问题：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/wWjSMbEIxBz7OR6.png" alt="image-20230821030210198"></p><p>当我们使用其他包中kt文件定义的类或函数时，会直接提示未解析的引用，这是因为默认情况下只有同包内的内容可以相互使用，而现在我们使用的是其他包中的内容，我们需要先进行导入操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.test.User   <span class="hljs-comment">//使用import关键字进行导入，导入时需要输入 包名.类型/顶级函数名称 来完成</span><br><span class="hljs-keyword">import</span> com.test.message<br><span class="hljs-keyword">import</span> com.test.a<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> user = User()<br>    message()<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们在导入之后就可以正常使用了，当然，如果一个包中定义的内容太多，我们需要大量使用，也可以使用<code>*</code>一次性导入全部内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.test.*   <span class="hljs-comment">//导入此包下的全部内容</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> user = User()<br>    message()<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上官方提供的库，也是来自于不同的包，但是Kotlin在默认情况下会自动导入一些包，不需要我们明确指定：</p><ul><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/index.html">kotlin.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/index.html">kotlin.annotation.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/index.html">kotlin.collections.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.comparisons/index.html">kotlin.comparisons.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/index.html">kotlin.io.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/index.html">kotlin.ranges.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/index.html">kotlin.sequences.*</a></li><li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/index.html">kotlin.text.*</a></li></ul><p>比如我们之前用到的一些基本类型，都是在<code>kotlin</code>这个包中定义的。</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/Zsi4CIT3XDz1QEY.png" alt="image-20230821030757225"></p><p>注意：在不同的平台下，还会有更多默认导入的包，比如Java平台下，就会默认导入<code>java.lang.*</code>和<code>kotlin.jvm.*</code>这两个包。</p><p>在有些情况下，可能会出现名称冲突的情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.test.message<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    message()   <span class="hljs-comment">//这里调用的，到底是导入的message函数，还是当前kt文件定义的函数呢？</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;Goodbye World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果显而易见，这里会优先使用导入的函数，而不是在当前文件中定义的同名函数。那么该如何去解决这种冲突的情况呢？我们可以使用<code>as</code>关键字来为导入的内容起个新的名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.test.message <span class="hljs-keyword">as</span> outer <span class="hljs-comment">//将导入的message函数名字改为outer</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    message()   <span class="hljs-comment">//此时这里调用的就是下面的message函数了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span>&#123;<br>    println(<span class="hljs-string">&quot;Goodbye World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以很好地消除存在歧义的情况了，最后总结一下，使用<code>import</code>关键字支持导入以下内容：</p><ul><li>顶级函数和属性</li><li>在单例对象中声明的函数和属性（下一章介绍）</li><li>枚举常量（下一章介绍）</li></ul><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>有些时候，我们可能不希望别人使用我们的所有内容，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.test<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">message</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;我是测试方法&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//我们不希望这个函数能够在其他地方被调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，有一个函数是我们不希望被外部调用的，但是经过前面的学习，我们只需要使用<code>import</code>关键字就能直接导入，那有没有办法能够控制一下其他地方对于当前文件一些可能私有函数或是其他内容的访问呢？我们可以使用可见性控制来处理。</p><p>在类、对象、接口、构造函数和函数，以及属性上，可以为其添加 <em>可见性修饰符</em> 来控制其可见性，在Kotlin中有四个可见性修饰符，它们分别是：<code>private</code>、<code>protected</code>、<code>internal</code>和<code>public</code>，默认可见性是<code>public</code>，在使用顶级声明时，不同可见性的访问权限如下：</p><ul><li>如果不使用可见性修饰符，则默认使用<code>public</code>，这意味着这里声明的内容将在任何地方可访问。</li><li>如果使用<code>private</code>修饰符，那么声明的内容只能在当前文件中可访问。</li><li>如果使用<code>internal</code>修饰符，它将在同一<a href="https://kotlinlang.org/docs/visibility-modifiers.html#modules">模块</a>中可见（当前的项目中可以随意访问，与public没大差别，但是如果别人引用我们的项目，那么无法使用）</li><li>顶级声明不支持使用<code>protected</code>修饰符。</li></ul><p>因此，在默认情况下，我们定义的内容都是可以访问的，而想要实现上面的效果，我们可以为其添加<code>private</code>修饰符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">inner</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//我们不希望这个函数能够在其他地方被调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当其他地方使用时，就会报错：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/poBbx9ytHW2nEi8.png" alt="image-20230821033355689"></p><p>在类中定义成员属性时，不同可见性的访问权限如下：</p><ul><li><code>private</code>意味着该成员仅在此类中可见（包括其所有成员）</li><li><code>protected</code>与<code>private</code>的可见性类似，外部无法使用，但在子类中可以使用（子类会在下一章中介绍）</li><li><code>internal</code>意味着本项目中任何地方都会看到其<code>internal</code>成员，但是别人引用我们项目时不行。</li><li><code>public</code>意味着任何地方都可以访问。</li></ul><p>比如下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-comment">//name属性无法被外部访问，因为是私有的</span><br>              <span class="hljs-keyword">internal</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;  <span class="hljs-comment">//age可以被外部访问，但是无法再其他项目中访问到</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment">//这个无参构造无法被外部访问，因为是私有的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有了访问控制，我们就可以更加明确地表示哪些内容是可以访问，而哪些是内部使用的。</p><h2 id="封装、继承和多态"><a href="#封装、继承和多态" class="headerlink" title="封装、继承和多态"></a>封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><ul><li>封装，把对象的属性和函数结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</li><li>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和函数，并根据实际需求扩展出新的行为。</li><li>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的函数。</li></ul></blockquote><p>正是这三大特性，能够让我们的Kotlin程序更加生动形象。</p><h3 id="类的封装"><a href="#类的封装" class="headerlink" title="类的封装"></a>类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个程序带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter函数来查看和设置变量。从这里开始，我们前面学习的权限访问控制就开始起作用了。</p><p>我们可以将之前的类进行改进：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>: String = name<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> = age<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，外部需要获取一个学生对象的属性时，只能使用特定的函数进行获取，而不像之前一样可以随意访问对象的属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> student = Student(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">//student.name   这样就不行了</span><br>    println(student.getName())<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的好处显而易见，其他地方只能拿到在内部某个成员属性引用的对象，而没办法像之前那样直接修改Student对象中某个成员属性。</p><p>同样的，如果要运行外部对对象中的属性进行修改，那么我们也可以提供对应的set函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    ...<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>&#123;   <span class="hljs-comment">//使用set函数来修改</span><br>        <span class="hljs-keyword">this</span>.name = name<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>等等，这不就是我们之前讲的属性的getter和setter函数吗，没错，哪怕我们不手动编写，成员属性也会存在默认的。但是，除了直接赋值之外我们也可以设置更多参数才能给学生改名字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>, upper: <span class="hljs-type">Boolean</span>)</span></span>&#123;<br>      <span class="hljs-comment">//判断是否upper来决定最终赋值的名字大写还是小写</span><br>        <span class="hljs-keyword">this</span>.name = <span class="hljs-keyword">if</span> (upper) name.uppercase() <span class="hljs-keyword">else</span> name.lowercase()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们自己封装好的名字设置方法暴露给外部使用，而不让外部直接操作名字。</p><p>我们甚至还可以将主构造函数改成私有的，需要通过其他的构造函数来构造：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> name: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">18</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个函数是什么作用，如何去用，而无需关心实现，要用什么由类自己提供好，而不需要外面来操作类内部的东西去完成（你让我做一件事情，我自己的事情自己做，不要你来帮我安排）封装就是通过访问权限控制来实现的。</p><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，根据前面的访问权限等级，子类可以使用父类中所有<strong>非私有</strong>的成员。</p><p>比如说我们一开始使用的学生，那么实际上学生根据专业划分，所掌握的技能也会不同，比如体育生会运动，美术生会画画，土木生会搬砖，计算机生会因为互联网寒冬找不到工作，因此，我们可以将学生这个大类根据不同的专业进一步地细分出来：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/21/Swh4GDy6z9WxTIn.png" alt="image-20230821192959617"></p><p>虽然我们划分出来这么多的类，但是其本质上还是学生，也就是说学生具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。就好比大学里的学生无论什么专业都会打游戏，都会睡觉，逃课，考试抄答案，四六级过不了，只不过他们专业不同，学的的方向不一样，也就掌握了其他专业不具备的技能。</p><p>在Kotlin中，我们可以使用继承操作来实现这样的结构，默认情况下，Kotlin类是“终态”的（不能被任何类继承）要使类可继承，请用<code>open</code>关键字标记需要被继承的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <span class="hljs-comment">//被继承的类我们称为父类</span><br>  <span class="hljs-keyword">val</span> xxx = <span class="hljs-string">&quot;学生证&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以像下面这样来创建一个继承学生的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;  <span class="hljs-comment">//以调用构造函数的形式进行声明</span><br>  <span class="hljs-comment">//这个类就是Student类的子类</span><br>  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)   <span class="hljs-comment">//子类中也可以继续编写自己独有的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，在Kotlin中不支持多继承，只不过套娃还是可以的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>: <span class="hljs-type">Student</span>()  <span class="hljs-comment">//继承了一级，相当于Student的儿子</span><br><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperArtStudent</span>: <span class="hljs-type">ArtStudent</span>()  <span class="hljs-comment">//继承了两级，相当于Student的孙子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperBigArtStudent</span>: <span class="hljs-type">SuperArtStudent</span>()  <span class="hljs-comment">//继承了三级，相当于Student的祖孙</span><br></code></pre></td></tr></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）比如下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> student = ArtStudent()<br>    student.hello()   <span class="hljs-comment">//虽然这里是ArtStudent对象，但是由于其继承的是Student，因此包含Student中的属性</span><br>  student.draw()   <span class="hljs-comment">//自己的属性也可以使用</span><br>  print(student.xxx)   <span class="hljs-comment">//不止函数，父类中的成员字段也是没有问题的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。这里需要特别注意一下，因为子类相当于是父类的扩展，但是依然保留父类的特性，所以说，在对象创建并初始化的时候，不仅会对子类进行初始化，也会优先对父类进行初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>() &#123;<br>    <span class="hljs-keyword">init</span> &#123; println(<span class="hljs-string">&quot;父类初始化&quot;</span>) &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>() : Student() &#123;<br>    <span class="hljs-keyword">init</span> &#123; println(<span class="hljs-string">&quot;子类初始化&quot;</span>) &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上这里就是在构造这个子类对象之前，调用了一次父类的构造函数，而我们用于继承指定的构造函数，就是会被调用的那一个。</p><p>因此，如果父类存在一个有参构造函数，子类同样必须在构造函数中调用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类必须适配其父类的构造函数，因为需要先对父类进行初始化</span><br><span class="hljs-comment">//其实就是去调用一次父类的构造函数，填入需要的参数即可，这里的参数可以是当前子类构造方法的形参，也可以是直接填写的一个参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>(name: String, age: <span class="hljs-built_in">Int</span>) : Student(name, <span class="hljs-number">18</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果父类存在多个构造函数，可以任选一个：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>() &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) : <span class="hljs-keyword">this</span>()<br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>) &#123;  <span class="hljs-comment">//任选一个父类构造函数即可</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当子类只存在辅助构造函数时，需要使用super关键字来匹配父类的构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String)<br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//子类不写主构造函数时，可以直接在冒号后面添加父类类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) : <span class="hljs-keyword">super</span>(str)   <span class="hljs-comment">//使用super来调用父类构造函数,super表示父类（超类）</span><br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(str, age)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以去匹配子类中其他构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) : <span class="hljs-keyword">this</span>(str, <span class="hljs-number">18</span>)   <span class="hljs-comment">//也可以调用子类其他构造函数，但是其他构造函数依然要间接或直接调用父类构造函数</span><br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(str, age)<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果子类既有主构造函数，也有辅助构造函数，那么其他辅助构造函数只能直接或间接调用主构造函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>() &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) : <span class="hljs-keyword">this</span>()<br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>()<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>() : Student() &#123;<br>    <span class="hljs-keyword">constructor</span>(str: String) : <span class="hljs-keyword">this</span>()  <span class="hljs-comment">//正确，必须直接或间接调用主构造函数</span><br>    <span class="hljs-keyword">constructor</span>(str: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(str, age)   <span class="hljs-comment">//报错，不能绕过主构造函数去匹配父类构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉玩法太多，都眼花缭乱了？实际上只要各位小伙伴心里面清楚下面的规则，就很好理解上面这一堆写法了：</p><ul><li>构造函数相当于是这个类初始化的最基本函数，在构造对象时一定要调用</li><li>主构造函数因为可能存在一些类的属性，所以说必须在初始化时调用，不能让这些属性初始化时没有初始值</li><li>子类因为是父类的延展，因此，子类在初始化时，必须先初始化父类，就好比每个学生都有学生证，这是属于父类的属性，如果子类在初始化时可以不去初始化父类，那岂不是美术生可以没有学生证？显然是不对的。</li></ul><p>优先级关系：父类初始化 &gt; 子类主构造 &gt; 子类辅助构造</p><h3 id="属性的覆盖"><a href="#属性的覆盖" class="headerlink" title="属性的覆盖"></a>属性的覆盖</h3><p>有些时候，我们可以希望子类继承父类的某些属性，但是我们可能希望去修改这些属性的默认实现。比如，美术生虽然也是学生，也会打招呼，但是可能他们打招呼的方式跟普通的学生不太一样，我们能否对打招呼这个函数的默认实现进行修改呢？</p><p>我们可以使用<code>override</code>关键字来表示对于一个属性的重写（覆盖）就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">//注意，跟类一样，函数必须添加open关键字才能被子类覆盖</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>  <span class="hljs-comment">//在子类中编写一个同名函数，并添加override关键字，我们就可以在子类中进行覆盖了，然后编写自己的实现</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;哦哈哟&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>覆盖之后，当我们使用子类进行打招呼时，函数会按照我们覆盖的内容执行，而不是原本的：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/jlMAVxCudRyi5gb.png" alt="image-20230823200019143"></p><p>同样的，类的某个变量也是可以进行覆盖的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> test: String = <span class="hljs-string">&quot;测试&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼: <span class="hljs-variable">$test</span>&quot;</span>)  <span class="hljs-comment">//这里拿到的test就会变成被覆盖掉的</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>  <span class="hljs-comment">//对父类的变量进行覆盖，类型必须一样</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> test: String = <span class="hljs-string">&quot;干嘛&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉很神奇？不过对于可变的变量，似乎下面这样来的更方便？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">var</span> test: String = <span class="hljs-string">&quot;测试&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼: <span class="hljs-variable">$test</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">init</span> &#123; test = <span class="hljs-string">&quot;干嘛&quot;</span> &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>有些时候为了方便，比如在父类中的属性，我们可以直接在子类的主构造函数中直接覆盖：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> name: String  = <span class="hljs-string">&quot;大明&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼，我叫: <span class="hljs-variable">$name</span>&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">//在主构造函数中覆盖，也是可以的，这样会将构造时传入的值进行覆盖</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>(<span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name: String) : Student() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = ArtStudent(<span class="hljs-string">&quot;小红&quot;</span>)<br>    student.hello()<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然现在已经很方便了，但是现在又来了一个新的需求，打招呼不仅要有子类的特色，同时也要保留父类原有的实现，这个时候该怎么办呢？我们可以使用<code>super</code>关键字来完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会打招呼&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我会画画&quot;</span>)<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-comment">//覆盖父类函数</span><br>        <span class="hljs-keyword">super</span>.hello()   <span class="hljs-comment">//使用super.xxx来调用父类的函数实现，这里super同样表示父类</span><br>        println(<span class="hljs-string">&quot;哦哈哟&quot;</span>)  <span class="hljs-comment">//再写自己的逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，我们在覆盖原本的函数时，也可以执行原本的实现，在一些对函数内容进行增强的常见，这种用法非常常见：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/zv8s3d6cU7rGWQD.png" alt="image-20230823201931679"></p><p>不过，由于存在我们之前讲解的的初始化顺序，下面的这种情况需要特别注意：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> name: String = <span class="hljs-string">&quot;小明&quot;</span><br>    <span class="hljs-keyword">init</span> &#123; println(<span class="hljs-string">&quot;我的名字是: <span class="hljs-subst">$&#123;name.length&#125;</span>&quot;</span>) &#125;  <span class="hljs-comment">//这里拿到的name实际上是还未初始化的子类name</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;大明&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student = ArtStudent()<br>&#125;<br></code></pre></td></tr></table></figure><p>由于父类初始化在子类之前，此时子类还未开始初始化，其覆盖的属性此时没有初始值，根据不同平台的实现，可能会出现一些问题，比如JVM平台下，没有初始化的对象引用默认为<code>null</code>，那么这里就会直接报空指针异常：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/nL7IlFWqGTvoPcd.png" alt="image-20230823203609819"></p><p>很神奇对吧，这里的<code>name</code>属性明明是一个非可空的String类型，居然还会出现<code>null</code>的情况报空指针，因此，对于这些使用了<code>open</code>关键字的属性（函数、变量等）只要是在初始化函数、构造函数中使用，IDEA都会给出警告：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/Us7gW92nhCQ5Dwr.png" alt="image-20230823204016350"></p><p>我们接着来讲一个很绕的东西，在使用一些子类的时候，我们实际上可以将其当做其父类来进行使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student = ArtStudent()   <span class="hljs-comment">//使用Student类型的变量接收一个ArtStudent类型的对象引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之所以支持这样去使用，是因为子类本身就是对父类的延伸，因此将其当做父类使用，也是没有问题的。就好比我们无论是美术生还是体育生，都可以当做学生来用，都可以送去厂里实习打螺丝，不然不给毕业证。</p><p>只不过，如果我们将一个对象作为其父类使用，那么在使用时也只能使用其父类的一些属性，就相当于我们在使用一个父类的对象：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/esvFlg2aoAD1mNY.png" alt="image-20230823210031003"></p><p>即使我们很清楚这里引用的对象是一个美术生，但是只能当做普通学生来用，这在后面的集合类中会经常用到，因为集合类往往存在多种不同的实现，但是我们只需要关心怎么用就行了，并且为了方便更换实现，所以一般使用集合类对应的接口来作为变量的类型。</p><p>那么，如果子类重写了父类的某个函数，此时我们以父类的形式去使用，结果会怎么样？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;大家好&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;我姓🐴我叫🐴牛逼&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/uUd5f7amLbO2yhg.png" alt="image-20230823210424758"></p><p>可以看到，虽然当做父类来使用，但是其本质是不会变的，所以说，这里执行的结果依然是子类的覆盖实现。</p><p>那么，如果项目中很多这种明明是子类但是拿来当做父类用，我们怎么去判断使用的对象到底是什么类型的呢？我们可以使用<code>is</code>关键字来进行类型判断，以下面的三个类为例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span> : <span class="hljs-type">Student</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SportStudent</span> : <span class="hljs-type">Student</span>() <br></code></pre></td></tr></table></figure><p>现在我们进行类型判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student = ArtStudent()<br>    println(student <span class="hljs-keyword">is</span> ArtStudent)   <span class="hljs-comment">//true，因为确实是这个类型</span><br>    println(student <span class="hljs-keyword">is</span> SportStudent)   <span class="hljs-comment">//false，因为不是这个类型</span><br>    println(student <span class="hljs-keyword">is</span> Student)   <span class="hljs-comment">//true，因为是这个类型的子类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，使用is关键字可以精准地对类型进行判断，只要判断的对象是这个类或是这个类的子类，那么就会返回true作为结果。</p><p>如果我们明确某个变量引用的对象是什么类型，可以使用<code>as</code>关键字来进行强制类型转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student = ArtStudent()<br>    <span class="hljs-keyword">if</span>(student <span class="hljs-keyword">is</span> ArtStudent) &#123;<br>        <span class="hljs-keyword">val</span> artStudent = student <span class="hljs-keyword">as</span> ArtStudent;<br>        artStudent.draw()  <span class="hljs-comment">//强制类型转换之后，可以直接变回原本的类型去使用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，编译器非常智能，它可以根据当前的语境判断的类型自动进行类型转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student: Student = ArtStudent()<br><span class="hljs-keyword">if</span>(student <span class="hljs-keyword">is</span> ArtStudent) &#123;<br>    student.draw()<br>&#125;<br></code></pre></td></tr></table></figure><p>此时IDEA中会出现提示：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/23/VEp5huGfZxcnj61.png" alt="image-20230823224118184"></p><p>不仅仅是if判断的场景、包括when、while，以及<code>&amp;&amp;</code> <code>||</code> 等运算符都支持智能转换，只要上下文语境符合就能做到：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student? = ArtStudent()<br>  <span class="hljs-comment">//很明显这里是当student为ArtStudent时，根据语境直接智能转换</span><br>    <span class="hljs-keyword">while</span> (student <span class="hljs-keyword">is</span> ArtStudent)  student.draw()<br>    <span class="hljs-comment">//很明显如果这前面已经判断为真了，那肯定是这个类型，后面也可以智能转换</span><br>  <span class="hljs-keyword">if</span>(student <span class="hljs-keyword">is</span> ArtStudent &amp;&amp; student.draw())<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅仅是这种场景，比如我们前面讲解的可空类型，同样支持这样的智能转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student? = ArtStudent()<br>  student?.hello()<br>    <span class="hljs-keyword">if</span> (student != <span class="hljs-literal">null</span>)   <span class="hljs-comment">//判断到如果不为null</span><br>  student.hello()   <span class="hljs-comment">//根据语境student智能转换为了非空Student类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在处理一些可空类型时，为了防止出现异常，我们可以使用更加安全的<code>as?</code>运算符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student: Student? = ArtStudent()<br>    <span class="hljs-keyword">val</span> artStudent: ArtStudent? = student <span class="hljs-keyword">as</span>? ArtStudent  <span class="hljs-comment">//当student为null时，不会得到异常，而是返回null作为结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>有了这些操作，类和对象在我们使用的过程中就逐渐开始千变万化了，后面我们还会继续认识更多的多态特性。</p><h3 id="顶层Any类"><a href="#顶层Any类" class="headerlink" title="顶层Any类"></a>顶层Any类</h3><p>在我们不继承任何类的情况下，实际上Kotlin会有一个默认的父类，所有的类默认情况下都是继承自Any类的。</p><p>这个类的定义如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kotlin类继承结构中的根类. 所有Kotlin中的类都会直接或间接将Any作为父类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Any</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断某个对象是否&quot;等于&quot;当前对象，这里同样是对运算符&quot;==&quot;的重载，而具体判断两个对象相等的操作需要由子类来定义</span><br><span class="hljs-comment">     * 在一些特定情况下，子类在重写此函数时应该保证以下要求:</span><br><span class="hljs-comment">     * * 可反身: 对于任意非空值 `x`, 表达式 `x.equals(x)` 应该返回true</span><br><span class="hljs-comment">     * * 可交换: 对于任意非空值 `x` 和 `y`, `x.equals(y)` 当且仅当 `y.equals(x)` 返回true时返回true</span><br><span class="hljs-comment">     * * 可传递: 对于任意非空值 `x`, `y`, 和 `z`, 如果 `x.equals(y)` 和 `y.equals(z)` 都返回true, 那么 `x.equals(z)` 也应该返回真</span><br><span class="hljs-comment">     * * 一致性: 对于任意非空值 `x` 和 `y`, 在多次调用 `x.equals(y)` 函数时，只要不修改在对象的“equals”比较中使用的信息，那么应当始终返回同样的结果</span><br><span class="hljs-comment">     * * 永不等于空: 对于任意非空值 `x`, `x.equals(null)` 应该始终返回false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">equals</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>?)</span></span>: <span class="hljs-built_in">Boolean</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回当前对象的哈希值，它具有以下约束:</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * * 对同一对象多次调用该函数时，只要不修改对象上的equals比较中使用的信息，那么此函数就必须始终返回相同的整数 </span><br><span class="hljs-comment">     * * 如果两个对象通过`equals`函数判断为true，那么这两个对象的哈希值也应该相同</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将此对象转换为一个字符串，具体转换为什么样子的字符串由子类自己决定</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String<br>&#125;<br></code></pre></td></tr></table></figure><p>由于默认情况下类都是继承自Any，因此Any中定义的函数也是被继承到子类中了。</p><p>首先我们来看这个<code>equals</code>函数，它实际上是对<code>==</code>这个运算符的重载，我们之前在使用一些基本类型的时候，就经常使用<code>==</code>来判断这些类型是否相同，比如Int类型的数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">20</span><br>    println(a == b)<br>    println(a.equals(b))  <span class="hljs-comment">//跟上面的写法完全一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>经过前面的学习，我们知道这些基本类型本质上也是定义的类，实际上它们也是通过重写这个函数来实现这些比较操作的（一些基本类型会根据不同的平台进行编译优化，没法看源码）</p><p>我们可以看到，这个函数接受的参数类型是一个<code>Any?</code>类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">open</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">equals</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>?)</span></span>: <span class="hljs-built_in">Boolean</span>  <span class="hljs-comment">//我们上节课说到一个子类也可以被当做父类类型的变量去使用，所以说equals判断接受的参数为了满足不同的类型变量之间进行比较，直接使用顶层Any作为参数（考虑到会用到可空类型，所以说直接用了Any?作为参数类型）</span><br></code></pre></td></tr></table></figure><p>到目前为止，我们认识了Kotlin中两种相等的判断方式：</p><ul><li><em>结果上</em> 相等 (<code>==</code> 等价于 <code>equals()</code>)</li><li><em>引用上</em> 相等 (<code>===</code> 判断两个变量是否都是引用的同一个对象)</li></ul><p>我们在使用<code>equals</code>比较两个可空对象是否相等时，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">a == b<br></code></pre></td></tr></table></figure><p>实际上会被翻译为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">a?.equals(b) ?: (b === <span class="hljs-literal">null</span>)  <span class="hljs-comment">//a如果为null那就直接判断b是不是也为null，否则直接调用a的equals函数并让b作为参数</span><br></code></pre></td></tr></table></figure><p>当然可能会有小伙伴疑问，那不等于判断呢？实际上是一样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-string">&quot;10&quot;</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-string">&quot;20&quot;</span><br>    println(a != b)<br>    println(!a.equals(b))  <span class="hljs-comment">//等价于上面的写法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以为我们自己编写的类型重写<code>equals</code>函数，比如我们希望Student类型当名字和年龄相等时，就可以使用<code>==</code>来判断为true，我们可以像这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">equals</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> === other) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">//如果引用的是同一个对象，肯定是true不多逼逼</span><br>        <span class="hljs-keyword">if</span>(other !<span class="hljs-keyword">is</span> Student) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">//如果要判断的对象根本不是Student类型的，那也不用继续了</span><br>        <span class="hljs-keyword">if</span>(name != other.name) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">//判断名字是否相同</span><br>        <span class="hljs-keyword">if</span>(age != other.age) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">//判断年龄是否相同</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>   <span class="hljs-comment">//都没问题，那就是相等了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时我们已经将其比较操作重写，我们可以来试试看：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    <span class="hljs-keyword">val</span> b = Student(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">17</span>)<br>    <span class="hljs-keyword">val</span> c = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(a == a)    <span class="hljs-comment">//返回true因为就是自己</span><br>    println(a == b)    <span class="hljs-comment">//返回false因为名字和年龄不一样</span><br>    println(a == c)    <span class="hljs-comment">//返回true因为名字和年龄完全一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下，如果我们不重写类的<code>equals</code>函数，那么会直接对等号两边的变量进行引用判断<code>===</code>判断是否为同一个对象。只不过，可以很清楚地看到IDEA提示我们：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/09/03/I8UKfnoGTDJ5bmt.png" alt="image-20230903022730000"></p><p>实际上在我们重写类的<code>equals</code>函数时，根据约定，必须重写对于的hashCode函数，至于为什么，我们会在后续的集合类部分中进行介绍，这里我们暂时先不对hashCode函数进行讲解。</p><p>接着我们来看下一个，<code>toString</code>函数用于快速将对象转换为字符串，只不过默认情况下，会像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = Student(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-number">18</span>)<br>    println(a.toString())<br>    println(a)  <span class="hljs-comment">//println默认情况下会直接调用对象的toString并打印，所以跟上面是一样的</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/09/03/1C97zSp6YtWm5h2.png" alt="image-20230903024131154"></p><p>可以看到打印的结果是对象的<code>类型@十六进制哈希值</code>的形式，在某些情况下，可能我们更希望的是转换对象的一些成员属性，这样我们可以更直观的看到对象的属性具有什么值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String &#123;  <span class="hljs-comment">//直接重写toString函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student(name=&#x27;<span class="hljs-variable">$name</span>&#x27;, age=<span class="hljs-variable">$age</span>)&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在得到的结果，就是我们自定义的结果了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/09/03/MoePNY7UEz6xRmf.png" alt="image-20230903024524946"></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>有些情况下，我们设计的类可能仅仅是作为给其他类继承使用的类，而其本身并不需要创建任何实例对象，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">protected</span> <span class="hljs-keyword">constructor</span>() &#123;  <span class="hljs-comment">//无法构造这个父类，要求使用子类</span><br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>: <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;原神&quot;</span>)  <span class="hljs-comment">//两个子类都对hello进行了实现，采用各自的方式</span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SportStudent</span>: <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;启动&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在上面这个例子中，Student类的<code>hello</code>函数在子类中都会被重写，所以说除非在子类中调用父类的默认实现，否则一般情况下，父类中定义的函数永远都不会被调用。</p><p>就像我们说一个学生会怎么考试一样，实际上学生怎么考试是一个抽象的概念，但是由于学生的种类繁多，美术生怎么考试和体育生怎么考试，才是具体的一个实现。所以说，我们可以将学生类进行进一步的抽象，让某些函数或字段完全由子类来实现，父类中不需要提供实现。我们可以使用<code>abstract</code>关键字来将一个类声明为抽象类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//使用abstract表示这个是一个抽象类</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> type: String  <span class="hljs-comment">//抽象类中可以存在抽象成员属性</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>   <span class="hljs-comment">//抽象类中可以存在抽象函数</span><br>  <span class="hljs-comment">//注意抽象的属性不能为private，不然子类就没法重写了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当一个子类继承自抽象类时，必须要重写抽象类中定义的抽象属性和抽象函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArtStudent</span>: <span class="hljs-type">Student</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> type: String = <span class="hljs-string">&quot;美术生&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;原神，启动！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是强制要求的，如果不进行重写将无法通过编译。同时，抽象类是不允许直接构造对象的，只能使用其子类：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/09/03/viBCqHg64TZyAsN.png" alt="image-20230903031350955"></p><p>当然，抽象类不仅可以具有抽象的属性，同时也具有普通类的性质，同样可以定义非抽象的属性或函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">val</span> type: String<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;不会有人玩到大三了才开始学Java吧&quot;</span>)  <span class="hljs-comment">//定义非抽像属性或函数，在子类中不强制要求重写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时，抽象类也可以继承自其他的类（可以是抽象类也可以是普通类）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>   //直接继承一个普通的类<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">Test</span>()&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然抽象类可以继承一个普通的类，但是这依然不改变它是抽象类的本质，子类依然要按照上面的要求进行编写。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>由于Kotlin中不存在多继承的操作，我们可以使用接口来替代。</p><p>前面我们认识了抽象类，它可以具有一些定义而不实现的内容，而接口比抽象类还要抽象，一般情况下，他只代表某个确切的功能！也就是只能包含函数或属性的定义，所有的内容只能是<code>abstract</code>的，它不像类那样完整。接口一般只代表某些功能的抽象，接口包含了一系列内容的定义，类可以实现这个接口，表示类支持接口代表的功能。</p><p>比如，学生具有以下功能：</p><ul><li>打游戏</li><li>睡懒觉</li><li>逃课</li><li>考试作弊</li></ul><p>我们可以将这一系列功能拆分成一个个的接口，然后让学生实现这些接口，来表示学生支持这些功能。</p><p>在Kotlin中，要声明接口，我们可以使用<code>interface</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> x: String  <span class="hljs-comment">//接口中所有属性默认都是abstract的（可省略关键字）</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>   <span class="hljs-comment">//接口中所有函数默认都是abstract的（可省略关键字）</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">game</span><span class="hljs-params">()</span></span><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">A</span>, <span class="hljs-type">B</span> &#123;   <span class="hljs-comment">//接口的实现与类的继承一样，直接写到后面，多个接口用逗号隔开</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> x: String = <span class="hljs-string">&quot;测试&quot;</span>   <span class="hljs-comment">//跟抽象类一样，接口中的内容是必须要实现的</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">game</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;读大学就该玩游戏玩到爽&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，接口相比于抽象类来说，更加的纯粹，它不像类那样可以具有什么确切的属性，一切内容都是抽象的，只能由子类来实现。</p><p>只不过，在接口中声明的属性可以是抽象的，也可以为Getter提供默认实现。在接口中声明的属性无法使用<code>field</code>后背字段，因此在接口中声明的Setter无法使用<code>field</code>进行赋值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">val</span> x: String<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;666&quot;</span>  <span class="hljs-comment">//只能重写getter，不能直接赋值，因为默认情况下getter是返回的field的值，但是接口里不让用</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">var</span> x: String<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;666&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;  <span class="hljs-comment">/* 默认的setter会直接报错，因为使用了field字段 */</span> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了应对变化多端的需求，接口也可以为函数编写默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//接口中的函数可以具有默认实现，默认情况下是open的，除非private掉</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一看，这函数可以写默认的实现那接口似乎变得不那么抽象了？这用着感觉好像跟抽象类没啥区别啊？接口跟类的最大区别其实就是状态的保存，这从上面的成员属性我们就可以看的很清楚。</p><p>接口也可以继承自其他接口，直接获得其他接口中的定义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">game</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;读大学就该玩游戏玩到爽&quot;</span>)<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span>: <span class="hljs-type">A</span>, <span class="hljs-type">B</span>   //接口的继承写法是一样的，并且接口继承接口是支持多继承的<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">C</span>    //直接获得<span class="hljs-title">ABC</span>三个接口的功能<br></code></pre></td></tr></table></figure><p>是不是感觉接口的玩法非常有意思？只不过玩的过程中，可能也会遇到一些麻烦，比如下面的这种情况：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;管他什么早八不早八的，睡舒服再说&quot;</span>)<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;7点起床学Java了，不能再睡了&quot;</span>)<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">A</span>, <span class="hljs-type">B</span>  //由于<span class="hljs-title">A</span>和<span class="hljs-title">B</span>都具有<span class="hljs-title">sleep</span>函数，那现在到底继承谁的呢？<br></code></pre></td></tr></table></figure><p>这种情况下，我们需要手动解决冲突，比如我们希望Student类采用接口B的默认实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-type">A</span>, <span class="hljs-type">B</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span> &#123;  <span class="hljs-comment">//手动重写sleep函数，自行决定如何处理冲突</span><br>        <span class="hljs-keyword">super</span>&lt;B&gt;.sleep()  <span class="hljs-comment">//使用super关键字然后添加尖括号指定对应接口，并手动调用接口对应函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于接口，我们可以像之前一样，将变量的类型设定为一个接口的类型，当做某一个接口的实现来使用，同时也支持<code>is</code>、<code>as</code>等关键字进行类型判断和转换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a: A = Student()<br>    a.sleep()  <span class="hljs-comment">//直接当做A接口用（只能使用A接口中定义的内容）</span><br>    println(a <span class="hljs-keyword">is</span> B)  <span class="hljs-comment">//判断a引用的对象是否为B接口的实现类</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉跟之前使用起来是差不多的？其实只要前面玩熟悉了，后面还是很简单的。</p><h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><p>Kotlin提供了扩展类或接口的操作，而无需通过类继承或使用<em>装饰器</em>等设计模式，来为某个类添加一些额外的函数或是属性，我们只需要通过一个被称为<em>扩展</em>的特殊声明来完成。</p><p>例如，您可以从无法修改的第三方库中为类或接口编写新函数，这些函数可以像类中其他函数那样进行调用，就像它们是类中的函数一样，这种机制被称为<em>扩展函数</em>。还有<em>扩展属性</em>，允许您为现有类定义新属性。</p><p>比如我们想为String类型添加一个自定义的操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//为官方的String类添加一个新的test函数，使其返回自定义内容</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;666&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;Hello World&quot;</span><br>    println(text.test())  <span class="hljs-comment">//就好像String类中真的有这个函数一样</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/A84ftRYmKgklz9F.png" alt="image-20231224000802923"></p><p>是不是感觉很神奇？通过这种机制，我们可以将那些第三方类不具备的功能强行进行扩展，来方便我们的操作。</p><p>注意，类的扩展是静态的，实际上并不会修改它们原本的类，也不会将新成员插入到类中，仅仅是将我们定义的功能变得可调用，使用起来就像真的有一样。同时，在编译时也会明确具体调用的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-type">Shape</span>()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Shape.<span class="hljs-title">getName</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Shape&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Rectangle.<span class="hljs-title">getName</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Rectangle&quot;</span>  <span class="hljs-comment">//虽然这里同时扩展了父类和子类的getName函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printClassName</span><span class="hljs-params">(s: <span class="hljs-type">Shape</span>)</span></span> &#123;  <span class="hljs-comment">//但由于这里指定的类型是Shape，因此编译时也只会使用Shape扩展的getName函数</span><br>    println(s.getName())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printClassName(Rectangle())<br>&#125;<br></code></pre></td></tr></table></figure><p>由于类的扩展是静态的，因此在编译出现歧义时，只会取决于形参类型。</p><p>如果是类本身就具有同名同参数的函数，那么扩展的函数将失效：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;你干嘛&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Test.<span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;哎哟&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Test().hello()   <span class="hljs-comment">//你干嘛</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过，我们如果通过这种方式实现函数的重载，是完全没有问题的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;你干嘛&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Test.<span class="hljs-title">hello</span><span class="hljs-params">(str: <span class="hljs-type">String</span>)</span></span> = println(str)  <span class="hljs-comment">//重载一个不同参数的同名函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Test().hello(<span class="hljs-string">&quot;不错&quot;</span>)  <span class="hljs-comment">//有效果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，类的属性也是可以通过这种形式来扩展的，但是有一些小小的要求：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/xcOf9EGpIgWCiuw.png" alt="image-20231224133250495"></p><p>可以看到直接扩展属性是不允许的，前面我们说过，扩展并不是真的往类中添加属性，因此，扩展属性本质上也不会真的插入一个成员字段到类的定义中，这就导致并没有变量去存储我们的数据，我们只能明确定义一个getter和setter来创建扩展属性，才能让它使用起来真的像是类的属性一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> Student.gender: String<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;666&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student()<br>    println(stu.gender)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>由于扩展属性并没有真正的变量去存储，而是使用get和set函数来实现，所以，像前面认识的field这种后备字段，就无法使用了。</p></blockquote><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/tcWgufYbXw6rMFa.png" alt="image-20231224140003005"></p><p>还有一个需要注意的时，我们在不同包中定义的扩展属性，同样会受到访问权限控制，需要进行导入才可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> com.test.gender<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> stu = Student()<br>    println(stu.gender)<br>&#125;<br></code></pre></td></tr></table></figure><p>除了直接在顶层定义类的扩展之外，我们也可以在一个类中定义其他类的扩展，并且在定义时可以直接使用其他类提供的属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> A.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        hello()   <span class="hljs-comment">//直接在类A的扩展函数中调用A中定义的函数</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这种扩展，由于是在类中定义，因此也仅限于类内部使用，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> (<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> a: A)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> A.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> = hello() + <span class="hljs-string">&quot;!!!&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">world</span><span class="hljs-params">()</span></span> = println(a.test())   <span class="hljs-comment">//只能在类中通过A的实例使用扩展函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> = B(A()).world()<br></code></pre></td></tr></table></figure><p>扩展属性无法访问那些本就不应该被当前作用域访问的类属性，即使它是对某个类的扩展，比如下面这种情况：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/24/WqImXYiLKoTvPMh.png" alt="image-20231224142935236"></p><p>在名称发生冲突时，需要特别处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Hello World&quot;</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> (<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> a: A)&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> A.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>        hello()   <span class="hljs-comment">//直接使用优先匹配被扩展类中的方法</span><br>        <span class="hljs-keyword">this</span>.hello()   <span class="hljs-comment">//扩展函数中的this依然指的是被扩展的类对象</span><br>        <span class="hljs-keyword">this</span><span class="hljs-symbol">@B</span>.hello()   <span class="hljs-comment">//这里调用的才是下面的</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;Bye World&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义在类中的扩展也可以跟随类的继承结构，进行重写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Student.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;AAA&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> = println(Student().test())<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-type">A</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Student.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;BBB&quot;</span>  <span class="hljs-comment">//对父类定义的扩展函数进行重写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    A().hello()<br>    B().hello()<br>&#125;<br></code></pre></td></tr></table></figure><p>局部扩展也是可以的，我们可以在某个函数里面编写扩展，但作用域仅限于当前函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">test</span><span class="hljs-params">()</span></span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-string">&quot;&quot;</span>.test()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们将一个扩展函数作为参数给到一个函数类型变量，那么同样需要再具体操作之前增加类型名称才可以：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-comment">//因为是对String类型的扩展函数，需要String.前缀</span><br>    <span class="hljs-keyword">val</span> func: String.() -&gt; <span class="hljs-built_in">Int</span> = &#123;<br>        <span class="hljs-keyword">this</span>.length   <span class="hljs-comment">//跟上面一样，扩展函数中的this依然指的是被扩展的类对象</span><br>    &#125;<br>    println(<span class="hljs-string">&quot;sahda&quot;</span>.func())  <span class="hljs-comment">//可以直接对符合类型的对象使用这个函数</span><br>  func(<span class="hljs-string">&quot;Hello&quot;</span>)  <span class="hljs-comment">//如果是直接调用，那么必须要传入对应类型的对象作为首个参数，此时this就指向我们传入的参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，此函数的类型是<code>String.() -&gt; Int </code>，也就是说它是专门针对于String类型编写的扩展函数，没有参数，返回值类型为Int，并使用Lambda表达式进行赋值，同时这个函数也是属于String类型的，只能由对象调用，或是主动传入一个相同类型的对象作为参数才能直接调用。可能这里会有些绕不太好理解，需要同学们多去思考。</p><p>总结一下，扩展属性更像是针对于原本类编写的外部工具函数，而绝不是对原有类的修改。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/t7lnl87f74f3v1ju?segment=1">https://www.itbaima.cn/zh-CN/document/t7lnl87f74f3v1ju?segment=1</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin程序设计基础 - Kotlin（一）基础语法</title>
    <link href="/2025/08/11/Kotlin%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%20-%20Kotlin%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2025/08/11/Kotlin%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%20-%20Kotlin%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/nCEfGvtyTO3MBzH.png" alt="image-20230725125851157"></p><h1 id="Kotlin程序设计初级篇"><a href="#Kotlin程序设计初级篇" class="headerlink" title="Kotlin程序设计初级篇"></a>Kotlin程序设计初级篇</h1><p><strong>注意：</strong> 在开始学习之前，推荐各位小伙伴有一定的编程语言基础，前置课程：《JavaSE 教程》或《C 语言程序设计》如果没有其他语言的基础，在学习Kotlin时会非常吃力，这门语言语法糖多到爆炸。</p><p>Kotlin是一种现代但已经成熟的编程语言，旨在让开发人员更快乐。它简洁、安全、可与Java和其他语言互操作，并提供了许多在多个平台之间重用代码的方法。它由JetBrains公司于2011年设计和开发，并在2016年正式发布。Kotlin旨在解决Java语言在编码效率和代码质量方面存在的问题，并且与Java语言完全兼容。Kotlin通过简化语法、提供更强大的功能以及减少样板代码的编写，使得开发者能够更高效地编写清晰、简洁而又安全的代码。</p><blockquote><p>Kotlin语言名字的来源是基于一个古老斯拉夫部落的名字。JetBrains开发Kotlin的初衷是为了在Android开发上取代Java，并且作为一门通用的编程语言。Kotlin通过减少样板代码和增加现代化的语言特性，提供了更好的工具和库来简化Android应用开发。由于Kotlin的设计理念和特性吸引了广泛的开发者关注，它也迅速被接受并得到了广泛的使用。现在，Kotlin已成为一门流行的编程语言，被许多开发者用于Android应用开发、服务器端开发以及其他领域的软件开发中。</p></blockquote><p>官方网站：<a href="https://www.jetbrains.com/opensource/kotlin/">https://www.jetbrains.com/opensource/kotlin/</a></p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/15/58x79t2JvlVZTmo.png" alt="image-20231215224847189"></p><p>Kotlin 是一种现代化的静态类型编程语言，具有以下优势：</p><ol><li>与Java互操作性强：Kotlin 可以与现有的 Java 代码无缝地互操作，允许开发者在现有的项目中逐步采用 Kotlin，而不需要重写整个项目。这使得 Kotlin 成为 Android 应用开发的理想选择。</li><li>简洁易读：Kotlin 的语法简洁并具有更好的可读性，减少了样板代码的编写。相比 Java，Kotlin 可以使用更少的代码来实现同样的功能，从而提高开发效率。</li><li>空安全性：Kotlin 对空值进行了更好的处理。在 Kotlin 中，变量默认是非空的，如果需要使用可能为空的值，需要显式声明类型为可空。这有助于减少空指针异常的发生。</li><li>函数式编程支持：Kotlin 支持函数式编程的特性，如高阶函数、lambda 表达式和函数式编程的集合操作等。这些特性可以让开发者编写更简洁、可维护的代码，并提高代码的表达能力。</li><li>扩展函数：Kotlin 允许开发者为某个类添加新的方法，而不需要修改该类的源代码。这种扩展函数的特性可以为开发者提供更灵活的方式来扩展现有的类库。</li><li>协程支持：Kotlin 引入了协程（coroutine）机制，使得异步操作更易于管理和编写。通过使用协程，开发者可以使用顺序的方式编写并发代码，并避免了回调地狱的问题。</li></ol><p>总的来说，Kotlin 是一门功能丰富、可读性高、与 Java 无缝互操作的编程语言，适用于 Android、Web 后端开发等多种场景。</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/TpBgQie7CcD2Vol.png" alt="image-20230725132203050"></p><p>正是因为Kotlin与Java的高度兼容性，再加上简洁、安全、互操作性强等特点，让Kotlin一度成为Android开发的官方指定语言。并且随着时代的发展，现在它不仅仅可以开发安卓应用程序，也可以开发iOS程序，甚至开发Java后端、开发桌面应用程序等。其简洁高效的语法也受到一众开发者追捧。</p><p>从下节课开始，我们就来正式学习一下Kotlin语言，Kotlin，启动！</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/QyjCMSHBn4cdAN3.png" alt="image-20230725135856171"></p><hr><h2 id="走进新语言"><a href="#走进新语言" class="headerlink" title="走进新语言"></a>走进新语言</h2><p>欢迎大家进入到Kotlin程序设计的学习中，我们将从开发环境配置开始，为各位小伙伴讲解。</p><p>编程语言可以被视为人与计算机之间进行交流的方式。它是一种用于编写计算机程序的形式化语言，用于描述计算机任务的操作步骤、算法和数据结构。简单来说，就是以计算机能听懂的语言告诉计算机我们要做什么，然后让计算机来做我们想做的事情，从而解决我们生活中各种各样的问题。</p><p>编程语言可以分为多种类型，包括低级语言和高级语言。低级语言（如汇编语言）与计算机硬件更接近，对计算机底层操作进行更精细的控制，但编写和理解起来较为复杂。高级语言（如Java、Python等）则更加易读、易写，并提供了更高层次的抽象，使得程序员能够更专注于问题的解决和算法的设计。而我们这里要学习的Kotlin语言，也属于高级语言的一种，能够使用我们人类更容易理解的语法来编写程序。</p><h3 id="开发环境配置"><a href="#开发环境配置" class="headerlink" title="开发环境配置"></a>开发环境配置</h3><p>要开发Kotlin程序，我们首先需要安装Java环境，我们一般使用Kotlin都是在JVM平台上进行开发（Kotlin同样可以开发系统原生程序、JavaScript程序、安卓程序、iOS程序等）因为Java支持跨平台，能在编译后再任意平台上运行，因此，我们将JVM环境中学习Kotlin程序的开发，接下来我们要安装两个环境：</p><ul><li>Java 8 环境</li><li>Kotlin 1.9.0 环境</li></ul><p>首先我们来安装Java 8 环境，这里我们需要去下载JDK，这里推荐安装免费的ZuluJDK：<a href="https://www.azul.com/downloads/?version=java-8-lts&package=jdk">https://www.azul.com/downloads/?version=java-8-lts&amp;package=jdk</a></p><p>在这里选择自己的操作系统对应的安装包：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/thaGoKI8pXA7Vl6.png" alt="image-20220916155142546"></p><p>比如Windows下，我们就选择<code>.msi</code>的安装包即可（MacOS、Linux下同样选择对应的即可）</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/vjc62OFaqmAegCh.png" alt="image-20220916155242814"></p><p>下载完成后，我们直接双击安装：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/Loi3Ru7FAWHP6vN.png" alt="image-20220916160027645"></p><p><strong>注意，这里不建议各位小伙伴去修改安装的位置！</strong>新手只建议安装到默认位置（不要总担心C盘不够，该装的还是要装，尤其是这种环境，实在装不下就去将其他磁盘的空间分到C盘一部分）如果是因为没有安装到默认位置出现了任何问题，你要是找不到大佬问的话，又得重新来一遍，就很麻烦。</p><p>剩下的我们只需要一路点击Next即可，安装完成之后，我们打开CMD命令窗口（MacOS下直接打开“终端”）来验证一下（要打开CMD命令窗口，Windows11可以直接在下面的搜索框搜索cmd即可，或者直接在文件资源管理器路径栏输入cmd也可以）</p><p>我们直接输入java命令即可：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/ROD3vkzwT8yFqrc.png" alt="image-20220916160756046"></p><p>如果能够直接输出内容，说明环境已经安装成功了，正常情况下已经配置好了，我们不需要手动去配置什么环境变量，所以说安装好就别管了。</p><p>输入<code>java -version</code>可以查看当前安装的JDK版本：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/WzuBIOierlDSsEF.png" alt="image-20230728003717281"></p><p>只要是1.8.0就没问题了，后面的小版本号可能你们会比我的还要新。</p><p>接着是Kotlin 1.9.0 环境，我们需要前往：<a href="https://github.com/JetBrains/kotlin/releases">https://github.com/JetBrains/kotlin/releases</a> 下载最新的Kotlin编译器并进行安装：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/YotcAjxpWhuGQbS.png" alt="image-20230728003925164"></p><p>这里我们可以直接解压然后拖入到刚刚Java安装的同级目录下，我这里是 C:\Program Files 文件夹，也可以自定义位置，但是不推荐，因为很多小伙伴配环境直接配到自闭。</p><p>然后我们需要手动配置一下环境变量，打开系统环境变量配置：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/pmbJioxOuWlNS7q.png" alt="image-20230728004205319"></p><p>添加路径 C:\Program Files\kotlinc\bin 到Path环境变量下即可，然后我们依然打开CMD查看是否安装成功，输入<code>kotlinc -version</code>来查看安装情况：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/ZWeadTSborCFwsp.png" alt="image-20230728004657590"></p><p>这样我们就完成了所有环境的安装，我们可以来体验一下编写并且编译运行一个简单的Kotlin程序，我们新建一个文本文档，命名为<code>Main.txt</code>（如果没有显示后缀名，需要在文件资源管理器中开启一下）然后用记事本打开，输入以下内容：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在看不懂代码没关系，直接用就行，我们后面会一点一点讲解的。</p><p>编辑好之后，保存退出，接着我们将文件的后缀名称修改为<code>.kt</code>这是Java源程序文件的后缀名称：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/2rqRSVJQG8n5j1L.png" alt="image-20230728004854748"></p><p>此时我们打开CMD，注意要先进入到对应的路径下，比如我们现在的路径：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/8A4oq7XdeLthpmg.png" alt="image-20220916161720722"></p><p>我们使用<code>cd</code>命令先进入到这个目录下：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/HifR7pVSmqbP4Kh.png" alt="image-20220916161802753"></p><p>要编译一个Kotlin程序，我们需要使用<code>kotlinc</code>命令来进行，将我们的程序编译为jar包，并包含Kotlin的运行时依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kotlinc Main.kt -include-runtime -d Main.jar<br></code></pre></td></tr></table></figure><p>执行后，可以看到目录下多出来了一个<code>.jar</code>文件，这是一个打包好的标准Java程序：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/zFmwRE2KNkfIWtT.png" alt="image-20230728005317422"></p><p>接着我们就可以将其交给JVM运行了，我们直接使用<code>java -jar</code>命令即可：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/ovDweRJaqAu4Qyx.png" alt="image-20230728005354810"></p><p>可以看到打印了一个 Hello World! 字样，这样我们的第一个Kotlin程序就成功运行了。</p><h3 id="IDEA安装与使用"><a href="#IDEA安装与使用" class="headerlink" title="IDEA安装与使用"></a>IDEA安装与使用</h3><p>前面我们介绍了Kotlin开发环境的安装以及成功编译运行了我们的第一个Kotlin应用程序。</p><p>但是我们发现，如果我们以后都使用记事本来进行Kotlin程序开发的话，是不是效率太低了点？我们还要先编辑，然后要改后缀，还要敲命令来编译，有没有更加方便一点的写代码的工具呢？这里我们要介绍的是：<strong>IntelliJ IDEA</strong>（这里不推荐各位小伙伴使用Eclipse，因为操作上没有IDEA这么友好）</p><p>IDEA准确来说是一个集成开发环境（IDE），它集成了大量的开发工具，编写代码的错误检测、代码提示、一键完成编译运行等，非常方便。</p><p>下载地址：<a href="https://www.jetbrains.com.cn/idea/">IntelliJ IDEA：JetBrains 功能强大、符合人体工程学的 Java IDE</a></p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/UfIQzAXBS7TePm9.png" alt="image-20220916162544360"></p><p>我们直接点击下载即可，注意要下载下面的社区版，不要下载到终极版了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/uFonbh4JNycW1Hd.png" alt="image-20230728010334215"></p><p>这个软件本身是付费的，比较贵，而且最近还涨价了，不过这里我们直接下载面的社区版本就行了（JavaSE学习阶段不需要终极版，但是建议有条件的还是申请一个，功能更强大，体验更友好）</p><p>下载好之后，直接按照即可，这个不强制要求安装到C盘，自己随意，但是注意路径中不要出现中文！</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/jd64AxEfmQXWTNl.png" alt="image-20220916163329410"></p><p>这里勾选一下创建桌面快捷方式就行：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/buv9QmapGCENcXn.png" alt="image-20220916163401880"></p><p>安装完成后，我们直接打开就可以了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/g1sK2l5rWRCMnPN.png" alt="image-20230728011902631"></p><p>此时界面是全英文，如果各位小伙伴看得惯，可以直接使用全英文的界面（使用英文界面可以认识更多的专业术语词汇，但是可能看起来没中文那么直观，而且IDEA本身功能就比较多，英语不好的小伙伴就很头疼）这里还是建议英语不好的小伙伴使用中文界面，要使用中文只需要安装中文插件即可：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/mLblTjy7GwxCXYe.png" alt="image-20230728012014698"></p><p>我们打开Plugins插件这一栏，然后直接在插件市场里面搜索Chinese，可以找到一个中文语言包的插件，我们直接Install安装即可，安装完成后点击重启，现在就是中文页面了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/3E8pnTgarKuAM6j.png" alt="image-20230728012045895"></p><p>如果各位小伙伴不喜欢黑色主题，也可以修改为白色主题，只需要在自定义中进行修改即可，一共四种主题，我们还可以在下面的设置中开启新UI以及更换各种字体、字体大小等个性化内容。</p><p>如果你之前使用过其他IDE编写代码，这里还支持按键映射（采用其他IDE的快捷键方案）有需要的可以自己修改一下：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/3wbt7QhZmq9EKgY.png" alt="image-20220916164415447"></p><p>接下来，我们来看看如何使用IDEA编写Kotlin程序，IDEA是以项目的形式对一个Java程序进行管理的，所以说我们直接创建一个新的项目，点击新建项目：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/4qvjxmozBaJgOuH.png" alt="image-20220916164906998"></p><p>此时来到创建页面：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/OHAYo9gCziRwEnP.png" alt="image-20230728012243268"></p><ul><li><strong>名称：</strong> 你的Java项目的名称，随便起就行，尽量只带英文字母和数字，不要出现特殊字符和中文。</li><li><strong>位置：</strong> 项目的存放位置，可以自己根据情况修改，同样的，路径中不要出现中文。</li><li><strong>语言：</strong> IDEA支持编写其他语言的项目，但是这里我们直接选择Java就行了。</li><li><strong>构建系统：</strong> 在JavaSE阶段一律选择IntelliJ就行了，Maven我们会在JavaWeb之后进行讲解，Gradle会在安卓开发教程中介绍。</li><li><strong>JDK：</strong> 就是我们之前安装好的JDK，如果是默认路径安装，这里会自动识别（所以说不要随便去改，不然这些地方就很麻烦）</li></ul><p>当然，如果JDK这里没有自动识别到，那么就手动添加一下：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/16/fDJKB6M3TlWizoQ.png" alt="image-20220916165351016"></p><p>没问题之后，我们直接创建项目：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/IvjfL6XTranAJ2y.png" alt="image-20230728012604472"></p><p>进入之后，可以看到已经自动帮助我们创建好了一个<code>kt</code>源文件，跟我们之前的例子是一样的。要编译运行我们的Kotlin程序，只需要直接点击左边的三角形（启动按钮）即可：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/MhnDTu7Aot9U62F.png" alt="image-20230728012647988"></p><p>点击之后，会在下方自动开始构建：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/OjEWI3GlSnkB7mP.png" alt="image-20230728012720838"></p><p>完成之后，就可以在控制台看到输出的内容了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/mbneHTRtjNwasQh.png" alt="image-20230728012737850"></p><p>我们可以看到新增加了一个<code>out</code>目录，这里面就是刚刚编译好的<code>.class</code>文件，这种文件是Java的字节码文件，可以直接运行在JVM中：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/4t5hgi63QNO9rYJ.png" alt="image-20230728012808045"></p><p>IDEA非常强大，即使是编译之后的字节码文件，也可以反编译回原代码的样子：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/vfXyUNQBqL2kACO.png" alt="image-20230728012917915"></p><p>如果我们想写一个新的Kotlin项目，可以退出当前项目重新创建：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/oVxj4dBwaOgIXc9.png" alt="image-20230728013013293"></p><p>此时项目列表中就有我们刚刚创建的Java项目了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/8opBUjILRNrDWyO.png" alt="image-20230728013031657"></p><p>如果你还想探索IDEA的其他功能，可以点击欢迎页最下方的学习：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/jNJ2h7bOAc8ezug.png" alt="image-20230728013059958"></p><p>会有一个专门的引导教程项目，来教你如何使用各项功能：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/28/hU8QHKnOy3FbvuC.png" alt="image-20230728013143382"></p><p>熟悉了IDEA的使用之后，下节课我们就可以正式地开始学习Kotlin语言的语法了。</p><h3 id="程序代码基本结构"><a href="#程序代码基本结构" class="headerlink" title="程序代码基本结构"></a>程序代码基本结构</h3><p>还记得我们之前使用的示例代码吗？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码要实现的功能很简单，就是将 Hello World 这段文本信息输出到控制台。</p><p>在编写代码时，注意需要区分大小写，Kotlin语言严格区分大小写，如果我们没有按照规则来编写，那么就会出现红色波浪线报错：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/RYygkm536VhSDvH.png" alt="image-20230729013954179"></p><p>只要源代码中存在报错的地方，就无法正常完成编译得到字节码文件，强行运行会提示构建失败：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/L5uFwIJW1ONc3D7.png" alt="image-20230729014133372"></p><p>注意这里包括的花括号是成对出现的，并且一一对应。</p><p>所以说各位小伙伴在编写代码时一定要注意大小写。然后第二行，准确的说是最外层花括号内部就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到外面使用花括号前添加了<code>fun main()</code>，这是我们整个程序的入口点，我们的Kotlin程序也是从这里开始从上往下执行的。而其中的<code>println</code>语句就是用于打印其括号中包裹的文本，我们可以看到这个文本信息使用了<code>&quot;&quot;</code>进行囊括，否则会报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br></code></pre></td></tr></table></figure><p>这段代码的意思就是将双引号括起来的内容（字符串，我们会在后面进行讲解）输出（打印）到控制台上。</p><p>比如下面的代码，我们就可以实现先打印Hello World!，然后再打印 KFC vivo 50 到控制台：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    println(<span class="hljs-string">&quot;KFC vivo 50&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/YH12P5clNXWrLdU.png" alt="image-20230729014638513"></p><p>注意我们上面编写的打印语句其实是函数的调用（后续会进行讲解）不能写到同一行中，否则编译器会认为是同一句代码，同样会导致编译不通过：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/ja3bzymNF5DEBIh.png" alt="image-20230729014909257"></p><p>如果实在要写到同一行，那么我们需要在上一句代码最后添加<code>;</code>来表示上一段的结束：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/l4W8UMEviKVo2yp.png" alt="image-20230729015012657"></p><p>再比如下面的代码：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/JNQMTl3m1wvzKiB.png" alt="image-20230729015512923"></p><p>这里我们尝试在中途换行或是添加空格，因为没有添加分号，所以说编译器依然会认为是一行代码，因此编译不会出现错误，能够正常通过。当然，为了代码写得工整和规范，我们一般不会随意换行或是添加没必要的空格。注意随意换行和空格仅限于可分割区域，比如<code>println</code>本身是一个函数的完整名称，这就不能从中间直接断开，否则语义就完全不一样了。</p><h3 id="程序注释编写"><a href="#程序注释编写" class="headerlink" title="程序注释编写"></a>程序注释编写</h3><p>我们在编写代码时，可能有些时候需要标记一下这段代码表示什么意思：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/uQctfFYpomxgBnw.png" alt="image-20230729020246148"></p><p>但是如果直接写上文字的话，会导致编译不通过，因为这段文字也会被认为是程序的一部分。</p><p>这种情况，我们就需要告诉编译器，这段文字是我们做的笔记，并不是程序的一部分，那么要怎么告诉编译器这不是代码呢？很简单，我们只需要在前面加上双斜杠就可以了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/TpBZU4XMsYwNJAI.png" alt="image-20230729020334200"></p><p>添加双斜杠之后（自动变成了灰色），后续的文本内容只要没有发生换行，那么都会被认为是一段注释，并不属于程序，在编译时会被直接忽略，之后这段注释也不会存在于程序中。但是一旦发生换行那就不行了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/uKIAkXMl2SR1pWx.png" alt="image-20230729020416439"></p><p>那要是此时注释很多，一行写不完，我们想要编写很多行的注释呢？我们可以使用多行注释标记：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/xIs7PuwMkS16ABD.png" alt="image-20230729020514528"></p><p>多行可以使用<code>/*</code>和<code>*/</code>的组合来囊括需要编写的注释内容。</p><p>当然还有一种方式就是使用<code>/**</code>来进行更加详细的文档注释：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/AD3oyi6YXs5aOSq.png" alt="image-20230729020728328"></p><p>这种注释可以用来自动生成文档，当我们鼠标移动到Main上时，会显示相关的信息，我们可以自由添加一些特殊的注释，比如作者、时间等信息，也可以是普通的文字信息。</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/jPENB5caOzIoAHl.png" alt="image-20230729020747000"></p><p>这样，我们编写Kotlin程序的基本规则就讲解完毕了，从下一个小节开始，我们将先给各位小伙伴介绍我们的基本数据类型。</p><hr><h2 id="变量与基本类型"><a href="#变量与基本类型" class="headerlink" title="变量与基本类型"></a>变量与基本类型</h2><p>我们的程序不可能永远都只进行上面那样的简单打印操作，有些时候可能需要计算某些数据，此时我们就需要用到变量了。那么，什么是变量呢？我们在数学中其实已经学习过变量了：</p><blockquote><p>变量，指值可以变的量。变量以非<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%97/6204?fromModule=lemma_inlink">数字</a>的符号来表达，一般用拉丁字母。变量的用处在于能一般化描述指令的方式。结果只能使用真实的值，指令只能应用于某些情况下。变量能够作为某特定种类的值中任何一个的保留器。</p></blockquote><p>比如一个公式 x + 2 &#x3D; 6 此时<code>x</code>就是一个变量，变量往往代表着某个值，比如这里的<code>x</code>就代表的是4这个值。在Kotlin中，我们也可以让变量去代表一个具体的值，并且变量的值是可以发生变化的，在程序中，我们也可以使用变量，并且变量具有类型。</p><h3 id="计算机中的二进制表示（选学）"><a href="#计算机中的二进制表示（选学）" class="headerlink" title="计算机中的二进制表示（选学）"></a>计算机中的二进制表示（选学）</h3><p>进入到变量的学习之前，我们需要先补充一下计算机的底层知识，否则各位小伙伴后面听起来会很困难。</p><p>在计算机中，所有的内容都是二进制形式表示。十进制是以10为进位，如9+1&#x3D;10；二进制则是满2进位（因为我们的计算机是电子的，电平信号只有高位和低位，你也可以暂且理解为通电和不通电，高电平代表1，低电平代表0，由于只有0和1，因此只能使用2进制表示我们的数字！）比如1+1&#x3D;10&#x3D;2^1+0，一个位也叫一个bit，8个bit称为1字节，16个bit称为一个字，32个bit称为一个双字，64个bit称为一个四字，我们一般采用字节来描述数据大小。</p><p>注意这里的bit跟我们生活中的网速MB&#x2F;s是不一样的，小b代表的是bit，大B代表的是Byte字节（8bit &#x3D; 1Byte字节），所以说我们办理宽带的时候，100Mbps这里的b是小写的，所以说实际的网速就是100&#x2F;8 &#x3D; 12.5 MB&#x2F;s了。</p><blockquote><p>十进制的7 -&gt; 在二进制中为 111 &#x3D; 2^2 + 2^1 + 2^0</p></blockquote><p>现在有4个bit位，最大能够表示多大的数字呢？</p><ul><li>最小：0000 &#x3D;&gt; 0</li><li>最大：1111 &#x3D;&gt; 23+22+21+20 &#x3D;&gt; 8 + 4 + 2 + 1 &#x3D; 15</li></ul><p>在Kotlin中，无论是小数还是整数，他们可以带有符号，因此，首位就作为我们的符号位，还是以4个bit为例，首位现在作为符号位（1代表负数，0代表正数）：</p><ul><li>最小：1111 &#x3D;&gt; -(22+21+2^0) &#x3D;&gt; -7</li><li>最大：0111 &#x3D;&gt; +(22+21+2^0) &#x3D;&gt; +7 &#x3D;&gt; 7</li></ul><p>现在，我们4bit能够表示的范围变为了-7~+7，这样的表示方式称为<strong>原码</strong>。虽然原码表示简单，但是原码在做加减法的时候，很麻烦！以4bit位为例：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1001 &#x3D; 怎么让计算机去计算？（虽然我们知道该去怎么算，但是计算机不知道！）</p></blockquote><p>我们得创造一种更好的表示方式！于是我们引入了<strong>反码</strong>：</p><ul><li>正数的反码是其本身</li><li>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反</li></ul><p>经过上面的定义，我们再来进行加减法：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1110 &#x3D; 1111 &#x3D;&gt; -0 （直接相加，这样就简单多了！）</p></blockquote><p>思考：1111代表-0，0000代表+0，在我们实数的范围内，0有正负之分吗？0既不是正数也不是负数，那么显然这样的表示依然不够合理！根据上面的问题，我们引入了最终的解决方案，那就是<strong>补码</strong>，定义如下：</p><ul><li>正数的补码就是其本身 （不变！）</li><li>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1（即在反码的基础上+1，此时1000表示-8）</li><li>对补码再求一次补码就可得该补码对应的原码。</li></ul><p>比如-7原码为1111，反码为1000，补码就是1001了，-6原码为1110，反码为1001，补码就是1010。所以在补码下，原本的1000就作为新增的最小值-8存在。</p><p>所以现在就已经能够想通，-0已经被消除了！我们再来看上面的运算：</p><blockquote><p>1+(-1) &#x3D; 0001 + 1111 &#x3D; (1)0000 &#x3D;&gt; +0 （现在无论你怎么算，也不会有-0了！）</p></blockquote><p>所以现在，1111代表的不再是-0，而是-1，相应的，由于消除-0，负数多出来一个可以表示的数（1000拿去表示-8了），那么此时4bit位能够表示的范围是：-8~+7（Kotlin使用的就是补码！）在了解了计算机底层的数据表示形式之后，我们再来学习这些基本数据类型就会很轻松了。</p><h3 id="变量的声明与使用"><a href="#变量的声明与使用" class="headerlink" title="变量的声明与使用"></a>变量的声明与使用</h3><p>要声明一个变量，我们需要使用以下格式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> [变量名称] : [数据类型]<br></code></pre></td></tr></table></figure><p>这里的数据类型我们会在下节课开始逐步讲解，比如整数就是<code>Int</code>类型，不同类型的变量可以存储不同的类型的值。后面的变量名称顾名思义，就像<code>x</code>一样，这个名称我们可以随便起一个，但是注意要满足以下要求：</p><ul><li>标识符可以由大小写字母、数字、下划线(_)和美元符号($)组成，但是不能以数字开头。</li><li>变量不能重复定义，大小写敏感，比如A和a就是两个不同的变量。</li><li>不能有空格、@、#、+、-、&#x2F; 等符号。</li><li>应该使用有意义的名称，达到见名知意的目的（一般我们采用英文单词），最好以小写字母开头。</li><li>不可以是 true 和 false。</li><li>不能与Kotlin语言的关键字或是基本数据类型重名</li></ul><p>当然各位小伙伴没必要刻意去进行记忆有哪些关键字，我们会在学习的过程中逐步认识到这些关键字。新手要辨别一个单词是否为关键字，只需要通过IDEA的高亮颜色进行区分即可，比如：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/pCmYyvloK1Tsq9A.png" alt="image-20230729021646779"></p><p>深色模式下，关键字会高亮为橙色，浅色模式下会高亮为深蓝色，普通的代码都是正常的灰白色。</p><p>比如现在我们想要定义一个整数（Int）类型的变量<code>a</code>，那么就可以这样编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a : <span class="hljs-built_in">Int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是这个变量一开始没有任何值，比如现在我们要让这个变量表示10，那么就可以将10赋值给这个变量：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a : <span class="hljs-built_in">Int</span> = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过由于变量在一开始就被赋值为10这个整数，此时类型是确定的，Kotlin的编译器非常聪明，它支持自动推断类型，这里会自动将变量a的类型推断为Int类型，我们可以直接省略掉后面的Int类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者我们可以在使用时再对其进行赋值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a : <span class="hljs-built_in">Int</span><br>    a = <span class="hljs-number">10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>是不是感觉跟数学差不多？这种写法对于我们人来说，实际上是很好理解的，意思表达很清晰。为了更直观地查看变量的值，我们可以直接将变量的值也给打印到控制台：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/qFHI38zuQWxPACs.png" alt="image-20230729130856235"></p><p>变量的值也可以在中途进行修改：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">666</span><br>    a = <span class="hljs-number">777</span><br>    println(a)   <span class="hljs-comment">//这里打印得到的就是777</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量的值也可以直接指定为其他变量的值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">var</span> b = a <span class="hljs-comment">//直接让b等于a，那么a的值就会给到b</span><br>    println(b) <span class="hljs-comment">//这里输出的就是10了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们还可以让变量与数值之间做加减法（运算符会在后面详细介绍）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">9</span>   <span class="hljs-comment">//a初始值为9</span><br>    a = a + <span class="hljs-number">1</span>   <span class="hljs-comment">//a = a + 1也就是将a+1的结果赋值给a，跟数学是一样的，很好理解对吧</span><br>    println(a)  <span class="hljs-comment">//最后得到的结果就是10了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于那些只读的变量，我们可以将其表示为一个常量，使用<code>val</code>关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">666</span> <span class="hljs-comment">//使用val关键字，表示这是一个常量</span><br>    a = <span class="hljs-number">777</span>;    <span class="hljs-comment">//常量的值不允许发生修改</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译时得到报错：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/A2u3yx69GbZmStJ.png" alt="image-20230729142023779"></p><p>常量的值只有第一次赋值可以修改，其他任何情况下都不行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Int</span><br>    a = <span class="hljs-number">777</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，声明变量和常量我们就介绍完毕了，下一部分我们将介绍常见的一些数据类型。</p><h3 id="数字类型介绍"><a href="#数字类型介绍" class="headerlink" title="数字类型介绍"></a>数字类型介绍</h3><p>前面我们了解了如何创建变量，并进行使用，但是我们知道，不同的数据往往对应着不同的类型，比如整数我们使用的就是Int，而这一部分我们将学习更多的基本数据类型。</p><p>Kotlin提供了一组表示数字的内置类型，对于整数，有四种不同大小的类型，因此，值范围：</p><table><thead><tr><th>类型</th><th>大小（位）</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td>Byte</td><td>8</td><td>-128</td><td>127</td></tr><tr><td>Short</td><td>16</td><td>-32768</td><td>32767</td></tr><tr><td>Int</td><td>32</td><td>-2,147,483,648 (-2^31)</td><td>2,147,483,647（2^31-1）</td></tr><tr><td>Long</td><td>64</td><td>-9,223,372,036,854,775,808 (-2^63)</td><td>9,223,372,036,854,775,807（2^63 - 1）</td></tr></tbody></table><p>为什么不同的数据类型有着值范围呢？这是因为我们的计算机底层是采用0和1表示数据的，并且数据的表示位数有限，我们以二进制来计算，就像下面这样：</p><blockquote><p>1 + 1 &#x3D; 10 </p><p>可能很多小伙伴会好奇，为什么1 + 1得到的结果是数字十？这是因为二进制中只有0和1，因此只要满二就进一，所以就变成这样的结果了，如果各位是初次学习，可能会不太好理解。</p></blockquote><p>这里以上面的8位大小的Byte类型为例，在计算机底层存储数据时，只有8个bit位（一个bit位就可以表示一个0或1）来存储它，那么它能表示的最大值和最小值就是：</p><blockquote><p>00000000 ~ 11111111   转换为十进制就是   0 ~ 255</p></blockquote><p>不过为了能够表示负数，计算机一般使用补码进行表示，所以，上面的最小值和最大值就变成了-128 ~ 127了。</p><p>默认情况下，我们使用的常量数字都是Int类型，除非它的大小已经超出Int类型能够表示的最大范围，在超出Int类型可以表示的最大范围之后，默认为Long类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> one = <span class="hljs-number">1</span> <span class="hljs-comment">// Int</span><br><span class="hljs-keyword">val</span> threeBillion = <span class="hljs-number">3000000000</span> <span class="hljs-comment">// Long</span><br><span class="hljs-keyword">val</span> oneLong = <span class="hljs-number">1L</span> <span class="hljs-comment">// 我们也可以在数字后面添加大写字母L来表示这是一个Long类型的数值</span><br><span class="hljs-keyword">val</span> oneByte: <span class="hljs-built_in">Byte</span> = <span class="hljs-number">1</span>   <span class="hljs-comment">//Int类型数据也可以在符合其他类型范围时自动转换</span><br></code></pre></td></tr></table></figure><p>对于一些比较长的数字，我们可能需要使用类似于分隔符一类的东西来方便我们计数，比如：</p><blockquote><p>银行往往把1000000000这种长数字记为1,000,000,000，这样看起来会更直观</p></blockquote><p>在Kotlin中也可以像这样去编写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">1_000_000_000</span><br></code></pre></td></tr></table></figure><p>数字类型不仅可以写成十进制，也可以以十六进制或是二进制表示（Kotlin不支持八进制表示）只需要添加对应的前缀即可，比如一个十六进制数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">0xAF</span><br></code></pre></td></tr></table></figure><p>因为十六进制中大于等于十的数据没有对应的阿拉伯数字可以表示，所以在计算机中就以ABCDEF来替代这无法表示的6个数字。并且我们需要在数字前面添加0x表示这是16进制的数字，接下来是2进制：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = <span class="hljs-number">0b1001</span>   <span class="hljs-comment">//0b前缀表示二进制数据，后面的1010对应着十进制的9</span><br></code></pre></td></tr></table></figure><p>除了整数类型外，Kotlin还为无符号整数提供以下类型：</p><ul><li><code>UByte</code>：一个无符号8位整数，范围从0到255</li><li><code>UShort</code>：无符号16位整数，范围从0到65535</li><li><code>UInt</code>：一个无符号32位整数，范围从0到2^32 - 1</li><li><code>ULong</code>：一个无符号64位整数，范围从0到2^64 - 1</li></ul><p>为了使无符号整数更易于使用，Kotlin同样提供了用后缀标记，该后缀表示无符号类型（类似于上面的<code>Long</code>类型添加L字母）</p><ul><li><p>使用<code>u</code>或<code>U</code>字母作为后缀表示无符号整数。而具体的类型是根据前面变量的类型确定的，如果变量没有提供类型，编译器将根据数字的大小使用<code>UInt</code>或<code>ULong</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: UByte = 1u  <span class="hljs-comment">// UByte类型, 由变量提供的类型</span><br><span class="hljs-keyword">val</span> s: UShort = 1u <span class="hljs-comment">// UShort类型, 由变量提供的类型</span><br><span class="hljs-keyword">val</span> l: ULong = 1u  <span class="hljs-comment">// ULong类型, 由变量提供的类型</span><br><br><span class="hljs-keyword">val</span> a1 = 42u    <span class="hljs-comment">// UInt类型，根据数字大小自动推断得到</span><br><span class="hljs-keyword">val</span> a2 = 0xFFFF_FFFF_FFFFu <span class="hljs-comment">// ULong类型，根据数字大小自动推断得到</span><br></code></pre></td></tr></table></figure></li><li><p><code>uL</code>和<code>UL</code>可以将文字直接标记为无符号Long类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a = 1UL <span class="hljs-comment">// ULong类型，直接使用后缀标记</span><br></code></pre></td></tr></table></figure></li></ul><p>对于小数来说，Kotlin提供符合IEEE <a href="https://en.wikipedia.org/wiki/IEEE_754">754标准的</a>浮点类型<code>Float</code>和<code>Double</code>，<code>Float</code>为IEEE 754标准中的单精度数据，而&#96;Double位标准中的双精度数据，对于单双精度，本质上就是能够表示的小数位精度，双精度比单精度的小数精度更高。</p><p>这些类型的大小不同，并为不同精度的浮点数提供存储：</p><table><thead><tr><th>类型</th><th>大小（位）</th><th>符号与尾数位数</th><th>阶码位数</th><th>小数位数</th></tr></thead><tbody><tr><td><code>Float</code></td><td>32</td><td>24</td><td>8</td><td>6-7</td></tr><tr><td><code>Double</code></td><td>64</td><td>53</td><td>11</td><td>15-16</td></tr></tbody></table><p>我们也可以直接创建小数类型的<code>Double</code>和<code>Float</code>变量，小数部分与整数部分由一个小数点（<code>.</code>）隔开，编译器默认情况下会将所有的小数自动推断为推断<code>Double</code>类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> pi = <span class="hljs-number">3.1415</span> <span class="hljs-comment">// 默认推断为Double类型</span><br><span class="hljs-keyword">val</span> one: <span class="hljs-built_in">Double</span> = <span class="hljs-number">1</span> <span class="hljs-comment">// 这种写法是错误的，因为1不是小数，无法编译通过</span><br><span class="hljs-keyword">val</span> one: <span class="hljs-built_in">Double</span> = <span class="hljs-number">1.0</span> <span class="hljs-comment">// 但是这种写法就是对的，因为这样表示就是小数，即使小数位是0</span><br></code></pre></td></tr></table></figure><p>由于默认是Double类型，如果我们要明确指定值为<code>Float</code>类型，那么需要添加后缀<code>f</code>或<code>F</code>，并且由于精度问题，如果该值包含超过6-7位小数，则会丢失一部分精度：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> e = <span class="hljs-number">2.7182818284</span> <span class="hljs-comment">// Double类型的数值</span><br><span class="hljs-keyword">val</span> e: <span class="hljs-built_in">Float</span> = <span class="hljs-number">2.7182818284f</span> <span class="hljs-comment">// 这里表示为Float会导致精度折损，得到2.7182817</span><br></code></pre></td></tr></table></figure><p>与其他一些语言不同，Kotlin中的数字类型没有隐式转换的操作，例如，一个<code>Double</code>类型的变量无法将其值赋值给<code>Int</code>类型变量：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/zwiQaU81LsIujr4.png" alt="image-20230729211441090"></p><p>如果需要将一个整数转换为小数，我们会在后面学习函数之后再给各位小伙伴讲解如何调用函数进行显示类型转换。</p><h3 id="数字类型的运算"><a href="#数字类型的运算" class="headerlink" title="数字类型的运算"></a>数字类型的运算</h3><p>Kotlin支持数学上标准的算术运算集，例如：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code> 并且这些运算符都是通过运算符重载实现的具体功能，我们会在后续的章节中讲解Kotlin的运算符重载机制，这里各位小伙伴就当做是普通的运算操作即可。</p><blockquote><p>Kotlin支持运算符重载，运算符重载是一种允许程序员重新定义运算符的语言特性，通过运算符重载，您可以为自定义的类或数据类型定义一些特定操作的行为。</p></blockquote><p>其中加减乘除操作这里就不做介绍了，而%符号用于取余操作，也就是计算前面的数整除后面的数得到的余数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>)   <span class="hljs-comment">//计算1加上2的结果</span><br>println(<span class="hljs-number">2_500_000_000L</span> - <span class="hljs-number">1L</span>)   <span class="hljs-comment">//计算2500000000减去1的结果</span><br>println(<span class="hljs-number">3.14</span> * <span class="hljs-number">2.71</span>)   <span class="hljs-comment">//计算3.14与2.71的乘积</span><br>println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>)   <span class="hljs-comment">//计算10除以3得到的结果</span><br>println(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>)   <span class="hljs-comment">//10除以3得到的余数为1</span><br></code></pre></td></tr></table></figure><p>以上运算都比较简单，但是注意在除法运算中，只有两个操作数中出现小数，除法的结果才是小数，如果两个操作数都是整数，那么得到的结果也是整数，并且直接丢失小数位（不会四舍五入）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-number">5</span> / <span class="hljs-number">2</span>)    <span class="hljs-comment">//结果是2，而不是2.5</span><br></code></pre></td></tr></table></figure><p>同样的，除了直接使用字面量来进行运算，我们也可以将定义的变量参与到运算中：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    println(a / <span class="hljs-number">2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，在Kotlin中不同的算数运算符，它们的优先级也不一样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>在数学中，乘法运算的优先级比加法运算更高，因此我们需要先计算乘法，再计算加法，而在Kotlin中是一样的，乘法和除法运算符的优先级是高于加法运算符的，所以说上面算出来的结果是7，同样的，我们数学中使用括号来提升某些运算的优先级，在Kotlin中同样可以，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println((<span class="hljs-number">1</span> + <span class="hljs-number">1</span>) * <span class="hljs-number">3</span>)   <span class="hljs-comment">//使用小括号来强制提升优先级</span><br></code></pre></td></tr></table></figure><p>有些时候，我们可能想要让某个变量的值增加一定数值，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>a = a + <span class="hljs-number">9</span>   <span class="hljs-comment">//让a等于a+9的结果</span><br></code></pre></td></tr></table></figure><p>对于这种让变量本身加减乘除某个值的情况，可以使用赋值运算符简化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">a += <span class="hljs-number">9</span>   <span class="hljs-comment">//等价于 a = a + 9</span><br>a /= <span class="hljs-number">9</span>   <span class="hljs-comment">//等价于 a = a / 9</span><br>a %= <span class="hljs-number">2</span>   <span class="hljs-comment">//等价于 a = a % 2</span><br></code></pre></td></tr></table></figure><p>如果我们只是希望某个变量自增或自减1，那么我们可以像这样去写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    a++    <span class="hljs-comment">//使用两个++表示自增1</span><br>    println(a)     <span class="hljs-comment">//打印得到11</span><br>  a--    <span class="hljs-comment">//使用两个--表示自减1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过，这个双++符号，可以放在变量的前后，都能实现自增操作：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>++a   <span class="hljs-comment">//最终效果等价于a++</span><br></code></pre></td></tr></table></figure><p>但是他们有一个本质区别，就是++在前面，a是先自增再得到结果，而++在后面，是a先得到结果，再进行自增，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span><br>    println(a++)   <span class="hljs-comment">//这里++在后面，打印a的值依然是10，但是结束之后a的值就变成11了</span><br>    println(++a)   <span class="hljs-comment">//这里++在前面，打印a的值是这里先自增之后的结果，就是12了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于新手来说，这个很容易搞混，所以说一定要记清楚。</p><p>Kotlin提供了一组整数的<em>位运算</em>操作，可以直接在二进制层面上与数字表示的位进行操作，不过只适用于<code>Int</code>和<code>Long</code>类型的数据：</p><ul><li><code>shl(bits)</code>– 有符号左移</li><li><code>shr(bits)</code>– 有符号右移</li><li><code>ushr(bits)</code>– 无符号右移</li><li><code>and(bits)</code>– 按位与</li><li><code>or(bits)</code>– 按位或</li><li><code>xor(bits)</code>– 按位异或</li><li><code>inv()</code>– 取反</li></ul><p>这里我们从按位与开始讲解，比如下面的两个数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">val</span> c = a and b <span class="hljs-comment">//进行按位与运算</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>按位与实际上就是让这两个数每一位都进行比较，如果这一位两个数都是1，那么结果就是1，否则就是0：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D; 1 &#x3D; 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul><p>同样的，按位或，其实就是只要任意一个为1（不能同时为0）那么结果就是1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">9</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">3</span><br>    <span class="hljs-keyword">val</span> c = a or b<br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;11&#x3D; 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul><p>按位异或的意思就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a &#x3D; 9 &#x3D; 1001</li><li>b &#x3D; 3 &#x3D; 0011</li><li>c &#x3D;10&#x3D; 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul><p>按位取反操作跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><ul><li>127 &#x3D; 01111111</li><li>-128 &#x3D; 10000000</li></ul><p>所以说计算的结果就是-128了。</p><p>除了以上的四个运算符之外，还有位移运算符，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-number">1</span> shl <span class="hljs-number">2</span> <span class="hljs-comment">//shl表示左移运算</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1 &#x3D; 00000001</li><li>4 &#x3D; 00000100（左移两位之后，1跑到前面去了，尾部使用<strong>0</strong>填充，此时就是4）</li></ul><p>我们发现，左移操作每进行一次，结果就会x2，所以说，除了直接使用<code>*</code>进行乘2的运算之外，我们也可以使用左移操作来完成。</p><p>同样的，右移操作就是向右移动每一位咯：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-number">8</span> shr <span class="hljs-number">2</span>  <span class="hljs-comment">//shr表示右移运算</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>跟上面一样，右移操作可以快速进行除以2的计算。对于负数来说，左移和右移操作不会改变其符号位上的数字，符号位不受位移操作影响：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = -<span class="hljs-number">8</span> shr <span class="hljs-number">2</span>   <span class="hljs-comment">//这里得到的依然是个负数</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用考虑符号位的右移操作，一旦考虑符号位，那么符号会被移动：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = -<span class="hljs-number">1</span> ushr <span class="hljs-number">1</span> <span class="hljs-comment">//无符号右移是ushr，移动会直接考虑符号位</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：</p><ul><li>-1 &#x3D; 11111111 11111111 11111111 11111111</li><li>右移： 01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值 2147483647 了，注意，不存在无符号左移操作。</p><p>最后我们再总结一下不同运算符的优先级，对应的优先级从上往下依次减弱：</p><ol><li>一元运算符：例如 ++、–、+、-、!、~</li><li>乘法和除法运算符：*、&#x2F;、%</li><li>加法和减法运算符：+、-</li><li>位移运算符：shl、shr、ushr</li><li>按位与运算符：and</li><li>按位或运算符：or</li><li>按位异或运算符：xor</li><li>逻辑运算符：&amp;&amp;、||</li><li>比较运算符：&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</li><li>区间运算符：..</li><li>赋值运算符：&#x3D;、+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;、%&#x3D;</li></ol><p>当然，这里列出的部分运算符各位小伙伴可能还没有遇到，不过在后续的学习中，我们会慢慢认识的，届时各位小伙伴可以回顾一下这里。</p><h3 id="布尔类型介绍"><a href="#布尔类型介绍" class="headerlink" title="布尔类型介绍"></a>布尔类型介绍</h3><p>布尔类型是Kotlin中的一个比较特殊的类型，它并不是存放数字的，而是状态，它有下面的两个状态：</p><ul><li>true - 真</li><li>false - 假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> a: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>如果给一个其他的值，会无法编译通过：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/hMkCfA6DVpWTPIi.png" alt="image-20230729214712431"></p><p>布尔值除了可以直接赋值得到，也可以通过一些关系运算得到，常见的关系运算有大于、小于以及等于，所有的关系运算在下方：</p><ul><li>判断两个数是否相等：<code>a == b</code>和<code>a != b</code></li><li>判断数之间大小：<code>a &lt; b</code>，<code>a &gt; b</code>，<code>a &lt;= b</code>，<code>a &gt;= b</code></li><li>判断数是否在指定范围中：<code>a..b</code>，<code>x in a..b</code>，<code>x !in a..b</code></li></ul><p>比如我们想判断变量a和变量b的值是否相同：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">8</span><br>    println(a == b)  <span class="hljs-comment">//判断a是否等于b（注意等号要写两个，因为单等号为赋值运算）</span><br>    println(a &gt;= b)   <span class="hljs-comment">//判断a是否大于等于b</span><br>    println(a &lt; b)   <span class="hljs-comment">//判断a是否小于b</span><br>  <span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Boolean</span> = a != b   <span class="hljs-comment">//判断a是否不等于b并将结果赋值给变量c</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，通过逻辑运算得到的结果，都是true或false，也就是我们这里学习的Boolean类型值。在Kotlin中，我们为了快速判断某个数是否在一个区间内，可以直接使用 <code>a..b</code> 来表示一个数学上<code>[a, b]</code>这样的闭区间，比如我们这里要判断变量<code>a</code>的值是否在1~10之间：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    println(a <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>)   <span class="hljs-comment">//这里1..10表示1~10这个闭区间，使用in关键字来进行判断</span><br>  println(a <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span>.&lt;<span class="hljs-number">10</span>)   <span class="hljs-comment">//这里1..&lt;10表示1~10这个前闭后开区间，使用in关键字来进行判断</span><br>  println(a !<span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span>)   <span class="hljs-comment">//相反的，使用!in判断是否不在这个区间</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于Boolean类型的变量之间，也有一些逻辑运算符用于进行组合条件判断：</p><ul><li><code>||</code>– 逻辑或运算</li><li><code>&amp;&amp;</code>– 逻辑与运算</li><li><code>!</code>– 取反运算</li></ul><p>其中取反运算最好理解，它可以让true变成false，false变为true，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">20</span><br>    <span class="hljs-keyword">val</span> c = a &gt; b   <span class="hljs-comment">//这里很明显c应该为false</span><br>    println(!c)   <span class="hljs-comment">//这里进行了取反操作并打印，那么结果就是true了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于逻辑与和逻辑或运算，我们可以像这样去使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> b = <span class="hljs-number">0</span><br>    println(<span class="hljs-number">100</span> &gt;= a &amp;&amp; b &gt;= <span class="hljs-number">60</span>)  <span class="hljs-comment">//我们可以使用与运算符连接两个判断表达式，只有两边都为true结果才是true</span><br>    println(<span class="hljs-number">100</span> &gt;= a || b &gt;= <span class="hljs-number">60</span>)  <span class="hljs-comment">//我们可以使用或运算符连接两个判断表达式，只要两边任意一个为true结果就是true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与运算符要求左右两边同时为真，得到的结果才是真，否则一律为假，而或运算就是要求两边只要有一边为真，结果就是真，除非两边同时为false，那么就没戏了。</p><p>不过需要注意的是，在与运算中，第一个判断表达式得到了<code>false</code>之后，此时不会再继续运行第二个表达式，而是直接得到结果<code>false</code>（逻辑运算符会出现短路的情况，只要第一个不是真，就算第二个是真也不可能了，所以说为了效率，后续就不用再判断了，在使用时一定要注意这一点）同样的，或运算下当发现第一个判断表达式为true时，也不会继续向后执行了，因为结果已经是顶真了。</p><h3 id="字符类型介绍"><a href="#字符类型介绍" class="headerlink" title="字符类型介绍"></a>字符类型介绍</h3><p>字符类型也是一个重要的基本数据类型，它可以表示计算机中的任意一个字符（包括中文、英文、标点等一切可以显示出来的字符）字符由<code>Char</code>类型表示，字符值用单引号：<code>&#39;1&#39;</code>囊括：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Char</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>println(c)<br></code></pre></td></tr></table></figure><p>注意，字符只能表示一单个字符，我们之前遇到的字符串跟字符不一样，关于字符串我们会在下节课进行介绍。</p><p>我们打印出来的也是单个字符：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/lS12kDwfR9TrO4b.png" alt="image-20230729233735560"></p><p>那么可能会有小伙伴好奇，字符类型在计算机底层是怎么进行存储的呢？实际上每个字符在计算机中都会对应一个字符码，首先我们需要介绍ASCII码：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><p>比如我们的英文字母<code>A</code>要展示出来，那就是一个字符的形式，而其对应的ASCII码值为65，我们可以使用<code>.code</code>来获取某个字符对应的ASCII码，比如下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c: <span class="hljs-built_in">Char</span> = <span class="hljs-string">&#x27;A&#x27;</span><br>    println(c.code)   <span class="hljs-comment">//这里就会打印字符对应的ASCII码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>得到结果为：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/29/a4ZRYXcK5E7d1MP.png" alt="image-20230729233949424"></p><p>字符型占据2个字节的空间用于存放数据：</p><ul><li>char 字符型（16个bit，也就是2字节，它不带符号）范围是0 ~ 65535</li></ul><p>不过，这里的字符表里面不就128个字符吗，那<code>char</code>干嘛要两个字节的空间来存放呢？我们发现表中的字符远远没有我们所需要的那么多，这里只包含了一些基础的字符，中文呢？那么多中文字符（差不多有6000多个），用ASCII编码表那128个肯定是没办法全部表示的，但是我们现在需要在电脑中使用中文，这时，我们就需要扩展字符集了。</p><blockquote><p>Unicode是一个用于表示文本字符的标准字符集。它包含了世界上几乎所有的已知字符，包括不同国家和地区的字母、数字、标点符号、符号图形以及特殊的控制字符。</p><p>与Unicode不同，ASCII（American Standard Code for Information Interchange）是一个只包含128个字符的字符集。它最初是为了在计算机系统中传输基本英语字符而设计的。ASCII字符集包含了常见的拉丁字母、数字、标点符号以及一些特殊字符。</p><p>Unicode采用了一个更加广泛的字符编码方案，包括了不同的字符集编码，比如UTF-8和UTF-16等。UTF-8是一种可变长度的编码方案，它可以用来表示Unicode中的任意字符，且向后兼容ASCII字符集。而UTF-16则是一种固定长度的编码方案，它使用两个字节来表示一个Unicode字符。</p><p>与ASCII相比，Unicode的主要优势在于它能够表示各种不同的语言和字符，而不仅仅限于英语字符。这使得Unicode成为全球通用的字符编码标准，为不同国家和地区的语言提供了统一的编码方式。</p></blockquote><p>所以，一个Char就能表示几乎所有国家语言的字符，这样就很方便了。</p><p>接着我们来介绍一下转译字符，对于一些我们平时很难直接通过键盘或是输入法打出来的字符，比如一些特殊符号：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/ugem2scKxyX7wJL.png" alt="image-20230730000657951"></p><p>这些符号我们没办法直接打出来，但是现在我们又想要表示它们，该怎么做呢？我们可以使用转义来将这些字符对应的Unicode编码转换为对应的字符，只需要在前面加上<code>\u</code>即可，比如✓这个符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-string">&#x27;\u2713&#x27;</span>   <span class="hljs-comment">//符号✓对应的Unicode编码为10003，这里需要转换为16进制表示，结果为0x2713</span><br>    println(c)<br>&#125;<br></code></pre></td></tr></table></figure><p>除了能像这样表示一个特殊字符，我们也可以使用一些其他的转义字符来表示各种东西：</p><ul><li><code>\t</code> – 选项卡</li><li><code>\b</code> – 退格</li><li><code>\n</code> – 换行（LF）</li><li><code>\r</code> – 回车（CR）</li><li><code>\&#39;</code> – 单引号</li><li><code>\&quot;</code> – 双引号</li><li><code>\\</code> –反斜杠</li><li><code>\$</code> – 美元符号</li></ul><p>这些转义字符都是为了防止在特殊情况下无法表示某些字符，而给我们的替代方案，后续各位小伙伴在使用时可以回来参考一下。</p><h3 id="字符串类型介绍"><a href="#字符串类型介绍" class="headerlink" title="字符串类型介绍"></a>字符串类型介绍</h3><p>字符串类是一个比较特殊的类型，它用于保存字符串。我们知道，基本类型<code>Char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列，它的类型名称为<code>String</code>。</p><p>字符串通常由双引号<code>&quot;&quot;</code>囊括，它可以表示一整串字符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> str: String = <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><p>如果我们需要再字符串中换行，需要用到转义字符，字符串中同样支持使用转义字符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;Hello\nWorld&quot;</span><br>    println(text)<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，字符串只能写一行，有时候有点不太够用，可能我们想要打印多行文本，我们除了用<code>\n</code>转义字符来换行之外，也可以直接使用三个双引号<code>&quot;&quot;&quot;</code>来表示一个原始字符串，但是原始字符串无法使用转义字符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    这是第一行</span><br><span class="hljs-string">    这第二行</span><br><span class="hljs-string">    别\n了，没用</span><br><span class="hljs-string">    真牛逼啊，这功能隔壁Java15才有</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    println(text)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/Y5fbh8FEOZcsMVz.png" alt="image-20230730002653406"></p><p>可以看到确实是够原始的，把我代码里面的缩进都给打印出来了，这样肯定不是我们希望的样子，我们希望的仅仅是一个简单换行而已，那这里该怎么去处理呢？后面我们在讲解函数之后，会额外补充这里的内容。</p><p>有时候为了方便，我们可以将不同的字符串拼接使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> str1 = <span class="hljs-string">&quot;Hello&quot;</span><br>    <span class="hljs-keyword">val</span> str2 = <span class="hljs-string">&quot;World&quot;</span><br>    <span class="hljs-keyword">val</span> str = str1 + str2<br>    println(str)   <span class="hljs-comment">//使用 + 来拼接两个字符串，得到的结果就是两个字符串合在一起的结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字符串除了和字符串拼接之外，也可以和其他类型进行拼接：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;这是拼接的值&quot;</span> + a<br>    println(text)   <span class="hljs-comment">//打印出来就是与其他类型的拼接结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们需要注意字符串拼接的顺序，只能由字符串拼接其他类型，如果是其他类型拼接字符串，可能会出现问题：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/AZSxuKqRvMohp8I.png" alt="image-20230730003158613"></p><p>但是现在我们就是希望其他类型的数据拼在最前面，这里应该怎么做呢？我们可以使用字符串模版来完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;这是拼接的值<span class="hljs-variable">$a</span>&quot;</span>  <span class="hljs-comment">//这里的$为模版表达式，可以直接将后面跟着的变量或表达式以字符串形式替换到这个位置</span><br>    println(text)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要添加到前面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;<span class="hljs-variable">$a</span> 这是拼接的值&quot;</span> <span class="hljs-comment">//注意这里$a之后必须空格，否则会把后面的整个字符串认为这个变量的名字</span><br></code></pre></td></tr></table></figure><p>出现这种情况除了用空格去解决之外，我们也可以添加一个花括号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;a&#125;</span>这是拼接的值&quot;</span>  <span class="hljs-comment">//添加花括号就可以消除歧义了</span><br><span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;a &gt; <span class="hljs-number">0</span>&#125;</span>这是拼接的值&quot;</span>  <span class="hljs-comment">//花括号中也可以写成表达式</span><br></code></pre></td></tr></table></figure><p>由于美元符用于模版表达式了，所以说如果我们希望在字符串中仅仅表示$这个字符，那么我们需要用到转义：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> text = <span class="hljs-string">&quot;\$这是美元符&quot;</span>   <span class="hljs-comment">//普通字符串直接使用\$表示</span><br><span class="hljs-comment">//原始字符串要套个娃</span><br><span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  <span class="hljs-subst">$&#123;<span class="hljs-string">&#x27;$&#x27;</span>&#125;</span>这是美元符    </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>至此，关于Kotlin的变量与基本类型的内容我们就暂时告一段落了，不过在后面学习了更多知识后，我们还会回顾这些基本类型，了解他们的更多用法，并且认识我们唯一没有在这一部分介绍的数组类型。</p><hr><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>经过前面的学习，我们知道，程序都是从上往下依次运行的，但是，仅仅是这样还不够，我们需要更加高级的控制语句来使得程序更加有趣。比如，判断一个整数变量，大于1则输出yes，小于1则输出no，这时我们就需要用到选择结构来帮助我们完成条件的判断和程序的分支走向。</p><p>在前面我们介绍了运算符，我们可以通过逻辑运算符和关系运算符对某些条件进行判断，并得到真或是假的结果。这一部分我们将继续使用这些运算符进行各种判断，以及实现流程控制。</p><h3 id="选择结构（if-else）"><a href="#选择结构（if-else）" class="headerlink" title="选择结构（if-else）"></a>选择结构（if-else）</h3><p>某些时候，我们希望进行判断，只有在条件为真时，才执行某些代码，这种情况就需要使用到选择分支语句，首先我们来认识一下<code>if</code>语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (条件判断) 判断成功执行的代码;<br></code></pre></td></tr></table></figure><p><code>if</code>的小括号中需要我们传入一个Boolean类型的结果，可以是一个Boolean变量，也可以是一个判断语句，反正只能接受true和false两种结果，比如下面的这个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">12</span>)  <span class="hljs-comment">//只有当a判断等于12时，才会执行下面的打印语句</span><br>        println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>    println(<span class="hljs-string">&quot;我是后续的语句&quot;</span>)  <span class="hljs-comment">//if只会对紧跟着的一行代码生效，后续的内容无效</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>if</code>会进行判断，只有判断成功时才会执行紧跟着的语句，否则会直接跳过，注意，如果我们想要在if中执行多行代码，需要使用代码块将这些代码囊括起来（实际上代码块就是将多条语句复合到一起，使用花括号囊括）所以说，我们以后使用if时，如果分支中有多行代码需要执行，就需要添加花括号，如果只有一行代码，花括号可以直接省略，包括我们后面会讲到的else、while、for语句都是这样的，就像下面这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">15</span><br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) &#123;    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        println(<span class="hljs-string">&quot;a大于10&quot;</span>)<br>        println(<span class="hljs-string">&quot;a的值为：<span class="hljs-variable">$a</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;我是外层&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们希望判断条件为真时执行某些代码，条件为假时执行另一些代码，我们可以在后面继续添加else语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> a = <span class="hljs-number">15</span><br>    <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">10</span>) &#123;    <span class="hljs-comment">//只有判断成功时，才会执行下面的代码块中内容，否则直接跳过</span><br>        println(<span class="hljs-string">&quot;a大于10&quot;</span>)<br>        println(<span class="hljs-string">&quot;a的值为：<span class="hljs-variable">$a</span>&quot;</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;   <span class="hljs-comment">//当判断不成功时，会执行else代码块中的代码</span><br>        println(<span class="hljs-string">&quot;a小于10&quot;</span>)<br>        println(<span class="hljs-string">&quot;a的值为：<span class="hljs-variable">$a</span>&quot;</span>)<br>    &#125;<br>    println(<span class="hljs-string">&quot;我是外层&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>if-else</code>语句就像两个分支，跟据不同的判断情况从而决定下一步该做什么，这跟我们之前认识的三元运算符性质比较类似。</p><p>那如果此时我们需要判断多个分支呢？比如我们现在希望判断学生的成绩，不同分数段打印的等级不一样，比如90以上就是优秀，70以上就是良好，60以上是及格，其他的都是不及格，那么这种我们又该如何判断呢？要像这样进行连续判断，我们需要使用<code>else-if</code>来完成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> score = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">90</span>) <span class="hljs-comment">//90分以上才是优秀</span><br>        println(<span class="hljs-string">&quot;优秀&quot;</span>) <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">70</span>) <span class="hljs-comment">//当上一级if判断失败时，会继续判断这一级</span><br>        println(<span class="hljs-string">&quot;良好&quot;</span>) <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>) <br>        println(<span class="hljs-string">&quot;及格&quot;</span>) <br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//当之前所有的if都判断失败时，才会进入到最后的else语句中</span><br>        println(<span class="hljs-string">&quot;不及格&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，<code>if</code>分支语句还支持嵌套使用，比如我们现在希望低于60分的同学需要补习，0-30分需要补Java，30-60分需要补C++，这时我们就需要用到嵌套：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> score = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">if</span> (score &lt; <span class="hljs-number">60</span>) &#123;   <span class="hljs-comment">//先判断不及格</span><br>        <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">30</span>) <span class="hljs-comment">//在内层再嵌套一个if语句进行进一步的判断</span><br>            println(<span class="hljs-string">&quot;学习C++&quot;</span>) <br>        <span class="hljs-keyword">else</span> <br>            println(<span class="hljs-string">&quot;学习Java&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了if自己可以进行嵌套使用之外，其他流程控制语句同样可以嵌套使用，也可以与其他流程控制语句混合嵌套使用。这样，我们就可以灵活地使用<code>if</code>来进行各种条件判断了。</p><p>除了直接执行语句之外，我们也可以将if和else用作结果判断，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> score = <span class="hljs-number">2</span><br>  <span class="hljs-comment">//这里判断socre是否大于60，是就得到Yes，否就得到No，并且可以直接赋值给变量</span><br>    <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">60</span>) <span class="hljs-string">&quot;Yes&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;No&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这类似于其他语言，如Java和C中的三元运算，不过Kotlin中没有那样的三元运算符，只能使用上面的表达式，对于多行代码块的情况，默认最后一行作为返回的结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> score = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">val</span> res = <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">60</span>) &#123;<br>        println(<span class="hljs-string">&quot;不错啊期末没挂科&quot;</span>)<br>        <span class="hljs-string">&quot;Yes&quot;</span>   <span class="hljs-comment">//代码块默认最后一行作为返回结果</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        println(<span class="hljs-string">&quot;不会有人Java期末还要挂科吧&quot;</span>)<br>        <span class="hljs-string">&quot;No&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，如果需要这种返回结果的表达式，那么必须要存在<code>else</code>分支，否则不满足条件岂不是没结果了？</p><h3 id="选择结构（when）"><a href="#选择结构（when）" class="headerlink" title="选择结构（when）"></a>选择结构（when）</h3><p>前面我们介绍了if语句，我们可以通过一个if语句轻松地进行条件判断，然后根据对应的条件，来执行不同的逻辑，当然除了这种方式之外，我们也可以使用<code>when</code>语句来实现，它更适用于多分支的情况：</p><p><code>when</code>定义具有多个分支的条件表达式。它类似于类似Java和C语言中的<code>switch</code>语句，它简单的形式看起来像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (目标) &#123;<br>    匹配值<span class="hljs-number">1</span> -&gt; 代码...   <span class="hljs-comment">//我们需要传入一个目标，比如变量，或是计算表达式等</span><br>    匹配值<span class="hljs-number">2</span> -&gt; 代码...   <span class="hljs-comment">//如果目标的值等于我们这里给定的匹配值，那么就执行case后面的代码</span><br>    <span class="hljs-keyword">else</span> -&gt; &#123;<br>        代码...    <span class="hljs-comment">//如果以上条件都不满足，就进入else中（可以没有），类似于之前的if-elseif-else</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如现在我们要根据学生的等级进行分班，学生有ABC三个等级：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-string">&#x27;A&#x27;</span><br>    <span class="hljs-keyword">when</span> (c) &#123;<br>        <span class="hljs-string">&#x27;A&#x27;</span> -&gt; println(<span class="hljs-string">&quot;去尖子班！准备冲刺985大学！&quot;</span>)<br>        <span class="hljs-string">&#x27;B&#x27;</span> -&gt; println(<span class="hljs-string">&quot;去平行班！准备冲刺一本！&quot;</span>)<br>        <span class="hljs-string">&#x27;C&#x27;</span> -&gt; println(<span class="hljs-string">&quot;去职高深造。&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果将when用作表达式，则else分支必须存在，除非编译器能推断出所有可能的情况都包含分支条件，比如下面的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-string">&#x27;A&#x27;</span><br>    <span class="hljs-keyword">val</span> numericValue = <span class="hljs-keyword">when</span> (c) &#123;<br>        <span class="hljs-string">&#x27;B&#x27;</span> -&gt; <span class="hljs-number">0</span><br>        <span class="hljs-string">&#x27;A&#x27;</span> -&gt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-number">2</span>    <span class="hljs-comment">//还有其他情况，这里必须添加else，不然其他情况岂不是没返回的东西？</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下情况就可以不需要else语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> c = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">val</span> numericValue = <span class="hljs-keyword">when</span> (c) &#123;<br>        <span class="hljs-literal">false</span> -&gt; <span class="hljs-number">0</span><br>        <span class="hljs-literal">true</span> -&gt; <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 由于Boolean只具备真和假条件，这里的&#x27;else&#x27; 就不再强制要求</span><br>      <span class="hljs-comment">// 这同样适用于比如枚举类等</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>when</code><em>语句</em>中，遇到以下情况，携带<code>else</code>分支是必须的：</p><ul><li><code>when</code>分支中仅有一个<code>Boolean</code>类型、枚举 或 密封，以及用于判断的目标变量是可空的情况（后面会讲解）</li><li><code>when</code>分支没有包括该判断目标的所有可能的值。</li></ul><p>有时候我们可能希望某些值都属于同一个情况，可以使用逗号将其条件组合成一行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (x) &#123;<br>    <span class="hljs-number">0</span>, <span class="hljs-number">1</span> -&gt; print(<span class="hljs-string">&quot;x == 0 or x == 1&quot;</span>)<br>    <span class="hljs-keyword">else</span> -&gt; print(<span class="hljs-string">&quot;otherwise&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以使用任意表达式（不仅仅是常量）作为分支条件，比如之前的if-else案例中我们判断学生成绩：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> score = <span class="hljs-number">10</span><br>    <span class="hljs-keyword">val</span> grade = <span class="hljs-keyword">when</span>(score) &#123;<br>      <span class="hljs-comment">//使用in判断目标变量值是否在指定范围内</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-number">100.</span><span class="hljs-number">.90</span> -&gt; <span class="hljs-string">&quot;优秀&quot;</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-number">89.</span><span class="hljs-number">.80</span> -&gt; <span class="hljs-string">&quot;良好&quot;</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-number">79.</span><span class="hljs-number">.70</span> -&gt; <span class="hljs-string">&quot;及格&quot;</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-number">69.</span><span class="hljs-number">.60</span> -&gt; <span class="hljs-string">&quot;牛逼&quot;</span><br>        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;不及格&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>包括我们之后学习的类型判断<code>is</code>表达式、函数调用等，都可以在这里作为分支条件。</p><h3 id="循环结构（for）"><a href="#循环结构（for）" class="headerlink" title="循环结构（for）"></a>循环结构（for）</h3><p>通过前面的学习，我们了解了如何使用分支语句来根据不同的条件执行不同的代码，我们接着来看第二种重要的流程控制语句：循环语句。</p><p>我们在某些时候，可能需要批量执行某些代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>)   <span class="hljs-comment">//把这句话给我打印三遍</span><br>    println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>)<br>    println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>遇到这种情况，我们由于还没学习循环语句，那么就只能写N次来实现这样的多次执行。但是如果此时要求我们将一句话打印100遍、1000遍、10000遍，那么我们岂不是光CV代码就要搞一下午？</p><p>现在，要解决这种问题，我们可以使用for循环语句来多次执行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (遍历出来的单个目标变量 <span class="hljs-keyword">in</span> 可遍历目标) 循环体<br></code></pre></td></tr></table></figure><p>这里的可遍历目标有很多，比如：</p><ul><li>数组</li><li>区间</li><li>任何实现了运算符重载函数iterator的类</li></ul><p>这里我们只学习了区间，我们来看看如何使用，比如我们要打印一段话3遍：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>)  <span class="hljs-comment">//这里直接写入1..3表示1~3这个区间</span><br>        println(<span class="hljs-string">&quot;大烟杆嘴里塞，我只抽第五代：<span class="hljs-variable">$i</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果为：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/12/16/5XuaWMjw3YDxvlK.png" alt="image-20231216151835790"></p><p>可以看到，每一次遍历出来的变量<code>i</code>，其实就是每次遍历的下一个目标，比如这里是1..3的区间，那么得到的依次就是1、2、3这三个结果了，唯一需要注意的是，这里的<code>i</code>是局部的，只在<code>for</code>循环内部可用（包括嵌套的内部）并不是整个main中都可以使用：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/mCGVySxMK2YLfkJ.png" alt="image-20230730160547655"></p><p>默认情况下，每一轮循环都会向后+1，我们也可以自由控制每一轮增加多少，也就是步长：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.10</span> step <span class="hljs-number">2</span>) &#123;<br>        println(i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，打印出来的数据会按照步长进行增长：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/08/01/vpHO32fU4SL1qYM.png" alt="image-20230801014238248"></p><p>那如果我们需要从10到1倒着进行遍历呢？我们可以将<code>..</code>替换为<code>downTo</code>来使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">1</span>) &#123;<br>        println(i)   <span class="hljs-comment">//这里得到的就是10到1倒着排列的范围了</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用调试来观察每一轮的变化，调试模式跟普通的运行一样，也会执行我们的Java程序，但是我们可以添加断点，也就是说当代码运行到断点位置时，会在这里暂停，我们可以观察当代码执行到这个位置时各个变量的值：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/CbXHzwlAIa5uo8e.png" alt="image-20230730152627331"></p><p>调试模式在我们后面的学习中非常重要，影响深远，所以说各位小伙伴一定要学会。调试也很简单，我们只需要点击右上角的调试选项即可（图标像一个小虫子一样，因为调试的英文名称是Debug）</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/BF28HR7LxsISqjP.png" alt="image-20230730152438291"></p><p>调试开始时，我们可以看到程序在断点位置暂停了：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/lIoGQnrC6LWE7mw.png" alt="image-20230730152411984"></p><p>此时我们可以观察到当前的变量<code>i</code>的值，也可以直接在下方的调试窗口中查看：</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/07/30/34xZXWVPv8qfH9C.png" alt="image-20230730152653140"></p><p>随着循环的进行，i的值也会逐渐自增。</p><p>和之前的<code>if</code>一样，for循环同样支持嵌套使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>)  <span class="hljs-comment">//外层循环执行3次</span><br>        <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>)  <span class="hljs-comment">//内层循环也执行3次</span><br>            println(<span class="hljs-string">&quot;外层<span class="hljs-variable">$i</span>，内层<span class="hljs-variable">$j</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，外层循环会执行3轮，而整个循环体又是一个循环语句，那么也就是说，每一轮循环都会执行里面的整个循环，里面的整个循环会执行3，那么总共就会执行3 x 3次，也就是9次打印语句。</p><p>我们也可以在循环过程中提前终止或是加速循环的进行，这里我们需要认识两个新的关键字：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>) &#123;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>  <span class="hljs-comment">//比如我们希望当i等于1时跳过这一轮，不执行后面的打印</span><br>    println(<span class="hljs-string">&quot;在这么冷的天&quot;</span>)<br>    println(<span class="hljs-string">&quot;当前i的值为：<span class="hljs-variable">$i</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>continue</code>关键字来跳过本轮循环，直接开启下一轮。这里的跳过是指，循环体中，无论后面有没有未执行的代码，一律不执行，比如上面的判断如果成功，那么将执行<code>continue</code>进行跳过，虽然后面还有打印语句，但是不会再去执行了，而是直接结束当前循环，开启下一轮。</p><p>在某些情况下，我们可能希望提前结束循环：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span><span class="hljs-number">.2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> <span class="hljs-comment">//我们希望当i等于1时提前结束</span><br>        println(<span class="hljs-string">&quot;伞兵一号卢本伟准备就绪！&quot;</span>)<br>        println(<span class="hljs-string">&quot;当前i的值为：<span class="hljs-variable">$i</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用<code>break</code>关键字来提前终止整个循环，和上面一样，本轮循环中无论后续还有没有未执行的代码，都不会执行了，而是直接结束整个循环，跳出到循环外部。</p><p>虽然使用break和continue关键字能够更方便的控制循环，但是注意在多重循环嵌套下，它只对离它最近的循环生效（就近原则）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>  <span class="hljs-comment">//当i == j时加速循环</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>, <span class="hljs-variable">$j</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>continue</code>加速的对象并不是外层的for，而是离它最近的内层for循环，<code>break</code>也是同样的规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>        <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">break</span> <span class="hljs-comment">//当i == j时终止循环</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>, <span class="hljs-variable">$j</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，要是我们就是想要终止或者是加速外层循环呢？我们可以为循环语句打上标记：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-symbol">outer@</span> <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;   <span class="hljs-comment">//在循环语句前，添加 标签@ 来进行标记</span><br>        <span class="hljs-symbol">inner@</span> <span class="hljs-keyword">for</span> (j <span class="hljs-keyword">in</span> <span class="hljs-number">1.</span><span class="hljs-number">.3</span>) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">break</span><span class="hljs-symbol">@outer</span>  <span class="hljs-comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span><br>            println(<span class="hljs-string">&quot;<span class="hljs-variable">$i</span>, <span class="hljs-variable">$j</span>&quot;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于for语句的更多用法，我们会在后续的学习中继续认识。</p><h3 id="循环结构（while）"><a href="#循环结构（while）" class="headerlink" title="循环结构（while）"></a>循环结构（while）</h3><p>前面我们介绍了for循环语句，我们接着来看第二种while循环，for循环要求我们给一个可遍历的目标，而while相当于是一个简化版本，它只需要我们填写循环的维持条件即可，比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">while</span>(循环条件) 循环体;<br></code></pre></td></tr></table></figure><p>相比for循环，while循环更多的用在不明确具体的结束时机的情况下，而for循环更多用于明确知道循环的情况，比如我们现在明确要进行循环10次，此时用for循环会更加合适一些，又比如我们现在只知道当<code>i</code>大于10时需要结束循环，但是<code>i</code>在循环多少次之后才不满足循环条件我们并不知道，此时使用while就比较合适了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">100</span> <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//现在唯一知道的是循环条件，只要大于0那么就可以继续除</span><br>        println(i)<br>        i /= <span class="hljs-number">2</span> <span class="hljs-comment">//每次循环都除以2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况就非常适合使用while循环。</p><p>和for循环一样，while也支持使用break和continue来进行循环的控制，以及嵌套使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">100</span><br>    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span><br>        println(i)<br>        i /= <span class="hljs-number">2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们也可以反转循环判断的时机，可以先执行循环内容，然后再做循环条件判断，这里要用到<code>do-while</code>语句：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> <span class="hljs-comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span><br><br>    <span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">//无论满不满足循环条件，先执行循环体里面的内容</span><br>        println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>        i++<br>    &#125; <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">10</span>) <span class="hljs-comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span><br>&#125;<br></code></pre></td></tr></table></figure><p>至此，Kotlin程序设计的基础篇内容就讲解完毕了，下一章我们将学习更多Kotlin特性。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/zh-CN/document/urw2e6gg1lprv65w?segment=2#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D">https://www.itbaima.cn/zh-CN/document/urw2e6gg1lprv65w?segment=2#%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D</a></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>程序设计</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-6.找单独的数【异或运算】</title>
    <link href="/2024/12/21/6.%E6%89%BE%E5%8D%95%E7%8B%AC%E7%9A%84%E6%95%B0%E3%80%90%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E3%80%91/"/>
    <url>/2024/12/21/6.%E6%89%BE%E5%8D%95%E7%8B%AC%E7%9A%84%E6%95%B0%E3%80%90%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="找单独的数【异或运算】"><a href="#找单独的数【异或运算】" class="headerlink" title="找单独的数【异或运算】"></a>找单独的数【异或运算】</h1><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在一个班级中，每位同学都拿到了一张卡片，上面有一个整数。有趣的是，除了一个数字之外，所有的数字都恰好出现了两次。现在需要你帮助班长小C快速找到那个拿了独特数字卡片的同学手上的数字是什么。</p><p>要求：</p><ol><li>设计一个算法，使其时间复杂度为 O(n)，其中 n 是班级的人数。</li><li>尽量减少额外空间的使用，以体现你的算法优化能力。</li></ol><h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><h4 id="样例1："><a href="#样例1：" class="headerlink" title="样例1："></a>样例1：</h4><ul><li>输入：<code>cards = [1, 1, 2, 2, 3, 3, 4, 5, 5]</code></li><li>输出：<code>4</code></li><li>解释：拿到数字 4 的同学是唯一一个没有配对的。</li></ul><h4 id="样例2："><a href="#样例2：" class="headerlink" title="样例2："></a>样例2：</h4><ul><li>输入：<code>cards = [0, 1, 0, 1, 2]</code></li><li>输出：<code>2</code></li><li>解释：数字 2 只出现一次，是独特的卡片。</li></ul><h4 id="样例3："><a href="#样例3：" class="headerlink" title="样例3："></a>样例3：</h4><ul><li>输入：<code>cards = [7, 3, 3, 7, 10]</code></li><li>输出：<code>10</code></li><li>解释：10 是班级中唯一一个不重复的数字卡片。</li></ul><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><ul><li><code>1 ≤ cards.length ≤ 1001</code></li><li><code>0 ≤ cards[i] ≤ 1000</code></li><li>班级人数为奇数</li><li>除了一个数字卡片只出现一次外，其余每个数字卡片都恰好出现两次。</li></ul><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>为了满足题目要求的时间复杂度 O(n) 和尽量减少额外空间的使用，我们可以考虑使用异或运算。</p><h3 id="异或运算的特性"><a href="#异或运算的特性" class="headerlink" title="异或运算的特性"></a>异或运算的特性</h3><ul><li>异或运算（XOR）具有以下特性：<ul><li><code>a ^ a = 0</code> （任何数与自身异或结果为 0）</li><li><code>a ^ 0 = a</code> （任何数与 0 异或结果为自身）</li><li>异或运算满足交换律和结合律，即 <code>a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b</code></li></ul></li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化一个变量 <code>result</code> 为 0。</li><li>遍历数组中的每个元素，将 <code>result</code> 与当前元素进行异或运算。</li><li>最终 <code>result</code> 的值就是那个唯一出现一次的数字。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solution</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; cards)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 遍历数组中的每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> card : cards) &#123;<br>        <span class="hljs-comment">// 将 result 与当前元素进行异或运算</span><br>        result ^= card;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Add your test cases here</span><br>    std::cout &lt;&lt; (<span class="hljs-built_in">solution</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>&#125;) == <span class="hljs-number">4</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; (<span class="hljs-built_in">solution</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;) == <span class="hljs-number">2</span>) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提问的智慧</title>
    <link href="/2024/12/17/howtoask/"/>
    <url>/2024/12/17/howtoask/</url>
    
    <content type="html"><![CDATA[<h1 id="提问的智慧"><a href="#提问的智慧" class="headerlink" title="提问的智慧"></a>提问的智慧</h1><blockquote><p>文章转自<a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">Github</a></p></blockquote><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p><a href="http://www.catb.org/~esr/faqs/smart-questions.html">原文网址</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><p>本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin所翻译版本的最新翻译；</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li><li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li><li><a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">在提问之前</a></li><li><a href="#%E5%BD%93%E4%BD%A0%E6%8F%90%E9%97%AE%E6%97%B6">当你提问时</a><ul><li><a href="#%E6%85%8E%E9%80%89%E6%8F%90%E9%97%AE%E7%9A%84%E8%AE%BA%E5%9D%9B">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#%E7%BD%91%E7%AB%99%E5%92%8C-irc-%E8%AE%BA%E5%9D%9B">网站和 IRC 论坛</a></li><li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%BD%BF%E7%94%A8%E9%A1%B9%E7%9B%AE%E9%82%AE%E4%BB%B6%E5%88%97%E8%A1%A8">第二步，使用项目邮件列表</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%89%E6%84%8F%E4%B9%89%E4%B8%94%E6%8F%8F%E8%BF%B0%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%87%E9%A2%98">使用有意义且描述明确的标题</a></li><li><a href="#%E4%BD%BF%E9%97%AE%E9%A2%98%E5%AE%B9%E6%98%93%E5%9B%9E%E5%A4%8D">使问题容易回复</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%B8%85%E6%99%B0%E3%80%81%E6%AD%A3%E7%A1%AE%E3%80%81%E7%B2%BE%E5%87%86%E4%B8%94%E5%90%88%E4%B9%8E%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AF%AD%E5%8F%A5">使用清晰、正确、精准且合乎语法的语句</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%98%93%E4%BA%8E%E8%AF%BB%E5%8F%96%E4%B8%94%E6%A0%87%E5%87%86%E7%9A%84%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8F%91%E9%80%81%E9%97%AE%E9%A2%98">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#%E7%B2%BE%E7%A1%AE%E5%9C%B0%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A8%80%E4%B9%8B%E6%9C%89%E7%89%A9">精确地描述问题并言之有物</a></li><li><a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a></li><li><a href="#%E5%88%AB%E5%8A%A8%E8%BE%84%E5%A3%B0%E7%A7%B0%E6%89%BE%E5%88%B0-bug">别动辄声称找到 Bug</a></li><li><a href="#%E4%BD%8E%E5%A3%B0%E4%B8%8B%E6%B0%94%E4%B8%8D%E8%83%BD%E4%BB%A3%E6%9B%BF%E4%BD%A0%E7%9A%84%E5%8A%9F%E8%AF%BE">低声下气不能代替你的功课</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6%E8%80%8C%E9%9D%9E%E4%BD%A0%E7%9A%84%E7%8C%9C%E6%B5%8B">描述问题症状而非你的猜测</a></li><li><a href="#%E6%8C%89%E5%8F%91%E7%94%9F%E6%97%B6%E9%97%B4%E5%85%88%E5%90%8E%E5%88%97%E5%87%BA%E9%97%AE%E9%A2%98%E7%97%87%E7%8A%B6">按发生时间先后列出问题症状</a></li><li><a href="#%E6%8F%8F%E8%BF%B0%E7%9B%AE%E6%A0%87%E8%80%8C%E4%B8%8D%E6%98%AF%E8%BF%87%E7%A8%8B">描述目标而不是过程</a></li><li><a href="#%E5%88%AB%E8%A6%81%E6%B1%82%E4%BD%BF%E7%94%A8%E7%A7%81%E4%BA%BA%E7%94%B5%E9%82%AE%E5%9B%9E%E5%A4%8D">别要求使用私人电邮回复</a></li><li><a href="#%E6%B8%85%E6%A5%9A%E6%98%8E%E7%A1%AE%E5%9C%B0%E8%A1%A8%E8%BE%BE%E4%BD%A0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%9C%80%E6%B1%82">清楚明确地表达你的问题以及需求</a></li><li><a href="#%E8%AF%A2%E9%97%AE%E6%9C%89%E5%85%B3%E4%BB%A3%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98%E6%97%B6">询问有关代码的问题时</a></li><li><a href="#%E5%88%AB%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%AE%B6%E5%BA%AD%E4%BD%9C%E4%B8%9A%E7%9A%84%E9%97%AE%E9%A2%98%E8%B4%B4%E4%B8%8A%E6%9D%A5">别把自己家庭作业的问题贴上来</a></li><li><a href="#%E5%8E%BB%E6%8E%89%E6%97%A0%E6%84%8F%E4%B9%89%E7%9A%84%E6%8F%90%E9%97%AE%E5%8F%A5">去掉无意义的提问句</a></li><li><a href="#%E5%8D%B3%E4%BD%BF%E4%BD%A0%E5%BE%88%E6%80%A5%E4%B9%9F%E4%B8%8D%E8%A6%81%E5%9C%A8%E6%A0%87%E9%A2%98%E5%86%99%E7%B4%A7%E6%80%A5">即使你很急也不要在标题写<code>紧急</code></a></li><li><a href="#%E7%A4%BC%E5%A4%9A%E4%BA%BA%E4%B8%8D%E6%80%AA%E8%80%8C%E4%B8%94%E6%9C%89%E6%97%B6%E8%BF%98%E5%BE%88%E6%9C%89%E5%B8%AE%E5%8A%A9">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%90%8E%E5%8A%A0%E4%B8%AA%E7%AE%80%E7%9F%AD%E7%9A%84%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E7%AD%94%E6%A1%88">如何解读答案</a><ul><li><a href="#rtfm-%E5%92%8C-stfw%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93%E4%BD%A0%E5%B7%B2%E5%AE%8C%E5%85%A8%E6%90%9E%E7%A0%B8%E4%BA%86">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E8%BF%98%E6%98%AF%E6%90%9E%E4%B8%8D%E6%87%82">如果还是搞不懂</a></li><li><a href="#%E5%A4%84%E7%90%86%E6%97%A0%E7%A4%BC%E7%9A%84%E5%9B%9E%E5%BA%94">处理无礼的回应</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%89%AE%E6%BC%94%E5%A4%B1%E8%B4%A5%E8%80%85">如何避免扮演失败者</a></li><li><a href="#%E4%B8%8D%E8%AF%A5%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98">不该问的问题</a></li><li><a href="#%E5%A5%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A0%A2%E9%97%AE%E9%A2%98">好问题与蠢问题</a></li><li><a href="#%E5%A6%82%E6%9E%9C%E5%BE%97%E4%B8%8D%E5%88%B0%E5%9B%9E%E7%AD%94">如果得不到回答</a></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E5%9C%B0%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98">如何更好地回答问题</a></li><li><a href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90">相关资源</a></li><li><a href="#%E9%B8%A3%E8%B0%A2">鸣谢</a></li></ul><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。</p><p>如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，你所提技术问题的解答的好坏, 很大程度上取决于你提问的方式与此问题的难度。本指南将教你如何正确地提问以获得你满意的答案。</p><p>现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件<strong>好事</strong>；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（loser）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以把你的建议发送至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><ol><li>尝试在你准备提问的论坛的旧文章中搜索答案。</li><li>尝试上网搜索以找到答案。</li><li>尝试阅读手册以找到答案。</li><li>尝试阅读常见问题文件（FAQ）以找到答案。</li><li>尝试自己检查或试验以找到答案。</li><li>向你身边的强者朋友打听以找到答案。</li><li>如果你是程序开发者，请尝试阅读源代码以找到答案。</li></ol><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h2><h3 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。</p><h3 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h3><p>搜索，<em>然后</em>在 Stack Exchange 问。</p><p>近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库&#x2F;包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。</p><p>Stack Exchange 已经成长到<a href="https://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="网站和-IRC-论坛"><a href="#网站和-IRC-论坛" class="headerlink" title="网站和 IRC 论坛"></a>网站和 IRC 论坛</h3><p>本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="第二步，使用项目邮件列表"><a href="#第二步，使用项目邮件列表" class="headerlink" title="第二步，使用项目邮件列表"></a>第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p></blockquote><blockquote><p>聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。</p></blockquote><blockquote><p>更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="使用清晰、正确、精准且合乎语法的语句"><a href="#使用清晰、正确、精准且合乎语法的语句" class="headerlink" title="使用清晰、正确、精准且合乎语法的语句"></a><a name="使用清晰、正确、精准且合乎语法的语句">使用清晰、正确、精准且合乎语法的语句</a></h3><p>我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email&#x2F;PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请向我发电邮&#x2F;私信；</li><li>我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来。</li><li>如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。</li></ul><h3 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效地报告Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个失败者，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！</p><h3 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="清楚明确地表达你的问题以及需求"><a href="#清楚明确地表达你的问题以及需求" class="headerlink" title="清楚明确地表达你的问题以及需求"></a>清楚明确地表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好地理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h3><p>如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的<strong>用户</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的用户也许仍会给你一些提示。</p><h3 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="https://strcat.de/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛茸茸的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h2><p><a id="rtfm"></a></p><h3 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a>RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM（Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h2><p>在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序&#x2F;设定&#x2F;SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com/">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序&#x2F;设定&#x2F;SQL 语句}没有用</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h2><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你在研究一番后才作出了回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-5.最大子数组和</title>
    <link href="/2024/12/02/5.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/12/02/5.%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><blockquote><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</p><p>输出：6</p></blockquote><p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><blockquote><p>输入：nums &#x3D; [1]</p><p>输出：1</p></blockquote><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><blockquote><p>输入：nums &#x3D; [5,4,-1,7,8]</p><p>输出：23</p></blockquote><h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p><code>1 &lt;= nums.length &lt;= 105</code></p><p><code>-104 &lt;= nums[i] &lt;= 104</code></p><h3 id="📖-文字题解"><a href="#📖-文字题解" class="headerlink" title="📖 文字题解"></a>📖 <a href="https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/">文字题解</a></h3><h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p><strong>思路和算法</strong></p><p>假设 nums 数组的长度是 n，下标从 0 到 n−1。</p><p>我们用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：</p><p>max0≤i≤n−1​{f(i)}</p><p>因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 nums[i] 单独成为一段还是加入 f(i−1) 对应的那一段，这取决于 nums[i] 和 f(i−1)+nums[i] 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：</p><p>f(i)&#x3D;max{f(i−1)+nums[i],nums[i]}</p><p>不难给出一个时间复杂度 O(n)、空间复杂度 O(n) 的实现，即用一个 f 数组来保存 f(i) 的值，用一个循环求出所有 f(i)。考虑到 f(i) 只和 f(i−1) 相关，于是我们可以只用一个变量 pre 来维护对于当前 f(i) 的 f(i−1) 的值是多少，从而让空间复杂度降低到 O(1)，这有点类似「滚动数组」的思想。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>, maxAns = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;x: nums) &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + x, x);<br>            maxAns = <span class="hljs-built_in">max</span>(maxAns, pre);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxAns;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>复杂度</strong></p><ul><li>时间复杂度：O(n)，其中 n 为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。</li><li>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</li></ul><h4 id="方法二：分治"><a href="#方法二：分治" class="headerlink" title="方法二：分治"></a>方法二：分治</h4><p><strong>思路和算法</strong></p><p><strong>这个分治方法类似于「线段树求解最长公共上升子序列问题」的 <code>pushUp</code> 操作。</strong> 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决<strong>多次询问</strong>的「区间最长连续上升序列问题」和「区间最大子段和问题」，还是非常有趣的。</p><p>我们定义一个操作 <code>get(a, l, r)</code> 表示查询 a 序列 [l,r] 区间内的最大子段和，那么最终我们要求的答案就是 <code>get(nums, 0, nums.size() - 1)</code>。如何分治实现这个操作呢？对于一个区间 [l,r]，我们取 m&#x3D;⌊2l+r​⌋，对区间 [l,m] 和 [m+1,r] 分治求解。当递归逐层深入直到区间长度缩小为 1 的时候，递归「开始回升」。这个时候我们考虑如何通过 [l,m] 区间的信息和 [m+1,r] 区间的信息合并成区间 [l,r] 的信息。最关键的两个问题是：</p><ul><li>我们要维护区间的哪些信息呢？</li><li>我们如何合并这些信息呢？</li></ul><p>对于一个区间 [l,r]，我们可以维护四个量：</p><ul><li>lSum 表示 [l,r] 内以 l 为左端点的最大子段和</li><li>rSum 表示 [l,r] 内以 r 为右端点的最大子段和</li><li>mSum 表示 [l,r] 内的最大子段和</li><li>iSum 表示 [l,r] 的区间和</li></ul><p>以下简称 [l,m] 为 [l,r] 的「左子区间」，[m+1,r] 为 [l,r] 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 [l,r] 的信息）？对于长度为 1 的区间 [i,i]，四个量的值都和 nums[i] 相等。对于长度大于 1 的区间：</p><ul><li>首先最好维护的是 iSum，区间 [l,r] 的 iSum 就等于「左子区间」的 iSum 加上「右子区间」的 iSum。</li><li>对于 [l,r] 的 lSum，存在两种可能，它要么等于「左子区间」的 lSum，要么等于「左子区间」的 iSum 加上「右子区间」的 lSum，二者取大。</li><li>对于 [l,r] 的 rSum，同理，它要么等于「右子区间」的 rSum，要么等于「右子区间」的 iSum 加上「左子区间」的 rSum，二者取大。</li><li>当计算好上面的三个量之后，就很好计算 [l,r] 的 mSum 了。我们可以考虑 [l,r] 的 mSum 对应的区间是否跨越 m——它可能不跨越 m，也就是说 [l,r] 的 mSum 可能是「左子区间」的 mSum 和 「右子区间」的 mSum 中的一个；它也可能跨越 m，可能是「左子区间」的 rSum 和 「右子区间」的 lSum 求和。三者取大。</li></ul><p>这样问题就得到了解决。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span> &#123;<br>        <span class="hljs-type">int</span> lSum, rSum, mSum, iSum;<br>    &#125;;<br><br>    <span class="hljs-function">Status <span class="hljs-title">pushUp</span><span class="hljs-params">(Status l, Status r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> iSum = l.iSum + r.iSum;<br>        <span class="hljs-type">int</span> lSum = <span class="hljs-built_in">max</span>(l.lSum, l.iSum + r.lSum);<br>        <span class="hljs-type">int</span> rSum = <span class="hljs-built_in">max</span>(r.rSum, r.iSum + l.rSum);<br>        <span class="hljs-type">int</span> mSum = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(l.mSum, r.mSum), l.rSum + r.lSum);<br>        <span class="hljs-keyword">return</span> (Status) &#123;lSum, rSum, mSum, iSum&#125;;<br>    &#125;;<br><br>    <span class="hljs-function">Status <span class="hljs-title">get</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> (Status) &#123;a[l], a[l], a[l], a[l]&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> m = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        Status lSub = <span class="hljs-built_in">get</span>(a, l, m);<br>        Status rSub = <span class="hljs-built_in">get</span>(a, m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pushUp</span>(lSub, rSub);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>).mSum;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>假设序列 a 的长度为 n。</p><ul><li>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 O(logn)，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 O(∑i&#x3D;1logn​2i−1)&#x3D;O(n)，故渐进时间复杂度为 O(n)。</li><li>空间复杂度：递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。</li></ul><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p><p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 [0,n−1]，还可以用于解决任意的子区间 [l,r] 的问题。如果我们把 [0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-3.n 皇后问题</title>
    <link href="/2024/12/02/3.N%E7%9A%87%E5%90%8E%E3%80%90%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E3%80%91/"/>
    <url>/2024/12/02/3.N%E7%9A%87%E5%90%8E%E3%80%90%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="n-皇后问题"><a href="#n-皇后问题" class="headerlink" title="n 皇后问题"></a>n 皇后问题</h1><blockquote><p><a href="/note/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95.md">回溯算法</a></p></blockquote><p>按照国际象棋的规则，皇后可以攻击与之在同一行、同一列或同一斜线上的棋子。n 皇后问题研究的是如何将 n 个皇后放置在一个 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><strong>要求</strong></p><blockquote><p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个不同的 n 皇后问题的棋子放置方案，其中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p></blockquote><p><strong>示例</strong></p><ul><li><p><strong>示例 1</strong><br><img src="/img.png" alt="img.png"></p><ul><li><p>输入：n &#x3D; 4</p></li><li><p>输出：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[<br>  [&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],<br>  [&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]<br>]<br></code></pre></td></tr></table></figure></li><li><p>解释：<br>如上图所示，4 皇后问题存在两个不同的解法。</p></li></ul></li><li><p><strong>示例 2</strong></p><ul><li>输入：n &#x3D; 1</li><li>输出：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[[&quot;Q&quot;]]<br></code></pre></td></tr></table></figure></li></ul></li></ul><p><strong>提示</strong></p><ul><li>1 &lt;&#x3D; n &lt;&#x3D; 9</li></ul><hr><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-keyword">auto</span> solutions = vector&lt;vector&lt;string&gt;&gt;();<br>        <span class="hljs-keyword">auto</span> queens = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> columns = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals1 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">auto</span> diagonals2 = <span class="hljs-built_in">unordered_set</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-built_in">backtrack</span>(solutions, queens, n, <span class="hljs-number">0</span>, columns, diagonals1, diagonals2);<br>        <span class="hljs-keyword">return</span> solutions;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;solutions, vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> row, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;columns, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals1, unordered_set&lt;<span class="hljs-type">int</span>&gt; &amp;diagonals2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (row == n) &#123;<br>            vector&lt;string&gt; board = <span class="hljs-built_in">generateBoard</span>(queens, n);<br>            solutions.<span class="hljs-built_in">push_back</span>(board);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (columns.<span class="hljs-built_in">find</span>(i) != columns.<span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal1 = row - i;<br>                <span class="hljs-keyword">if</span> (diagonals<span class="hljs-number">1.f</span>ind(diagonal1) != diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> diagonal2 = row + i;<br>                <span class="hljs-keyword">if</span> (diagonals<span class="hljs-number">2.f</span>ind(diagonal2) != diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>()) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                queens[row] = i;<br>                columns.<span class="hljs-built_in">insert</span>(i);<br>                diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(diagonal1);<br>                diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">insert</span>(diagonal2);<br>                <span class="hljs-built_in">backtrack</span>(solutions, queens, n, row + <span class="hljs-number">1</span>, columns, diagonals1, diagonals2);<br>                queens[row] = <span class="hljs-number">-1</span>;<br>                columns.<span class="hljs-built_in">erase</span>(i);<br>                diagonals<span class="hljs-number">1.</span><span class="hljs-built_in">erase</span>(diagonal1);<br>                diagonals<span class="hljs-number">2.</span><span class="hljs-built_in">erase</span>(diagonal2);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateBoard</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;queens, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> board = <span class="hljs-built_in">vector</span>&lt;string&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            string row = <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            row[queens[i]] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            board.<span class="hljs-built_in">push_back</span>(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> board;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure><p>作者：力扣官方题解</p><p>链接：<a href="https://leetcode.cn/problems/n-queens/solutions/398929/nhuang-hou-by-leetcode-solution/">https://leetcode.cn/problems/n-queens/solutions/398929/nhuang-hou-by-leetcode-solution/</a></p><p>来源：力扣（LeetCode）</p><h1 id="关于N皇后2-只用求次数，不用求位置"><a href="#关于N皇后2-只用求次数，不用求位置" class="headerlink" title="关于N皇后2-&gt;只用求次数，不用求位置"></a>关于N皇后2-&gt;只用求次数，不用求位置</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/c++<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 解决n皇后问题的递归函数</span><br><span class="hljs-comment"> * @param x 当前处理的皇后所在的行</span><br><span class="hljs-comment"> * @param y 当前处理的皇后所在的列</span><br><span class="hljs-comment"> * @param n 棋盘的大小</span><br><span class="hljs-comment"> * @param bord 记录了每一行皇后的位置</span><br><span class="hljs-comment"> * @param ans 保存了找到的解的总数</span><br><span class="hljs-comment"> * @return 如果当前皇后的放置导致了问题的解决，则返回1，否则返回0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span>* bord, <span class="hljs-type">int</span>&amp; ans)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 当n为1时，只有一个皇后，只有一种解法</span><br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>    &#123;<br>        ans = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果y大于等于n，说明当前列已经越界，没有解法</span><br>    <span class="hljs-keyword">if</span>(y &gt;= n)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查当前列、正对角线和反对角线是否有皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(bord[i] == y || y - bord[i] == x - i || y - bord[i] == i - x)<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 在当前位置放置皇后</span><br>    bord[x] = y;<br><br>    <span class="hljs-comment">// 如果x等于n-1，说明已经放置了所有皇后，找到了一个解</span><br>    <span class="hljs-keyword">if</span>(x == n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试在下一行放置皇后</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        ans += <span class="hljs-built_in">fun</span>(x + <span class="hljs-number">1</span>, i, n, bord, ans);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果没有找到解，则返回0</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算n皇后问题的总解数</span><br><span class="hljs-comment"> * @param n 棋盘的大小</span><br><span class="hljs-comment"> * @return n皇后问题的总解数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalNQueens</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化解的总数为0</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 分配空间来记录每一行皇后的位置</span><br>    <span class="hljs-type">int</span> *bord = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>    <span class="hljs-comment">// 尝试在第一行的每一列放置皇后</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">fun</span>(<span class="hljs-number">0</span>, i, n, bord, ans);<br>    &#125;<br>    <span class="hljs-comment">// 返回解的总数</span><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-4.使数组为空的最少操作次数</title>
    <link href="/2024/12/01/4.%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/"/>
    <url>/2024/12/01/4.%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%BA%E7%A9%BA%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="4-使数组为空的最少操作次数"><a href="#4-使数组为空的最少操作次数" class="headerlink" title="4.使数组为空的最少操作次数"></a>4.使数组为空的最少操作次数</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个下标从 0 开始的正整数数组 <code>nums</code> 。 你可以对数组执行以下两种操作任意次 ：</p><ul><li>从数组中选择 两个 值 相等 的元素，并将它们从数组中 删除 。</li><li>从数组中选择 三个 值 相等 的元素，并将它们从数组中 删除 。</li><li>请你返回使数组为空的 最少 操作次数，如果无法达成，请返回 -1 。</li></ul><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><blockquote><p>输入：<code>nums = [2,3,3,2,2,4,2,3,4]</code><br>输出：<code>4</code><br>解释：我们可以执行以下操作使数组为空：</p><ul><li>对下标为 0 和 3 的元素执行第一种操作，得到 <code>nums = [3,3,2,4,2,3,4]</code> 。</li><li>对下标为 2 和 4 的元素执行第一种操作，得到 <code>nums = [3,3,4,3,4]</code> 。</li><li>对下标为 0 ，1 和 3 的元素执行第二种操作，得到 <code>nums = [4,4]</code> 。</li><li>对下标为 0 和 1 的元素执行第一种操作，得到 <code>nums = []</code> 。<br>至少需要 4 步操作使数组为空。</li></ul></blockquote><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><blockquote><p>输入：<code>nums = [2,1,2,2,3,3]</code><br>输出：<code>-1</code><br>解释：无法使数组为空。</p></blockquote><p>提示：<br><code>2 &lt;= nums.length &lt;= 105</code><br><code>1 &lt;= nums[i] &lt;= 106</code></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/img_2.png" alt="img_2.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; numMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : nums) &#123;<br>            numMap[n]++;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : numMap) &#123;<br>            <span class="hljs-keyword">if</span> (m.second == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            res += (m.second % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> ? m.second / <span class="hljs-number">3</span> : m.second / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="关于unordered-map"><a href="#关于unordered-map" class="headerlink" title="关于unordered_map"></a>关于unordered_map</h2><p>这段代码使用了 <code>unordered_map</code> 来统计数组 <code>nums</code> 中每个元素出现的次数。具体解释如下：</p><ul><li><code>unordered_map&lt;int, int&gt; cnt;</code>：定义了一个无序映射 <code>cnt</code>，其中键（key）是 <code>int</code> 类型，表示数组中的元素；值（value）也是 <code>int</code> 类型，表示该元素出现的次数。</li><li><code>for (int x : nums)</code>：这是一个范围基于的 for 循环，遍历 <code>nums</code> 数组中的每一个元素，并将当前元素的值赋给变量 <code>x</code>。</li><li><code>cnt[x]++;</code>：对于每个元素 <code>x</code>，在 <code>cnt</code> 映射中对应的值加 1。如果 <code>x</code> 还没有出现在 <code>cnt</code> 中，则 <code>cnt[x]</code> 默认初始化为 0，然后加 1。</li></ul><p>这样，循环结束后，<code>cnt</code> 映射中就存储了 <code>nums</code> 数组中每个元素出现的次数。</p><h2 id="例如：-如果-nums-1-2-3-2-1-，那么执行这段代码后，cnt-映射将会是-1-2-2-2-3-1-，表示数字-1-出现了-2-次，数字-2-出现了-2-次，数字-3-出现了-1-次。"><a href="#例如：-如果-nums-1-2-3-2-1-，那么执行这段代码后，cnt-映射将会是-1-2-2-2-3-1-，表示数字-1-出现了-2-次，数字-2-出现了-2-次，数字-3-出现了-1-次。" class="headerlink" title="例如：- 如果 nums = {1, 2, 3, 2, 1}，那么执行这段代码后，cnt 映射将会是 { {1, 2}, {2, 2}, {3, 1} }，表示数字 1 出现了 2 次，数字 2 出现了 2 次，数字 3 出现了 1 次。"></a>例如：<br>- 如果 <code>nums = &#123;1, 2, 3, 2, 1&#125;</code>，那么执行这段代码后，<code>cnt</code> 映射将会是 <code>&#123; &#123;1, 2&#125;, &#123;2, 2&#125;, &#123;3, 1&#125; &#125;</code>，表示数字 1 出现了 2 次，数字 2 出现了 2 次，数字 3 出现了 1 次。</h2>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-2. 复数乘法</title>
    <link href="/2024/12/01/2.%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95%E3%80%90Lambda%E5%87%BD%E6%95%B0%E3%80%91/"/>
    <url>/2024/12/01/2.%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95%E3%80%90Lambda%E5%87%BD%E6%95%B0%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="2-复数乘法"><a href="#2-复数乘法" class="headerlink" title="2. 复数乘法"></a>2. 复数乘法</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>复数 可以用字符串表示，遵循 “实部+虚部i” 的形式，并满足下述条件：</p><p>实部 是一个整数，取值范围是 [-100, 100]</p><p>虚部 也是一个整数，取值范围是 [-100, 100]</p><p>i^2 &#x3D; -1</p><p>给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。</p></blockquote><p>示例 1：</p><blockquote><p>输入：num1 &#x3D; “1+1i”, num2 &#x3D; “1+1i”</p><p>输出：”0+2i”</p><p>解释：(1 + i) * (1 + i) &#x3D; 1 + i2 + 2 * i &#x3D; 2i ，你需要将它转换为 0+2i 的形式。</p></blockquote><p>示例 2：</p><blockquote><p>输入：num1 &#x3D; “1+-1i”, num2 &#x3D; “1+-1i”</p><p>输出：”0+-2i”</p><p>解释：(1 - i) * (1 - i) &#x3D; 1 + i2 - 2 * i &#x3D; -2i ，你需要将它转换为 0+-2i 的形式。</p></blockquote><p>提示：</p><blockquote><p>num1 和 num2 都是有效的复数表示。</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><h4 id="（substr字符串处理）"><a href="#（substr字符串处理）" class="headerlink" title="（substr字符串处理）"></a>（substr字符串处理）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> add1_pos = num<span class="hljs-number">1.f</span>ind(<span class="hljs-string">&#x27;+&#x27;</span>);<br>        <span class="hljs-type">int</span> add2_pos = num<span class="hljs-number">2.f</span>ind(<span class="hljs-string">&#x27;+&#x27;</span>);<br>        <br>        <span class="hljs-comment">// 修正 substr 参数</span><br>        <span class="hljs-type">int</span> a = <span class="hljs-built_in">stoi</span>(num<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, add1_pos));<br>        <span class="hljs-type">int</span> b = <span class="hljs-built_in">stoi</span>(num<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(add1_pos + <span class="hljs-number">1</span>, num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() - add1_pos - <span class="hljs-number">2</span>)); <span class="hljs-comment">// 减2去掉&#x27;i&#x27;</span><br>        <span class="hljs-type">int</span> c = <span class="hljs-built_in">stoi</span>(num<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, add2_pos));<br>        <span class="hljs-type">int</span> d = <span class="hljs-built_in">stoi</span>(num<span class="hljs-number">2.</span><span class="hljs-built_in">substr</span>(add2_pos + <span class="hljs-number">1</span>, num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>() - add2_pos - <span class="hljs-number">2</span>)); <span class="hljs-comment">// 减2去掉&#x27;i&#x27;</span><br>        <br>        <span class="hljs-type">int</span> real = a * c - b * d;<br>        <span class="hljs-type">int</span> imag = a * d + b * c;<br>        <br>        <span class="hljs-comment">// 直接使用 + 号，因为 to_string 会处理负号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(real) + <span class="hljs-string">&quot;+&quot;</span> + <span class="hljs-built_in">to_string</span>(imag) + <span class="hljs-string">&quot;i&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Lambda函数⭐"><a href="#Lambda函数⭐" class="headerlink" title="(Lambda函数⭐)"></a>(Lambda函数⭐)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">complexNumberMultiply</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;<br>    <span class="hljs-comment">// Lambda函数用于解析复数字符串并返回复数对象</span><br>    <span class="hljs-keyword">auto</span> get = [](string&amp; s)&#123;<br>        stringstream <span class="hljs-built_in">ss</span>(s);<br>        <span class="hljs-type">int</span> i, r; <span class="hljs-type">char</span> c;<br>        ss &gt;&gt; r &gt;&gt; c &gt;&gt; i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span>&lt;<span class="hljs-type">int</span>&gt;(r, i);<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 使用Lambda函数解析输入字符串为复数，并计算两个复数的乘积</span><br>    <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">get</span>(num1) * <span class="hljs-built_in">get</span>(num2);<br>    <br>    <span class="hljs-comment">// 将复数乘积的结果格式化为字符串并返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">to_string</span>(a.<span class="hljs-built_in">real</span>()) + <span class="hljs-string">&#x27;+&#x27;</span> + <span class="hljs-built_in">to_string</span>(a.<span class="hljs-built_in">imag</span>()) + <span class="hljs-string">&#x27;i&#x27;</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好题好代码-1. 最后一个单词的长度</title>
    <link href="/2024/12/01/1.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E3%80%90%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91%E3%80%91/"/>
    <url>/2024/12/01/1.%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E3%80%90%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91%E3%80%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-最后一个单词的长度"><a href="#1-最后一个单词的长度" class="headerlink" title="1. 最后一个单词的长度"></a>1. 最后一个单词的长度</h1><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote><p>给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。</p><p>单词是指仅由字母组成、不包含任何空格字符的最大子字符串。</p></blockquote><p>示例 1：</p><blockquote><p>输入：s &#x3D; “Hello World”</p><p>输出：5</p><p>解释：最后一个单词是“World”，长度为 5。</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “   fly me   to   the moon  “</p><p>输出：4</p><p>解释：最后一个单词是“moon”，长度为 4。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s &#x3D; “luffy is still joyboy”</p><p>输出：6</p><p>解释：最后一个单词是长度为 6 的“joyboy”。</p></blockquote><p>提示：</p><blockquote><p>1 &lt;&#x3D; s.length &lt;&#x3D; 104</p><p>s 仅有英文字母和空格 ‘ ‘ 组成</p><p>s 中至少存在一个单词</p></blockquote><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLastWord</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123; <span class="hljs-comment">// 从后往前遍历！！</span><br>            <span class="hljs-keyword">if</span>(s[i]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                flag=<span class="hljs-number">1</span>;        <span class="hljs-comment">// 记录是否遇到非空字符</span><br>                ret++;         <span class="hljs-comment">// 记录字符个数</span><br>                <span class="hljs-keyword">continue</span>;      <span class="hljs-comment">// 遇到空字符，且遇到过非空字符，则跳出</span><br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>好题好代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makdown的使用方法</title>
    <link href="/2024/11/29/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/"/>
    <url>/2024/11/29/Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="手把手教会你使用-Markdown"><a href="#手把手教会你使用-Markdown" class="headerlink" title="手把手教会你使用 Markdown"></a>手把手教会你使用 Markdown</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown 是一种轻量级标记语言，通俗的说你记笔记写博客的时候不用管排版如何，只要将自己的内容写上去，Markdown 语法就可以给你搞定一切。</p><h2 id="一、Markdown-是什么"><a href="#一、Markdown-是什么" class="headerlink" title="一、Markdown 是什么"></a>一、Markdown 是什么</h2><hr><p><code>Markdown</code> 是一种轻量级标记语言，创始人为约翰 · 格鲁伯（John Gruber）。<br><code>Markdown</code> 允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的 HTML 文档。<br><code>Markdown</code> 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br><code>Markdown</code> 编写的文档后缀为 .md, .markdown。<br>我个人认为<code>Markdown</code>是现在现在是<a href="https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&spm=1001.2101.3001.7020">互联网</a>上最流行的写作语言！！！许多网站平台的文章、博客、论文都是基于它写的！！！</p><blockquote><p>例如：<br>国外的 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge 等；<br>国内的 CSDN、简书、掘金、博客园、知乎等。</p></blockquote><p>推荐一款 <a href="https://so.csdn.net/so/search?q=Markdown%20%E7%BC%96%E8%BE%91%E5%99%A8&spm=1001.2101.3001.7020">Markdown 编辑器</a> <strong>Typora</strong>（下载链接我放到文末）。这款<a href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782?utm_source=glcblog&spm=1001.2101.3001.7020">软件</a>足够轻量级，同时功能做到了尽可能的简单。至于 Web 编辑器必然是最好的 CSDN 哈哈哈。</p><h2 id="二、Markdown-优点"><a href="#二、Markdown-优点" class="headerlink" title="二、Markdown 优点"></a>二、Markdown 优点</h2><hr><p>好多人看到 Markdown 的标签是【轻量级】【标记】【语言】就直接放弃，想着自己学习了非常多的语言，为了记个笔记写个博客还要再学习一门语言吗？实则不然，Markdown 的语言非常非常简单，如果想学，10 分钟你完全可以学完 90% 的常用的语法，而且你从此摆脱排版的折磨，属实是强迫症党的福利了。它的优点不仅限于此：</p><ul><li>纯文本编辑，只要是支持 Markdown 编辑的都能获得同样的结果，摆脱排版苦恼</li><li>学习成本低，常用的语法很少，简单易学快速上手</li><li>支持跨平台同步数据</li><li>支持插入图片、视频等</li><li>随时修改，不必担心 word 等工具出现排版错误</li></ul><p>废话不多说，进入干货阶段</p><h2 id="三、Markdown-的基本语法"><a href="#三、Markdown-的基本语法" class="headerlink" title="三、Markdown 的基本语法"></a>三、Markdown 的基本语法</h2><hr><h3 id="3-1-标题"><a href="#3-1-标题" class="headerlink" title="3.1 标题"></a>3.1 标题</h3><p>使用 #号标记，可以表示 1-6 级标题， 随 #的个数递增，一级标题字号最大，六级标题字号最小。<br>代码如下：</p><figure class="highlight cpp"><figcaption><span>一级标题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure><p>效果如下：<br><img src="data:image/png;base64,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qbvnsuGVAnyIiIiIiIjImZxcAjxj88i5/nK+js/eK6NkV5juTLz+HPIGDcM33I9/mJc0t4krAWgKU7pgGkt3RWDIXObenU1KUiar91UQIcacsJA1i/LwmcCgFWxKXsm8R4sJNgBJWTzy33PxJNA7yW7MJB+3AyWcLWtIGp1ceIZ46HQFacO9sC8E3MWo4Sa+9BXsnBCkbP1qfrGpgroGvjbP3Vn4EhAREREREZEeOLkEeH/4IHOnuvk66jYHKdkV5kze+5axkB4keMhd9gyh6Su44n8W4EsAJi9jWcVEFr7hJXfRUyye6KEr95hCNrySRdGSx3h3yhJyPcTH5cWXAeylU5KbrJnLWDLFzTkluMn6WRHP9Slg/qlxZLqISfaRM+8Zch6OUPfxIT74KETwYDWf8tU+O1zBu0dpMz7Dh4iIiIiIiPTMsFtwEYrUW5yiXZKJ6eKCilgWLtPktPo6wkluPC7i1xTBsk7RJqEPpuniTBHL4lQTbfqYJq4Eeq+pjrp6N243IiIiIiIicoEYdgtEREREREREJC4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4ORERERERERCRuDkREREREREQkbg5EREREREREJG4OvksiQco3BwhH+AZYBDatZvWa1ZRUWYiIiIiIiMh3i5OL0b5iZjy1lT/VpAUbyB/JadbOF1j4eDk87qZg7b8yd+ghSja8SS1fbdiUuWQPoosIoV1FFO2GLM995KXTwiKw6Ze8WUuvDJsyl+xBQE0p8ycvpYKeZS0pInffk7wQ5Px8D7JqUTZuRERERERE5Nvm5GLUVEvwYJA/VWYTnZqCvPR8OW3GzOW+dBfUhKhYW0QFXy3/B3PJHsRXiBDaVUTRbnol/wdzyR5Er1hHgwQPcn7JFiIiIiIiInJh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"></p><blockquote><p>注意：</p><ul><li>最后一个<code>#</code>字符与标题中间留一个空格</li><li>标题应该置于行首，如果放入表格中可能无法正确解析</li></ul></blockquote><h3 id="3-2-字体"><a href="#3-2-字体" class="headerlink" title="3.2 字体"></a>3.2 字体</h3><p>星号与下划线都可以，单是斜体，双是粗体，三是粗斜体</p><table><thead><tr><th align="center">代码</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>*这是斜体*</code></td><td align="center"><em>这是斜体</em></td></tr><tr><td align="center"><code>_这是斜体_</code></td><td align="center"><em>这是斜体</em></td></tr><tr><td align="center"><code>**这是粗体**</code></td><td align="center"><strong>这是粗体</strong></td></tr><tr><td align="center"><code>__这是粗体__</code></td><td align="center"><strong>这是粗体</strong></td></tr><tr><td align="center"><code>***这是粗斜体***</code></td><td align="center"><em><strong>这是粗斜体</strong></em></td></tr><tr><td align="center"><code>___这是粗斜体___</code></td><td align="center"><em><strong>这是粗斜体</strong></em></td></tr></tbody></table><blockquote><p>快捷键：<br>加粗 Ctrl+B<br>斜体 Ctrl+I</p></blockquote><h3 id="3-3-换行"><a href="#3-3-换行" class="headerlink" title="3.3 换行"></a>3.3 换行</h3><p>Markdown 换行的方式有很多种:</p><ul><li>直接在一句话后敲两个空格</li><li>两句话之间加一个空行</li><li>如果你在编辑的时候，想让一行文字在显示的时候换行，就在中间加<code>&lt;br/&gt;</code></li></ul><h3 id="3-4-引用"><a href="#3-4-引用" class="headerlink" title="3.4 引用"></a>3.4 引用</h3><p>Markdown 中引用通过符号 <code>&gt;</code> 来实现。<code>&gt;</code> 符号后的空格，可有可无。<br>在引用的区块内，允许换行存在，换行并不会终止引用的区块。如果要结束引用，需要一行空白行，来结束引用的区块。<br>代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">这是一个引用</span><br></code></pre></td></tr></table></figure><p>效果</p><blockquote><p>这是一个引用<br>此外，引用还可以嵌套使用：<br>代码：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">这是一个引用：</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;这是一个引用的引用</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;这是一个引用的引用的引用</span><br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这是一个引用：</p><blockquote><p>这是一个引用的引用</p><blockquote><p>这是一个引用的引用的引用</p></blockquote></blockquote></blockquote><h3 id="3-5-链接"><a href="#3-5-链接" class="headerlink" title="3.5 链接"></a>3.5 链接</h3><p>Markdown 中插入链接的使用方式是：<br>代码：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[链接名称]</span>(链接地址)<br>&lt;链接地址&gt;<br>即是：<br><span class="hljs-string">[这是小白的主页]</span>(https:<span class="hljs-comment">//blog.csdn.net/qq_40818172?type=lately)</span><br>或者<br>&lt;https:<span class="hljs-comment">//blog.csdn.net/qq_40818172?type=lately&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p><a href="https://blog.csdn.net/qq_40818172?type=lately">这是小白的主页</a><br><a href="https://blog.csdn.net/qq_40818172?type=lately">https://blog.csdn.net/qq_40818172?type&#x3D;lately</a></p></blockquote><h3 id="3-6-图片"><a href="#3-6-图片" class="headerlink" title="3.6 图片"></a>3.6 图片</h3><p>Markdown 中插入图片的使用方式是：<br>代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[图片描述，可写可不写，但是中括号要有]</span>(图片地址，本地链接或者URL地址。)<br>比如我此文章的图片：<br>!<span class="hljs-selector-attr">[卷不动的小白]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//i-blog.csdnimg.cn/blog_migrate/ec1c9a9c57e4d6494b5b36554f7af692.png)</span><br>)<br></code></pre></td></tr></table></figure><p>效果：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfIAAABvCAYAAAAXHkL5AAAgAElEQVR4AezBCWBU9YH48e/vvTfzJjOZSQITCJBwGA4Jh0ZBQdHgUWi1aGUR6CJli9autWw9un/L9r8idl3lvxbZxaMi0vWgJZTiQatClYJSiYBEBMIZzhByQZJJMjNv3vH7M1AwhAABE8R2Ph9R3xCWiqLgdrtQFYWLlW3bhMNRHMehOS7VIUnWI4waQPJ3RyigeUCoSEUnQhKmrdAcRVHwej2oqkpCQkJCwtebqG8IS49HR1UULlaWZdHQEOF0vJqFK1YJdoy/a0KA6gFFI85UA4QtjdPx+ZLQNI2EhISEhK8vhSNUReFiZZoWDQ0RTsevRXFFy8CO8XdPSrAi4JjEuewQfs3gdBoaIpimRUJCQkLC15fCRcw0TcLhCM1RFUlACaFEK0DaJDRiGeCYxCl2AwGtAVWRNCccjmCaJgkJCQkJX08KFynTtAiHozTHpUqS5WGEUQ1SktCUBNsA6RAnbINkUYdLlTQnHI5imhYJCQkJCV8/Chchy7IIhyM0R1cdvFYFxOpJOAMpwTY4wbHwylp01aE54XAEy7JISEhISPh6UbjI2LZNQ0OE5ng0G49ZDlaUi41pxCgp3sunK1Zz0XBskA4nSAePU4NHs2lOQ0ME27ZJSEhISPj60LiIOI4kHI7SHI9moxvl4Jh89QQIjhDYls3ebTt5/3dL2LzmM64YPpQrb7gWpOQYSZwZM9FcGkIILhwJdgw0D43pdi1oKUQtlabC4Sg+nxdFESQkJCQkXPw0LiKRSATHcWhKVx30WDk4Jl8ZRQVFA1QQAoQgLv+/n6Vw5V+INISJy+jeHVxejpISxzJZ+cYSKkpK+c4930X3eLigHBuQgKAx3a5FqqkYtkJjjuMQiUTw+bwkJCQkJFz8NC4SkUgUy7JpyqVKPGYl2CYXlFBAqKBooKiAoLGq0jLm/9f/sGPDJhpLDQYBgZSSTz/4iA9+9wb7d+zilknj0ZPbgbTAsUA6XBgOSAlC0JRHhnDUFExb0Jhl2UQiUZKSPCQkJCQkXNw0LgKxmEksZtKUqki89iGwo1wwQgXVBYoGCJpTXxsif9bz7NiwiaZcbjfRhjB/WvB7li96C9OIIYQgLT0dFBVQQXGDtMAxwbFpc1KC4FTSwSvqqFf82I6gsVjMRFVV3G4XCQkJCQkXL42vmG07RCJRmuMjBGYDF4RQQPOAUDmbd19dwJZ1n9Gcupoa/vc/nmbzmk+RUnKcEIIThADhAsUF0gLLAOnQdiSn5Vj41DAhx0dTkUgUVVVRVYWEhISEhIuTxlcsGo3SHL8aQURraXsKaG4QGgjB2ZTs2MWnf/6I03nv9YXUVdfQVKi6hmYJDTQVHAucGEiHC03YBn5No87SaSoajeLzeUlISEhIuDhpfIUMI4Zl2TTl1UyUSCUgaVOKBqoOQuFsHNshUl/PB797k/raEKdTV11DU1JKPvvoYwLtUsnolkW7jh1ISvbhcrs5SghQXaCoYMfAMWlVQuFsFLsBr6YStjQasywbw4ih624SEhISEi4+or4hLH3eJC4023aor2+gKZfq4I0dBMei7QjQdFBcnI3jOOzauIXNa9axZukH1B6u4csSQqH/kCsZfPNw+l19Je6kJIQQnGCbYBuA5MsT4PKBELREWEnFtBWaSk72oaoKCQkJCQkXF1HfEJY+bxIXWkNDBMuyaCogahCxWtqMEKAmgaJyJrVVh/no7XfYtHotlaVlxKJRpJS0Js3lIpCWSve+vbn+jlvpObA/J0gHrAhIhy9F0UBLoqWkohOyfTSlaRo+XxIJCQkJCRcXUd8Qlj5vEhdSLGYSiURpyqcaaNFyQNImhAqaB4RCc2zLomTnbla/8yfWLV9JNBzhQlFUlV6X9WfIN2+i35BBeJOTQUqwDXBMzo8ALQkUlXNhqX4aLBdNJSV5cLtdJCQkJCRcPER9Q1j6vElcSHV1DTiOQ2MuVeI1SkA6tAmhgMsLCJpTXVHFBwvf4C9/XIppxPgq9b58ALdOvotL+l2KEIBlgGNyzhQVNC/nI6ykYdqCxhRFwe/3kZCQkJBw8RD1DWHp8yZxoRhGjGjUoCm/qEWJ1dAmFA00DyBoyohEKVj6Ae+9uoD6UB3ScfjKCdB1D9kD+3HnlHtJ75wBjgm2QcsJcHlBKJwPR/VQZ3lpyuPR0XU3CQkJCQkXB1HfEJY+bxIXgpSSuroGpJQ05lEt9OgB2oSiguoBodDU7s1bee+1fIrWrkdKycWoQ5fOjJhwJ1d9YzgKNtgGLaJ5QHHxZRhqClFLpTEhBH6/DyEECQkJCQlfPVHfEJY+bxIXgmHEiEYNmgrISoQVptUJAZoXhEJjVsxk0ydrWfjfLxI6XM3FTnO5GHzzcG67ZyJ+fxI4Mc5I1UF182VJxUXI9tOUx6Oj624uVpUlJejtMgl4+ZtnhEIYNuiBALrKuTMMDE1HVzm7sAFena+3EDtXlaAPzCYroJOQ8FWSQG0UdtdCOw9kJIOucs4ULiDDiNGUVzUQVpjWJ0DzglBoLBoOk//fv+LXv/gvQoer+TqwTJPV7/6J/37w3yg7UAGaB4TCqQSoHlDdtAbhmHg1i6YMI8ZXJlTIcw/MYEUlp1HMez++idwBfXjwnRCnMih85l6mLioiZPM1V8VbDwwmd9BgZhZyHkIsfWQgOZdfy13zizmzYl77x4FkD7iWH71RQuurYuHkPmRn9+HuRVW0meIlPDjpDobn3sJzG2kT2xugKkaz1ldJNtXAtjrYXgfb62BbHWyqgXqTZn1aC5vqSfgbE7NhUyVsqoSQAXtqYUM5lDdwzjQuEMOIIaWkKZdZQ5vQdBAKjYUOVfO72S9S+OHHfB2V7SvhpWlPcscP/4n+QwaBdEBKQIIQIDQQgtbkkmEgQGNSSgwjhq67ubCqWPr4vcxcEoIig5fnP8rwdE4WKmb9Ro7IY+gVAZoy1s3iZ8+uZCclpGe/wUO5On+3qlfy1hKO8DB0YDZntLeAtzZyRBZDr8jk66ro3XkUcUTuZG4bQKvbFZYsPiiIOZJHewuOO2TA67sg2SM4nU+qoT4Kd10C7XVOeLdSgiPo35uEvwGWA+UNsDcEps1RYcNCd6lELMHWQ1AZhq4B8OsgODuNCyQWM2nKqxpgRml1qgsUF40dKivnpUf/k5Kdu/k6K99Xwq//42kmP/p/6DsoF0XVaFOOhVezCFsajcViJrru5sIKMnLGGzwZuoWpH8zn7gnw8vxHGZ7OCUZhAW9zxIA8rsjgZCWL+NH357ETneEz5vBQrk5Tle/8nMlzimhr/e99iSdvCULZIu6+9uesoAXynqBg3hjSaR2hVctYyhG5k7ltAGe0f9USCjkidxTDu/H1ZBSw8MUSQGfiA2PIovU9ssnhylQV0+aoegvy94IDeN3gOJyR1w2LS0AA47qC3wWGCT4VbimweGeIRkIbkRJpmshoFGnGwLaRjkOccGkogRSEy82XUWvAliqI2SA5ZkdpLRt2HyItWeeavh1JcmscikBNFDomQ89UEIIz0rgATNPCcRya0swaWp2igKLTWOWBMp77P49SdbCMvwVGJMrcaU9x1yM/4cobrqOtaTIC+GnMcRxM08Ll0rig1EzGznqF4u+MZ27xfO6+L5uliybQk2OKVi8iLmtkLj1pJFTAk5N/zoow9PzBKzw/JpNmhSsp2lhEW+sQ5itWwluvLCNu5KRRZHEmxaz4XSFxIyeNIouLWDhEyKBZtR/M57Uw0Hsyt/cxCFUbtJgeIODljIpCkm66imGB4wjmbpOYiqCpcAxqwpJQVCAEBHRJ+2SBW+Mkr+0GXQVVCgwLgprCngZJd58gofU4NdVYB0txag5jV1ZgV1bi1FbjRKNgWcQJXzLem0bg7jcQ4XJxrhpMOFAH5Q3gSJBAeXWYov3VlFWHiSuvCfPOun1cmpnGJRkBktwqpXVQE4WuAQh6QRU0S+MCME2TpjyqiTCjtDrVA0JwXPm+El75z5lUHSzjb4kZi7HgmeeJNoS59tsjaUvCMfFoNlFLpTHTNHG5NC44by5T5z3B/geKGfvCBHryV0YBb803gEzuzMvhJFo62bnZ6N0nM/dfc9FpXvqopym8iXMQY/3zt3P3vCogk3vm5XP/QDdn5Q1wVPoonlk3ghZRdQJ8GYXM/c7jvMURdgXFRRyhs37OJEa9zMlufZQlP8jlqI3LeHkjR+isnzOJUS9zBqN4/M3J5PLVKPyfwYx5iTPb/gJjhrzAOfnBAop/lssZSVAFGDZH7YxAVhJH2RIO1EBpDdTHOELwBUFcigc6pUCXVBAcs61eoimCOGFBQYVDmU/wt0wAbhV8miBNh3SP4EuTEruyAnN3MXb1YbAsjjP37ia2aQMyHEboHoTXi5KcjOL1gceDU32Y6Po1CI+Oq1sPRFo7WkoCJXWwuwak5CjbkRRsrWBvZYimDNNmw+4qth2o4bp+nUgPeAibsPUQ+OthQDq4FE6h0caklJimRVMuu45Wp7hAqBxXV13L6/81m33bd3ImQgg8ugtVVVAUgeNIpJSYlo1p2kgpaUsuTUVzqaiKgiIEEoltS4yYiW07nE6kvoE/zHudYOcMeucORAhBW3FhEMVLY6ZpIaVECEHbClE4fx5/ruAkPa/VWf/6LNbzV1UFLAxzRDo7l85i5lJOlpHHxLQSfvc/szhZDnc+OIIsjtADBHRarng+z86rIk6f8CgP5QXROQeqTiBNp2VKWPrMIjZzXIjNxRz16YJZzPyI5vUbw0MjMomr3FhEEY0ZVBYVUUkTQ/grg9WLX2A/cQaVRUVUciZDuBjoGTlkp/OlxUqK2FlNi0gpKat3SPeoxEkEO+ugvQZby8CwQDoSo84gGrYwGmLEef1udK+LBuFmZ6XgYAh6d4DSKHhcgpjNUeV1DrKD4G+dBAwbDFty2ICSBkmmT5DuEZwXKTGLd9DwztvEPl0Lhw6BaWIaEaR0cPe+FHfuIFzde6BldEHx+1GSk5G2jVNbg7G2ALv6MFpmV4Su01JVEdgfgpDBUY6E7aU1bC+poT5qcibRmMX7n5WQFUymb1Ya7f06dQZ8Ugqdk6GLH3SVEzTamGmaNKUJiRKro1UJBVSd44xIlN/OnM2eoq00JYRAUxXSgwFyB3Sne9d0knQ3qqqgKAJHgnQcLNvBMm0qDtWya08lO3eVUReOYNsOjiM5V0IIVFXB7VLp0bUD2T06ktmpHW63C5emoigKigJSgu04xGIWZRU1bNi8l117K7AsG8eRNFZXU8uv/+NpfjLzCTp170pbUewompKE5QgaM00Tt9tN24qx44MXeG4lLVTI288W0nKTueHBEWRxjuxiXnvkcQo5wjuKZx7MQ6ctVbL+2ReYy6kK33iBQk7jB3k8NCKTxkb+/BUm9uYUm/Mn8eQ7fGHvIn75qgHkMvXNOYzNpHnrZ5F773zOZv+Ce3msKI+Jk0YxPDtASxglBbw2q5B+j9/HUC8tMvTBl3h5TJAvq/CpPox5iRYr2GsyoqfKcbEYHKwEJIRro+xYW4ppOghFpTHp2Hh8Gr2u6ISq6HxeCqlpYNgcJYGNZSZc4ubvjWFDcUjSYEJ3v+Bc2ZUVNLzzNrHl75Pk8uJK6Ui0vgbLNEi67kZ83/4O7suvQLjcOLU1RD9aiVWyF6uyAruqEvtQFUnXXEfSNdcjvD5awpawuZKjpITacIwPN5dSHzE5HU0RdAy4UBROkLbBJ1tL6dYxlUszUwHB/hCETeifzgkabcw0LZrSRZjWJUB1gxDEOY7DH+a9zsaP1yKl5DhVVejRNZ0hV/Yiq0uQZJ+OEIKzyeiYysCcbkgpCUdiVB0OsXlrCUXbD3C4up6z8Xhc9OyRweX9u9O5YyoBfxKKotASHdNTuKxfN4yYSXlliLWfFVO07QCRiMFx9TW1zPm/T/Dgfz9FoH0abUVXLCzHRWOmaeF2u2lbQW6ftZZv2pyW8fkLjJo8j0pG8OTyJ/hmgHOgE+DcFc2ZwmOFHKEz/PGfMTKNNpbNna+8wnCOK+K1STNYSg73zHqE4WmcpHLlDB6cV0RzsgYOYeggTuFZRSMGhb+dRyGgT7iPiQMC6JxGis7ZFbNiwUpWbFxJcYdcVvw4h7Oyi5g7YRIzS6Bndh5L78vhYqVIqKi3qWpw8LsVTEtihgWagJ0bDlJR0gBCRdXcnEJRMSI2mz8+QGaPAFl9g9TVgJ4s0RRBZdQmEnXQBKdRxeJp1eTTRD8fU8obmF1FM3R+Mb0rvWmsjlWzy6i4uRej+3KSmpXFvEwHHs7zc37qWDW7jE8GZvBwnp9zVRaRxHX3C86FubuY2KdrSXJ58aWkY4RDGNF6kobl4Z/0A7Qel4AQHKWoKElJEI0S27Aeu6oSJTUNd99+qMF0zpWUsGH3IXaU1mDaDmcy5BI/E4d2pKl9h6P8v/dK2FdZR17/znh1jaY02pDjSCzLpinVqqdVCQUUjePW//kjVr75R6SUxAkgo2MaN13Xj0u6d8SjuzgfQgh8Xh2fN52uXYJcM7g3hZv28smnOwnVhWnK5VLpf2lXrru6D8GgH01VOV+620XXLu3pkpHGkCt6snJ1EVu3l2LZDnGVpQf5w69fZ+xP/hnN5aItqDIKuGjMsmwcR6IograkBwLonE4Vb8+fTyWQ9YPJ3N4tgE7bMtbN4MGni4nTRz3NM3cEaXsBeg4bQk+O01lBXDrZg4cwNIOTVJal86UUL+KJl0qAXKZOykOnBbw6p7VxGS9v5IhM7rwxhxZRc5j4yCiem7KEnU/PYuEdcxibwcVJCLr4FMoqDK64VMejgaZI4oZ27YAjwbLBdMByBKYlcSTELIntgGmD5YBpgyNNHAeMWokhYcfBKJe395GqC5oXZPT0IKOBmpXF/LA8hfyxQY4bRhNVpfzyt9CBv6oq5ZezLUZNT6N5dWz63GFNVTXb8/z05mTbF+7g3zdzsn5p5I8NckJVHZ9U6YzK83O+yiISnwvSPYKWsqsPw6FDuFIzsGIR6qvLceVeQfKEf0Lr3gOEwNxQiFl+EOfwIZyqKsy9u1FMG1dyOyzTxDEMEIJzJaWkojaCaTucza7KKJsONKApgsw0HZ+ucJTkqOp6g0jMxqtrNKXRhizLoimXYiHMKK1KdQOCuPJ9Jbz90qs4tk2c7tYYOrg3N18/AEURtBYhBKkpPm64Noerci/hlfyPKC07jONI4pKTk/jHO66he9d0WpOqKnTp1I5/HD2Mou0l/OFPhdTUNBD3ydLlZHTtyg133oYQgtYmHBOX6mDaCo1ZloXb7eKrEnrnKX72gQHePB76p1x02ljJIn70/XnsJC6Xe0YEKC4xyM3UOSe2QShkcE5UnUBApyWilkHc8J5ZnLtKls6ZQSGgT7iPsdm0zOBMMmmOwerFL7CfI3Inc1sOLRYYOZn7s5cws3glj71YwO3ThqBz8VmwA8b3UunUzoWiCBqTgGmDYoOwQXFAqGDZEhSJ6QikLcEGKSSWI7CRIAWOA5emJ+HTTFaU6IzqITm9OjZ97jDu5iAnVJXyy9kWo6Z3pTd/VWmxpqOXh2le/oId5HNEvzTyxwZhSzWzO6bx4sBafriwivyxQb5QR0U5XHVjBg/n+WleHat+28AaYM20HZydzi+md6U3pyppkKR7BC1mWWDZOLZFJFQLGR3xjRmPK7sXKArSsoht24K5bQuRT9cgLAuX0PAnt0MogtChg2BZtDZVEbT3aeguBcN0KAuZPLu8lJH908jukARCICU4nJ1GG7Isi6bc0qBVCQUUlTjLNPnd7DkcrqgkzuVSGXPbEPr26oyiCNqKz+th8nfzeHvZejZs2kt6MMCEf7iW9PYB2lJO70zap/nJf2s1ZeU12LbN0t8s5MqbrielfRptwS1sTBQasywLt9tFm1g3g+xx82iR8EoevLYPD3J+7snfxtRBnFm4kCcn/5wVYcCbTc92hTw3ZRKbZ/yFl8fogMH+4jqysoOcVeEscsfN45zkPUHBvDGkc3ZVewo4f+mMfPwdXs9aRGhCHnqoiKJQDjmZnB+jkKWLDOKGjx9JFudAzWHilBHMfGAZxquzWHjXAiZmc1HZUyfRcOgSdBNX32CxZXs9peUmQgiEUHEQSKGgC4OI4yFJjeHVTOpjgnrLi7RtLKlimja2Y4KUeHwaKR19SFXhsKHiqTaIdnXjUWleVR2fVOmM6svJghod+ML2jQZXdUzjdMaN78XovvxVHaveN5ny3SCpQZ0ps8tYvCXI6L78lUFFFfTo4Od0alZWMBsfL07vTCqNbNnHuPc1XpzSmVRaxrChMipJ9whaSkqHcOgQtgr+0WNx978MNI04p+wg5q5iIgWrIGrgb98Zjz8NRdWIRRsQtC5VEVzdw893ctuTkqRxXG3YYs2eOm64NBVVEeypipDud9MSGm3IsmyaUp0wrUrVAYGUkvUrVrH9s43EpQS8/MO3r+KSbh1RFEFb83jcjBpxBW5NZVBuNuntA1wIHdNT+N6d17FoySfs2ltBQ6iO3zw9m+//+0/xeL20NlXGABeNWZZNm1HTyRmQQ7PCJRQVh4jTM3LITqdZsZIidlYD3iA52R04nXSVMwsX8dz3JzG3mCOyuefXs8l+/hamlnBC6J2fM3LKEvRhD/D8jPsYmsHpqenkDMihscriIirDoGfkkJ3OqToFOMEIYdCG9EyG/vgBjKJ5jBk3g8JOk1n05iPkejmVxRmFls3ntTBHjOD2m4Kcq8At9/HQ08uYWVLIk6+sZOzjeehcPD4vt8kMasSF6kxmz92FZQkU1YWiqKiqQrJuclduOd+6eTDf/eVh7v1mgBGXuZn5v6s5UJbGS//Slade38K6gxlYloPj2EjbQmyp5NKhXVE9GqUNKrsqbXIyVJqzfXkD3JhBbxqptFjT0cvDHFdHRbnC1Tf6OaqqlF/ObmANsGZaGUct2EE+RwR9/GJghE8GJtFjdjGrpmQzbIrB4mk7WDy+F6P7AlUxdqNwdTrNqyrl5eUwZUpnUmkd1Qake2gxy4hgGVGS77gTzzXXgaoSXbWSyPvvEd2wHtkQxuNJJjmzGy49CSEU2sr4welc0zOAIgQ7yiOUhWJ0SnFzSXoS38hJI27D/nry11byyLeyaAmNNmLbNlJKGlOERJhhWo1QQNGIqzpwkDdemIdj23h0F7d/cxA9e2RwrqSUCCE4H0keN9+5ZTAXWmqKj3F3XMOvf7OCsooaitZ+ymcrP+bqb96EEILWJBwDRfhwJCdIKbFtG1VVaXW5k1ny5mROYZew8L5bmFoMePN46vdzuC2D5pUs4u5v/ZwV4RSu+dkrTB0S4JyFi3ntgfHMXGcAOsNnzGHqIA8LaayK9QXFxIVWzeKubyxj7LQnmHpHDgGVU+VOZsmbkznBLuTJy8czl0zu/9Ub3D+AM6uuZD9xmXRIo83o3XO5shMUFs9jwlNDKHw8D52TVZYUc3olvPXKMuL0701gZBrnTs1h4k9HMPOBZRjzZzB3fB7353BaRriCULWbL6vWoEUUlwCHo367aC+mYaOoLjTFZnS/g3z75ssIprhwubpzoLQCSyST6a0COrOpOoNegRKSvJcy/d4rqQmF+XxbJf/zhwZqHA+OLdn1WSm9hnQlLmpJmlVVypLNsGZzGeOWlwEKU6Zk07/C5GQGFVUu+gc5JtiZh6fTrJqVxfywPIX8sUHoV8ovZxfDlGxGT4fF04pZNSWbYZUWa3BYM3sHs/mrfmnkjw0St315Az3G96L/5mLGLXc4lcEPp+3gJEEfL07pTCrNa7AkIGgpKR3cl/TCc+31xNX8x78T+eQvCMshyZ9GcpfeqC4dIQRtaVC3ZK7vnUJNxOL366oor4uRlaazdk8d6ckuxgxKJ8mlULi/nrDpYJgOkZiDlJyRRhuxLJum3CJGq1I04qSUfLTkPepqaom7bmhfLu3VmZaIxkzWbtnLZ9v3U344hGnZ+L06fbplcH1uLzqmBWhrNfVhVm/cxaZdpRwKNSCAdgEfAy7pzNX9s0nzJ3E2fp+HUSOv4NX8DzFiFu8vWEz/a64iOSVAa3OrNlFLpTHLslFVlQsiXMxrD9zBYx8Y4M3jyT/M4bYMTi9zDM//upjbxs1j7oTxhGbN4clRmbRYuIjnvj+emesMQGf4E+/w8phMoIqTBRn++BsUjF/Ekw/8nIXFRSx85A7eemUMj/3yUcb21jkTY/USXgsDuZO5bQBnd7CE1RzhDZCic07mjuvDXFrIm8vUFx7l0xGPUzh/Cj8a+A4vj8mkpYxV83iykCMyuX/0EHTOT2DEZO7JXMbckmKem7OMibNGEKB5q6ffQe50LhjNpYDBUdU1JghBhq+Blx7uRZI3m9LScn6/0mBdsc2u2lSEUOmc7uPQocNUW505FOvAvbN2k3uJznev83L94G4MvdxkwhNbOBTRMRpiHCc0lVPVseq3DawBxo3vxei+VSyeVssJm6sZN62axvKn7YCgjxendKZi4Q6WdMzg4X51/HK5m4fHBqlZWczLdCB/rJ+jgp15eDp/FWT09CBxNZtNQGHKlGyGBTmijlWzyxi3EPLHBuk9the9gZoKoF8a+WODnLBlH+Pe13hxSmdSabmYTctJidA0kq4bjiu7J6GXXiD6ycekpHTEGwgiFJVjJEjJSaREIsGxwXFAUfgyhmYHcKQkf00lMcvhgZszSXIrVNWZPPrWHmK25PvXZnBF12QKiuv4r2Ul2A5YjuRMNNqIbTs0pckYrUeA6iZuz5btfPzHpcT17Z3JNYN6cSa19RE+2rCTFeu3sWN/BYZp0dSqz4v53z+upmO7AFfldOcbV/Ulu0s6raWyup4PP9vOn9ZupaTiMJbt0NQH67aiLlpB147tGDrgEm4c1IfM9DROp3tWOt+86TKWLF1P2f4S/rzoTUbd/T1am4YNqDRm2w4XxN4lTP3BT1lYDHhzeeg3sxnbjbPSBz3C3KdLuB8BLWYAACAASURBVO2ny1j4wE2sX/UEz/xsDDlpnFnlSh6bcC+vFXOEzvBpb/D8+EzOJJAzhiffHc5t//Nj7n62EKNoEVO/tYy3H5zNM/cNIV2lGQarl83HAEZOGkUWjdiAyikq9xRhcMTgTDJpY9kTeGbGSkY+spIVj9zLk93fYOognbMLsTR/PgZH5N3H2AGcPz2Xu+7NZe6jhRhLZvHavSO4P4dm6Rk5ZKfzpcVKithZzTkTQpDk0YhEDZK8XlICybiVBjRVw5ZuMtx7SU3tzcbtZSC8ZAeq6NfVzY39JKlpqTiOw849FdSbOi1SVccn6IwLGjSVmpdNfh6nqFlZzA8/5yzqWDytjHxOddWNGTyc5yc1L5v8PBrxM+zmamYvqGVVVZBhQb4yTl0Iu6wU96X9cF8xiOhHKzDWFeD3B/EGgghF5RhJpL6GWDhEY7YVwzYNIh8uR3iS8AwdhuIPcL66tfcQNhyKKyP868hMktwKmw80sLo4hCOhqDRM1LTp1t6DBEIRm5bQaCO2bdOU4kRpNYoGCOJW/P5touEILk3l5uv6oesumiMlbNhZwstLVrGzpBIpJWdiOw6lVTW8+eFnrCzczrevHch38i7H53FzvmzbYfWmXbz6XgH7yw8jJWdkOw67D1ax+2AVH6zdwj+OvJobr+yDS1NpSgjB5f178FHBNg5X17Pug4/4xvgxeHxeWpMiTcBNY7Zt06bsEEVvzODBRxaxkyOys+lZXMjM7wxkJi2Xc9MIWL2MokU/Z9SiGeROeICHJ41iaHaApkKFLzD5e7MoDHNEgJEz3uD5MZm0iBpk6IMLKBg5n59973GWVodY/cwkhrw9hidnPcLYnAAnqV7GwvmAdwITRwSICxUtYuajM9h0xxssmpBJUyXbCojTB2STTlMhKso4qmf3IE3dk7+NqYM4ReFTfRjzEs3KuuNRHlt2C1M/KGbuw7MY/u4jDPVyst7ZpNNI0Xyee4cjdCZOHkU6X07WHfcx8al7eS1czHNzljFx1ggCnGrogy/x8pggX1bhU30Y8xJnZcUcQCUuLdXFwfIYuw/pfHdmNaP7beP2EQO5Pa8bd9ygcPuMei7rWENcSX0aHhFhxg+yUBWoro2wbNVO/nd5PZVGKlK6ABO3181x0rIBjZMEO/PwlDpWzS6jgi+h0mLN5gYWbwlyI3F+Rk/vzGga2bKPcQtgVJ6f00rXuAqTtuJWaRGrZD/G55/h6tsPobkJr/gALWzg6dARoaicICEWDlFffxgtM5MveFFIJba1CMUfwD3wchR/gPPl0xVCERu/RyXd72bD/np+tfIgjuSohpiN7UCyrnIuNNqAlBLHcWhK2FG+FMdGmjGkdEDVwbKpPlTL5k8+Ja7XJR3plJFGc6SULF5RyK//+DGW7XCcS1VJ8SVxSUY7Oqb6CXg9VIUaKKmqpeRQDaFwBCmhui7Ma+8V8PHGnUybPIoO7fycq4hhMvftVbyzehNSSo7z6i46pPrp1qEdHQI+JFBRU8fOskMcrmsgGrOIK6+u45kF71O4bR8PT/gGLlWlKd2tMfrWwcz7zUoOl1fw7iu/5fbJ40E6IAFFQdHcoLk4X0KaNOU4DlJKhBC0tsp185k5fQYLiwziArc8yvwnsnkrdxI70UnPySZd5cwqiykqM+gwYhovPzGB5346hZmrQhTOf5y75j8OadncNm0Oz4zKBDtE4bwpTH6qgBBHeHO459mXmJoX5FwFcibw/IdDWDh9ClMXFUPxIqaOWsLCH8/hhX8ZQrrKUfvfmc9SIPdnkxmqc1TArmRFYYj9lUsoGn8fOSqNFLOpwCBuZJ9sThWjNkTrUjMZ+/gTLF39U1aUzOPuJ4ZQ8EQeAU4nxNI5L7CTI7LvY+xQnS/Nm8fYH2by2jMlGEtm8dq9I7g/h6+caUrQOOq7Y7oxe+4uLEviSIXFRV14a1s1WYE6fjjcAC7h+qv7EFe0ZRceLZ3PN2zkVyuTKI+kYVp+pOMFYuA4KKpCdm5njtM1QYtt3se45QanCPr4xUCgo5tUoII4g1Xvm0wZ7+OTBfvYdCPHbNnHuAXwi+ld6b1lH+MWwC+md6U3x2xfuIN/J438sUFOqLRYg4tRwSoWT6smn+OqGTetmpMZ/HDaDk7RL438sUGa49MEZyNjMcxdO3Dq63D36Utsw3rsXcUEAkFUzU1z1IyOtPvF48QpXg+K309czcxZyKjFl9Vg2GiqoMFwWLr5MB9ur8WRnOBzq6gK1Bs250KjDTiOQ1OasEE6nCtpxrCqDmJWV+CE65GWCY4NQmBLWPLuOoxIhCSPm28Mv4zmWLbDb/+0loUfrMOyHeJ0l8ZVvbtyeY9M2iV7cbtUGpMSwkaMqlA9H27exY7SSmzHofhAFf/56rtM/d436dguQEuZls0Li1fyp7VFSMlRHVL95PXPpnuHdviTdFRFobGbHYfahijbDlSwqmgXNQ0R4j78bAfRmMlD//gNAl4PTWV1CZLZqR37DlSx7v0/c3V3D36fm6OEgtBcKJ5k1HYdcXXshpKUzDmRDpoisRxBY47joKoqrceg6KVJjHqqkKO8OYyd9jSPjclGp5C3iBvCQy/NYWwGZ1T0wk2MeroEVCB9CPe/spaxq+bxnzNm8XaRAQMn89AtmVBWwMyf3Mtz6wyOyh7DMy89wW3dOH/ebMbOeIehw37Oj/5tEUVhgzpDJ6ByjFHI63MKgRF875ZMThgwirtzZ/FY4SyefWcCz48KcMLeAt7ayBF5DL0iwAWTMYqnHl/GfetG8MzjeQQ4JmoZnKJoPjOXGMSNnDKBHJVWkTNqMrnPPE4hxTy3YCX3PJ6Hzlfr8gyVX22wuLSLhi/ZxX13Z1O0tZ6DFRYIjhDYIsDLRYKsTHh2lQvxlzCO7IYrFZ77LBtSJAGfgyMdbNtB2hpJfhf+Dl5Ut0qc3+WQHXTRYv26kp9Hs7Yv3EFja5ZXw40ZPNzXT4d+O/j35XDVjUDfrrx4YzE/nLYDUJgyJZvefKH3AB0W1LKqKsiwIEdUsXiBwVU3ZtAbP72nBxnNaWzZx7j3NV6c0plUWi5N56ycuhDm9m2owXQU3UNk02e4pcDt8SGEoDnOocOEXvoVcXpuf3y33sQxMUDhy9p7yCCns5ceQQ+L1x+iqUszkkhyqeysqOdcaLQBx3FoShMW50JaJtbhcoz9O3Ei9SAlTdXU1FO0cRdSSjpnpJHe3k9TjiNZ/uk2Fr6/DtO2EQI6t0vhtqv607l9CooQWLaDYVogQFMUVEVBCPB53Pg87RjXLoWNe0p599MtRGIm2/aVMyt/Of/3n76FL0nnbGzH4dd//Jjln25FSlAVweBeXRk+oCf+JA+NWY6DbTvEqapCO7+XIZd259LMDixdv5XN+8twHMknRXtYsGwtk24diu7SaMylqfTu2Yn9pVWEauvYtXM/A/t15ThpGjiReqzqcmIl29Gz+uDK6I7QvbSUpjhYjkpjjuOgqiqtRydn8tM8ufYOXkt/hBmPjCEnwHkxakuI65kV5Lj0YZN5ZthkphcXUKwPIathJVO/cS8LwxwVuOVRfjdjAj29tIqsUU+wZPAInny0kG/+Sy46x4SWzWNuCWT9YDIj02gkk9snjeCxwmUsfWUJ+0dNIItj9q9aQiFH5I3ghgwuqPTbZrPoDk5StaeAk1Wx8OlZ7OSIzAf48S0BWk23MTz8vRnc9aqBMf8FFt6dx8RufKV6+AUNtsrugzE6BV14PBoDBqRwqSOwbDBtiWVJTEdgOmDZYFkOlgMxW2LZYNpg2WDaEltyMilxCUkw1Y1Hk5xJ/oId5BOnMIXTqaOiHK4aqNPYmuVljFteRlOpednk9yvll7Mb+GRzHcPy/JzQtyv54/cxbvYOZnPMVTdm8HCen7agq5DuEZyN0DSEz4dTW0N4xQeYO7bj9ySjaC5OIcCdlIzjOMj1W4hF6lG8Am4dxDExwMM5EyAEJ/ylOET/Lj7GDU5HUwVr99QhJSgCBvfw8w9XBBECPt5ZR3MUQbM02oDjSJpSsWgpaUaJbFmPVXuIM9m1p4KIYRDXs0cGiqLQ1I6SCl5880NM2yaue4d2TLrxKlyaSsQw2Xqggi0lZRwKhdEUhc7tU+iXlUH3jmloqkqcW1O5smcW6al+frNiHXURg8927GfRn9fzvW8NQQjBmWwsLuWPH2/Csh1UReGGgb0YPqAngi8YpsWO0iq27C+jvLYOgaBjqp+crI707BwkLdnL+Ouv4A9rNlOwfS9SSt748DO6dEjl1msG0FSvHhl8VLAVwzBZtWYbA3K6IgRNSKQRIbrzM2IlO0m67HrU5FRaQsUBVBpzHEmrUzMZ+8Jaxqq0mGGArvOFUAHvvcsROWSmcYpA9hByicvjsWcn8NaPC7n9P2fz5KhMWl1GHlPn5HFCuIDnnl4G5HL3d3PROVlgxAQmepfxWuE83t44gfsHAHYRb88pJG7kHSNIpzn7KVnLEUPIzqB1qZyWrnOUse51Zq7kqJE/nUCOSivSGTr6PrJenUVFRoDQ4RB0C/BV++cB8OwGNxW7Y3Rpr6EKiYOCZTsYpsS0wXTAssG2JaYDlgOmLbFssGywHInjgFAEcVJKVEXgFjbt2yXxrR4OZzNufC9G961i8bRaTlbHqtllzK7ir3R+kecnrvfYXuRzspqVxbxMI8HOPDy9isXTKljVz8+wIF/o25X86VwQmT5BSyjJfpKG5eEcPkRs+1aIRLB0BSMcQigKTSmaG29KEMcysS0TMIFajjGxa6KY27ZgV1aiBtPRMjqBEJyJIgRD+nTkk+3lVNVGWb+3nj9vreH63ilMvjaDETlplNXG6JTqpkuajuNIPthSTeH+ehrTXSr9urYjLVmnORptwHEcmhLSoiWc+hDh7YU4DSHOZvW6HUgJLpdKl07taM5vlq2hIWIQ197v5barB+DSVPZVVvP2J5uoqK3HdhyOKzlUQ+GuEnp2CnLHkAH4PDrHZbVP5dbB/fj9xxswLZvfLf+U6y7vxSWdg5xOfdjgv+YvxYiZCOCyHp25LucSBF+oqK3nzYKNHDhUg2U7HFd6uJaNe0vJCqbyD9deTpoviZsu700oEmXzvjKklLyxspCRV+WgaSqNdeqYit/nwTBMDhw8THllDRkdUjkdJ1pP5LM/4+kzGC09k7MRODTlOA5tQuWcrH+6D3fNA7xBcjrFKCoOcVTuGIZnc0zhLIY8UcI9Ux5gYl4mOsfoeY9Q8BedQIC2FyrkuR/cy9wSSJ8wmeGBEJXFxew8aEB1Mat3VkJ1Ee8RV8Jziwu4Z8AQjHdeYGYJ4J3AxBEBTscIc4QOGhfM0Kws4vRBD1DwlyE893QRN9wSoNUNuJPn80eRnZuJrnJR6N9OoAgwXW72hUDXoEsKqJpKQUEFO3Y2IKVAURSEotKYdGyOsbhsYBqDBqUhJRyohZjNUYqANJ0z8DNsip9jgoyeHuRkfoZN8TOMlknNy+ZhmgoyenqQVtO3K/l9abGMJEG6R9Aiqoq7Tw7q3R0xi7cTXVOA8elajENlYNkImielg2UaaMRAhhDExTCLd1E3/38RbjdJN44g+fYxoKo0RxHQLgkOR8Cf5GL4gC6UV0f4bHclv/u0ir2Hotw6sD1Z7XSy2unEVdTF+OOGw6zZU89xQkDvzqn06ZJKcpKLOE2BdC8n0WgDjiNpSkiLs5HRMJEdG3AaQpxNWUUNB8urifPobjqmp9DU1r1lfL7zAHGKENw6uD8dUpLZVXaI3374KVm9LmX8T8YRCTcw/1fPUxeq5ShHsnV/Oa9FDCbeMBifx02cEDCgWyf2lB+iYNteLNvhvdWb+OfReShC0JxPinZzqLaBuI5pAb49uB+aqnBcZW09r/95HWmZ3fjJlH+lrraGBXNfJFRTQ5yQUFYV4uVlq/nejYPpkOLn24P7UXywiqhpcbAqxBsrP2PMjVcghOA4TVPp0qkdVYfrkFKydXspGR1SORPHiBDZugavqqG2y+BMBDZNOY7kYtCzTx6wEsJVFBVzVGDYAzz/9ASyOKZyTxGVhSt5ctUY7snL5As6gQAXRnURf15nEFc5fwrD53NGxqvzWfpPBuv/bRlxPX80hqE658WoDRGq5hS1Buehih3bOVXGEO5/eghtI0jOIC46T14DD64ECVg27KuG7u3hhhs60K+fwXvvHiRi2ODYNJWWqnHzTZm0b+9GSth9GAyLoxQBd17q8PcsI0nQ3S84J6qKmt4BNZiO65JemFdfg119GCyLkzg2kQ+XY+7ejH/iVcS5stoBtYDAe/MluPukAJLQa+uwy0oByekIYEA6lNbD/hBELUGX9l46pGSxYc8h1u+vo2B3HQGPhq4JDEsSilpIyVGKEKT63FzZswPpKR7iVAVSdOjdDnSVk2i0ASklTQlpc0ZSEtm5Ebu+hpbYubuM45KS3CT7dBqzbYd3Vm8iasSIa+f3kp3RHsO0WPzxBsKGyX2P/JyrrrseKSUVZQdZ/P/Zgxf4tu7C4Pu//zlHOpJsy5dYspU4SXNx0jpuWjVter9RsINZGyipzQYUiih2hwd72d5njJhMy+Ns8G6DD+Bn2GMmMC6rTZ8xM+rFgVK6hkuatqapk5Krm8SJYjvx3ZIlHZ3/GyV1oyi+5toWfb//9h3iNEUh3WKh68QAbS+/xgduX4kQgnG3LlvI7zqPMRaJ8sJrh3i4f5j8HCfJIobBL1/ey7ibl85Ht2iMM2ImTc+3c3J4lC/8ry9w+/3vIm6wv4+mxm8RZ5gmeWlp9IaCtL74Go++6xacDht3Fi3iFzv3ETNNfvHyHsruKCbNrpPI7XIy7uDhbu6V1yGEYCoyMkZoz4ukrS5FqBYmI6RJMiklbwWudf/CgXUQHhoijI7TqXOuMLvanyPuIW8RV83CB3m0bCPtrU6WXl+ANXMJd9xYgO5ewu0LXZBZwIoCJ+i9tDz+KL+8/jZ6vrGR7wUBx4f5648VMakDu/k1cQW4sznP9z51C9/jEgnvZ/cOTnM6rFyYQcJ9XDIHtv4zXzni5GIdeZFZybTCwkw4MMBpoxHoPAmLcmCeR+exjy3k5MkIA0MGg4MR4ubk6DgzNHJyLAhFMBaF1/tgLMqbFmVJ7Bp/kHQVCtIELpvgggmB6s5DdecxoZiB0XWY6KFdKA6FuNjJAUK/HGCccCicpjBjc9Nhjh2OjcCRIbBoCquWuiicm8nOzpMcOTFCMk1VWLXUzQJXGhZVIc5hgcJsyLSB4Hwal4GUkmTCjDGV6MkAxuAJpmIaJrGgQXQwwp7XjjEuI82GEIJEI2MRXt5zGAkIAaU3XYumKrzy+jH6R0PE2R0O4oQQpKWnMy5kGHgcaZhS8vLBo9xTvJRcZxrj5jjTWLEgn5f2H6G7b4hdB4+Sn+Mk2ZHufl47FCDOoVtZsSCfRF0nBwj0DxGXlpHBOLs9jXESGIsZzE/P4GDgBIe6+1iUP4fVhQvZse8IQ8ExjvYO0N0/zGK7TiJnhoNxx48PcGRXD/meLLQMC4pVYTJmaJjI/lfQl60CIZiIwCSZlJIrR8dZAHT9lt27hiDfSTLd6UTnfEOvPsX3fswp93L7TU6uHicPfWMPD32DaTj56A9+xX1PfYrSb3UBOg99+c+5z8FpQwd+y64AkFnAigIng13P8aPaL7ObU+4tYoXOeZxLiihwcJ5I127293OecFc7L/e7WFHgBHSc2Tpx4d7dtPzjRr4X5BQvN61wMrUwR9p3E/Yswa3zhghdbd+k8VUumSPP/ID/8wxXxd+shr97EXad4LThMdgVAHe6xJUh8OTpePJ0II1EI2E4MQo9wyA5a1GWpGSh5A+FAKwqpGmCbB1cNsGVYvYFGfzX7UzF7AsyG7oKizJhjh1eH4CBMch0WLmryMPrPcO8dqSfgdEwFk2hIDedmxbnoltU4nQV8tNhoROEYFIal4GUkvPIGJORkTDhQ3vBNJmQhODRUUJdo0RHooSiUU6cHGKcbtVI1jc0ytBIiLh0m8783CziXu8+ybhvf/2rPPKxTxAcHWXLf/xfEplSMsdmZzASIdA3RK4zjXGqorBsnpuXD3QhpWTv4R4euPk6kh063sdIMEzcEs8cHDYriTqPn2Tct77yD/zJp55gaKCf//6PH5FISkmaZkFTFA719rMofw5pNp38rAyGgmMYRozjJ4dYPDeXRFaLxrjgWIRDu45jDRiodg17vp20RRkIVXAeKYkEOtHmLUFNz2ZC0iSZlJIrp4j7P7SEr/zjAb73qVv4XvYSigp0pham69UDDHHG0sefYG0+bwtHfvxnPPRXzxEGlj7+Xb5U5mSc3rWVj3ziB5xP56F1Jbg4X/nf/Zi/vpnztH9pOeu+xXn03ufwrfsmYSanf/gJyhcyDZ0TbR9i3beYhJf7bsnlYhV94h/5wr0uLtaupo/x963M2hduhr/ZDntOcloM6BoUdA2CTQOnTZJhE0gJw2HJQEgQjXEOIeCWfMnnvAIQpFxGikp6xUdxlP4RM6FkZYOiMhtOKxS7YCAMvz8J0Rgsystg3pw0DvUOMyfDRlaaFUUI4lwOWJwNNpVpaVwGUkrOJ5lMbLgfMzjMRGRMMtI5TPDQCNKUxPWHQoSiUcZJKUnWPxwkZkri0nQrdt1K3GBwjDhFCLY/9ywv/+ZXmLEYsViMRBZFwaqoqELQPxokWX6OE0VATMKuzmM88+LvSfabjoOMy8/JRFMUEvWNBImzKAov/3obO198gZhhYJomidIsFhRAUxQGgyHihIC87Az2HuvFlJLuviGSSSkZZ0rJseFBlmbPIRYyGHl9mOhIlMyibBSrQjIZixLrPYqans2EpCSZlJIrqehT/8b3Y3+L/ztb2d9/gN39zIie76X043/OFz7hRedtIhYmDOg3/zlf/YwXnbP0a4q43QG/CfIm55ISPrnhb/j0XU4uCU8BtwO/ZAKOXO6r/Ce+9MRt6EyvYOm9wHOcx1FE+Zf/kY8u5KK5l9/O7XflcrFs27hgf3srDISh+hcQjvGm0QiMRgSBId4gSGbToO5+yNQFKVeAEKhzclHn5HI5KQJybHBzPhwegu5RQFMo9GQSJ4AMHeY7IdfOjGlcKdJkMkZfN5MJ94QY7RxmnAS6R4eJxGKMC4YiJBsLR5BSEmezWtAUhThFCBQhyLRaGQiHiUYiJHNoGg7NQkyaSEBVFJJlpNlQFZWYabC/q5d/+MFWJiOEIDvdTjJVUYjLtOoEjSjBSIRk6RYL2boNySlSogiFcRk2G+P6hkZIFgqFSXRkaAATiYoACeHeMUYPDpFxbRYTiQQOYl1UzMQkV52ay+3V36Ctmqsm01NE0fXgdnBZzV/3L7TpT3HigXUUOTjXwnV8/9V1TM/L517cwacB3cmEvJ/fw4HPc778dTQeWEdcuH+IMON0nNk6s+H6wDdofyBMMt3pRFe5KN7P7KC9EnA4uRS8n9lBeyWgO7kQWTp8/71weBi+8CsIRphSmg6b7oAFGaS8g1lVWJoNCzJhVy8MhUEIWJINnjRQBLOi8RZgDJxgItKUDB8YIpGUku7RYRINj4xhGDE0TWWclLxJVRTGzclwsP+YxKFZUIXCibEQiayqyoJ0J6oQjBkmUkpynWkk060aiiKYKYddRwiBlJJxrsx04kKGwfy0DI6HRhmMRBiXZdWZl5aOKgRRM0bYNJmT4WCcKSXjpOQ8fQOjJBozDGKmRFV5U/BoEHtBGlq6hWRmaBQ5NoqwpZEykVxKN/2YUq6M+Q+uYz4XR892onNx9GwnOhdB1XFm61wWDidOB5eOw4nTwUVbkAHfXwO/Pg4RA6IxzmFRweuGTCspf0CsCnjzuGgaV5thYI4FmUi0P0wsFCORBPpDIRKNhSOc7B8hz5XJOJtVQwgBUjIWjWJKiSIEywvy2L7nECfGQhRmZpNl1RmIjGFKsGsaLpsdRQgkkpPhMTRVZW5OJokURaBYNIyYSVxejpObli8g2YGjvew93A1IpCLQNIVoNMa4wrkuhBCMGlGCMYMlzixCMYNoLIZV1bCpKnGmlPSEQiBgqSeXcSNjYcZlpdtJJCV0HesjUdSMYZgmVlVlnDQlY71jpKdbOJ8kNjqIZksjJSXl4t2RT0rKJadxlZlGhMkYowbJTGkSMqIkGgtH6e4ZIM+VyThnuh1FEcRMGAmFCYYjpNt0lnpyWeDK4VBvH93BUQrSM3BarSTrD4fpC49RctO1ZNh1EmmaSl8whGmaxN20fAGfLX8Xydp+u4u9h7uREo6eGMB7zVyi0RjjXM50iubnsevwcY6NjmIRCpm6jl3VSNQXHqM7FOTW5dfgzspgXN9IkDghBPk5ThKNjIY40TdMIiNmEjNNksWCBpOR0TApKSkpKW9dCleKUJiQlExGmpwnZkoMM0Yi05QcONRDIldmOul2G3FDoTBHegeIU4TgkbtuwJPt5GR4jH2D/QxFI0RNE0OajBkGh0eGOTo6indJAbcvv4ZkmZkOXt53BFNK4q5bmM9Erpmbi8NmJW7Ha6+j6RqJhICH77iBwrkuTExeHxli70A/3aEg/eEwPaEgewf7ORocYdk8Fw/cUMi4YDhCoG+IOE1V8ORmkajzcC/BYJhEEkn/WJBZkZKJCVJSUlJSrj6Fy0AIwfkEExGahcmodpVkUkpMKUl24PVugqEw49LsOisWe4iTUvLLV/djmCZx2ekOPnL/zdyweB4xAfsHB9gz0M+egX72DPZjaHDfyqX80c1FaKpCIotFJYLkhV2dxOVmplO0yMNECtzZLJ6bS9zgSIi9Xb2kp9tIZLNorLvzBm6/dhF23cKoEeXo6Aidw4N0jY4gNIXbll9D+Z1e0nQr41470s1gMERcXo4Td04G46SU7N7TRcw0SRYyoiRTdJXJCM3KhIQgmRCClJSUlJQrS+MyEEIgpeQcQgUZI5mwWBGaBWlESWbN1hGKQJqScRKJKTlP/8Aou/cchEzMPQAAIABJREFU5eYbFxNn0VTeffO17Nj9OuGowbG+QY70DrAoL4e4rDQ7D9+2kr7iUV470kOgfwiLqrAofw5L8nNJt+sIzqUoAs/cHH687RX6h4PE3bR8AXNdWUwkzWblnhsL6Th4jLjW33ZQ+8kHCYV6iMVMxqXbdMpWXccd1y5iz9Fuuk4MIgTMz81i2Tw3mQ4bQgjGhSJRtrz8e0xTogjBXSuXkGbXGTc4FKLzcA8TGYsaJNOzdSaj2NOZkFBIJoQgJSUlJeXK0rgMhBAkk4qKMJmQluUieuIYyRSrQtriDEb2DzHOlCCRJJNS8rPndnL9dfPRdQtxq1csYkmBi92dAUwp+emOXXz43lXkZDiIUxRBrjOdu1ekMx0hwOXK4uDxk2zdvptxZXcUowjBZO5YuYTG//oV4ahB57Fe/v2Zlyi/z8vhwycwTZNxQgiy0+3ctvwaWM6kjJjJL1/dTygcIc6Vnc4jD6xCEYI4KSXPbOtgeGSMiYzFoiTSc21Yc3QmolhtKGmZTESikEwIQUpKSkrKlaVwGQghSCaFymS0bBeTccxLw5qjcw7JhEZHw7z4ykGklMQpQlD+rlVYLRpxx/uH+O+XdhM1YsyGogg8+TmMmQbf/M//YSQURggou30FhfPdTCU3M52qD9yDpqrETEnb9l38ancnCxbkYrGozNaOfYfZvucQEhAC3nfHStJsOuMC3YPs3HWYyZiSN6k2lYxCJwgmpLkKQAgmIoVCMiEEKSkpKSlXlsJloCiCZFJoTEbLykWxWJmIYlXIuSkX+1wHikVBEaAIJmRKybPbdnPkWB/jVq9YxEdKb0VRBHG7j3Tzrz/7LSeGRpBSMhVFETgcOgsWujncP8Cff62Z4ycGEcCy+Xl84sE7URWF6bxndRG3rrgGRQjGIlH++f/+kqe378Izbw5OpwNVVZjOWNTg2Vf38dMdu4jGYgghKFm9gvffcwPjgqEIrc+8TDRqMBm7ZkGoAn2Ozpxb3WjpFiYkFCx5C5mMRCWZoghSUlJSUq4s9Qvr1/utFguXkmmaGEaMRBYlhhILMhGhakggNniSCQmwuezouToxi+ClvYeImSYTiRoxjvcM4L3+GhRFQQjBkgIX3f1DdB47SdxQcIxdh7vRLCoL8+YgTUkiVVXIyU5nricHe4aNf/nJNp782YtEjBhx81zZrP/4e8nNymAmFEXgXbaAPYe76e4bIm5X5zE6Dh5jReE8li5wo1lUolGDWMwkkdWqcaRvkB89/zteOXgUyRlL5rv53IfeTbpdZ9zP/+dVdu46zFRuXLGQRTfOJW1hBopFYTJa7lz0+ctBUZiIqdiImiqJLBYLmqaSkpKSknLliJHRoExz2LmUotEoweAYiWxKGD18nMnIWIzgK9uIjQ4xlWAowle++VOCoQiTEcCKa+fzwT9aja5biBuLRPm3//4tT//6VcIRgzhVUchxOrgmfw6FBW7mZKaTmWZjeCzM8b4h9hzqpvNYL0PBMaQEIQTLF+Tx6Q/eR+F8N7N1/OQgDf/5PC/sfp2YaRJns1oocGexfEE+C/KycTrsxGIx+oaCHO7u48DRXgJ9Q4xFosSpqsKd1y/h0x+8j8x0O3GmlPz2xX1seeZ3GDGTqTz2x/dRuDifqQirjbRV70ZxOJlMWM1kzFBJ5HDYsFgspKSkpKRcOWJkNCjTHHYupVgsxshIkESaiJEW6WIqscGThH7/MmZkjMmEIwZf+ebTDI+EmIqiCIqvnc/73nMTGek24mKmSdv23fz71h2cGBhGMnNpdp27Vi7h4++7g+wMBxcqFI7yo1+8ROuvOxgYCTIbmWl2HrxrJevedRM2q4W4aDTGjt8d4Ge/fJVwJMpUhBD8P5XvJXeOk0mpGvalXiwFhUxlVGRjmIJE6ekOVFUlJSUlJeXK0bgMFEUhmSFVEApIk8momXPQF11HaO/vQEomoqkK6Wk6wyMhpmKakp27DzM0EuKjj9yN3WZFVRTKbi/m9uLFND3zEj/d9gpGzGQ6xUvmUfX+e1ha4OJi2XULj773Nt6z+jr+7b9/y7Mv7WE6iiK4bcUiPvngXcx1ZZHol7/exbPbdjMTFouKzWZlKnrBMizzljIloWCYgmSKopCSkpKScmWJkdGgTHPYudSGh0cxTZNETtmLMIJMJzbUR2jP7zDHRklmmpIft+7gpVcOMlNZTgd33nott3gXY7VojBsYCXLw6Aleez3AoeN9DAXHMGMS3arhmeNk2YJ8li1wM8+VhaooJDNNiRAghGAyUkpMU6KqCsmklJwYGKHz+Ele3X+Urp5+gmMREJBm0ylwZ3HtQg+FBS5c2RmMk1JyoLObnz/fwZGjJ5FSMhMZ6XY+V1WGrltIJjQrtmWrsOQtBEVhKlLRGYqlkUhRFDIy0khJSUlJubLEyGhQpjnsXGrB4BjRaJRE6WIYNdLHTJijw0SOHiTaexRpxhgnJfxmx15++rOXmQ0hBMuX5LPqhsUULvFgtWgkM02JKSWaqjCVWMzkdx2HaO94HatFxXv9NVx/3QKSHeo6wW927GVoOEThYg+3rVqK3W5lKrGYCQJURWEih7tO8MquQ7y0s5NIxGA2PHlZ/OljJaiqwpuEQJvjQZ9/LWp2HgjBdGJqOiOGlUQWiwWHw0ZKSkpKypWlcZmoqkI0yjkMYUVlZpS0DGzLbsC6YCnhg7uJjQxiRsMIKVlQkIvdZiU0FmGmpJT8fn+A3+8PkJFu55MfuR/XHCeJFEWgIJjOSzsP8p+tLzJuz/4AOVnpzPPkMC4SMfj+j55nNBgm7vUjvQwOB3n/e29mKqqqMBHDiPFvP3qe/QePc6GWLfGgqAooCkK1oKZnoi9eiZrlZjYMVJKpqkJKSkpKypWncZlomkqyiLSiMzuKLQ37dTcjpYIZHsMMjbJw0Sg5v9jN0UNdXAiLppKeZuNC/X7vMRJJKfnZL1/l0Yp7UBRB3Cu7DjEaDJNo74EAsZiJqirMlqoqpDtsXCirTee6e+/DUbQcxZ6OsKWhWO2gKMxWJKaSTNNUUlJSUlKuPIXLRFVVhBAkMqVAag5mTQiE1YaamYslfyFpi4q45voVXKhrFrqx6RYulFAEyXTdghC8SVEEyTRNQVEEF0IIwR23LEMIwYXIcbtYfNtdWDyLUbPcKLY0UBRmSyo6puQcQghUVSUlJSUl5cpTuIw0TSVZTLFzYSSJim65iQu1+obFCCG4UDddvwiLRWOcw27l/rtWIIRgnPf6a3DlOhmnKgo3FC1ECMGFKpibw5zsdC7ENSuuxZGRwcWKCSvJNE0lJSUlJeXq0LiMNE0jGjVIFBE2NC6ANElUdOsqsnLnMHDiJLPhsOvML5jDxbhu2Vw+VnEPL7y8H0UR3LqqkHx3JokUReGjj9zNi787yLHj/axauYjrls/jYs2bm8OJvmFm6+b77uZSiEiVZJqmkZKSkpJydWhcRpqmkSxqakjVhoiNMSvSJJHFauU9f/JBnvrGt5BSMlMFc3MQQnAxFEVh8UI3ixe6mUpuTgZr3nUDl9LCebm80nGI2VhQuJRlq27gYknFQjSmkEzTNFLe/rq7+4jLy8sh5Z2hu7uPvLwcUt4Zurv7yMvLIZnCZaQoAk1TSRZT05g1aZKs6OabsKenMRtzstN5O8udk8FsCCG4b92DKIrCxYoJG8k0TUVRBFdE7ATtT32ZPy25hSVLlrNkyS2Ufuwv+ddtJ0h5OwjQVlNJeWM7Ke8MHY2VlNe00kPK1aRwmVksGsnCOJg9CdIkUe48Dw888n4URWGmcnOcvJ05MxzYbVZmqmDJIopvu4VLIWxqJLNYNK6IYDtfef+7WPdX36btwBBnDLF/23/x9x+7k9IvtRNmZjoaK6nZEmBKva3UVPhp62UC7TRW1NPBVNpprKikZkuAqfRs8VPe2M4fhN52nt/nwfeQl5no2eKnvKKS8op6Onj76dnip7yiksadTKlni5/ymlZ6eLtpZ/tWKC0vw80M7KynvKKS8go/bb1cdj1b/JTXtNJDkt5Wair8tPVyWkdjJeWN7cxIbys1FZXUbAnwVqJxmVksFkKhMIkMqWBa0lGiI8yYlCAlCN4khOC+dQ+x45nnOH7oCDPhzLDzdqZbNRwOndBYhOnodhvvr/w4jvQ0Lpap2jAMQTKLxcLlF+Y3X/1L/s/uMJPZ/62P8fmV2/hqmZOpBXDP87J3cwsda6oo5gL0AoXtbKxppa62DDcT8XJrCbRtbqFjTRXFTGLVako311O+1cuGpiqKe1upqW5hL9MoXEtdbRlu3vo6GivZuJU37a2upJEEhWupKz9M9aZ2zlFSRXOTl7MCtNX4adzHrC17zE/tGg+Ta6exop42Lkzp+gZ8Kzmrt5Wvbw4Q17apks7H/NSu8fBO0LPFT/XmAG/aVEkbibxsqFvAk9Ut7CVB4Vrqmqpwc1ZHYyUbtzJ7JVU0+7xcWQHavtbC3sK11K3x8FaicZkJIbBYNKJRg0RRJR2dEWZFmoBKIt1m476HH+Spum9hRKNMR9c1ZsKMmBgjURRdRUvTuFzMcAxj1EC1a6h2lelomorVojITy2+6gWU33QBCcLGi6CSzWDSEEFx2h57in77dxRk69/3Nk3z1w0U4jQM0/9kH+OtnwkCYn3z5Bzxe9gRFTMWDe81afNv8bN8JxSuZPZcXX20VVNRTXQN1tWW4OV+xr4rSrfVs3wnFK5mQ21WGr8lLQY2fJ7cEqF1TRm1TGVPp2eKnehtvG8W+BpofaqWm+gXurvNT6uJ8O+sBLxuaqihmMh5KaxsoJVmAtho/jYuqaPZ5uRil6xvwreRcva3UVLewaH0DvpXMQDuN1S3sLami2eeFnfWUb/JTg5/aNR7obaWm+gXurvNT6uJtx73GT/Oadhor6mF9A76VnK+3FfDgq/NT6mJSxb4Gmn2cp6Oxko2da6mrLcPNW0GAtho/jfs4pYXqihamUrq+Ad9KrhiNK8BisRCNGiQaM3Wsqg0RG2PGZAywkOz2976bw3v38+untzIdq9XCTAy8cpLIQIS4Obe5sWRYuNTMiMmJ3/RgRk1Um8qcW90oVoWpqKqCpqlMJ9eTzyN/9imEEFwsqVgYM1SSWSwWroTeHc/RzhsKnuAvPlyEUwXUJZSv/yuan9lIO6d0PcWzu5+gqIhpeCitbSBRR2MlG7dynr3VlTRyVun6BnwrOcWLr24tnV/jlABtNX4a9zGxTZW0kciDr64Svubn+bv81K7xUFrbQCnvVAHavtbC3pIqal3Qs8VP9bbV1NWW4eatr+elF9hbuJbPrGQGArTV1NOGlw0+L6etrKK5rpWaaj/lR6tofoi3vY7GetoK11K3EthZT/km2NBURTFXX88WP9WbA5zRQnVFC8seq+LubfU07uMNHu4mwdZ6yrfyptL1DfhW8qaORj+NrKWuqQw3k2mnsaKetpIqfCu5ojSuAItFQ1EUTNMkkaE5scTGmDFpAhIQJFI1jTUfLmfPS69w8ng3U5NMR0ZNjKDBuJH9g2QW56BYFC4VaUpGDg5hRk3izIhJdDCC7rIxJQmCqamaxtpPfYwsVy6XgiHsJFMUBYtF4/ILs2vnc7ypxEuRylkLi7jDAe1BTuni5T0noCiXiXQ0VrJxK0m8bGiq4rSSKpp9Xk7rbaWm+gXurvNT6gJ6W6mpfoECD2e5yqit5bTS2gZKiWunsaIe1jfgW8kUArTxB6K3nef3AfvqKd/KG1qormghbtljfmrncko7Gysqmciyx/zUrvEwseN07YNld+VzqXQ0VrJxKwlaqK5o4XxeNjRVUUxcgLYaP437vGxoqqKYBK4yaps8NFbU0zhvLW9v7WzfyiktVFe0MG5jRSWnlVTR/BCnBGisrqSRCZRU0ezzMrEARzuBRR7czJ57jZ/mNdCzxU/1ttXU1Zbh5pQ1DZRySm8rNdUvcI6SKpp9Xs4XoK3GTyNrqastw81k2mmsqKetpIpmn5crTeMKsVotjI2FSRQ07WQqVjAjzIiMgZQgBMly8t1U/u/11P2vDQz1DzCZSMRgOsKiYMmwED4ZJi58IszwvkGcy7MQquBiSVMycmCIYNco4xS7iiXTynRipknUiDEZVVN570cruOGu2xBCcNEUjaChkcxqtXBlDNPTxZvm5zg513wKbgGe47TfvH4EyGUixb4Gmn28IUBbjZ9GFuAGephG4DB7yedDLlJmy1VGbVMZ43q2+Knetpq62jLcnNGz5TgUrqWutgw3p+ysp3wTbGiqopirpKSKZp+XSe2sp3wTb2insaKeNrxsaKqimIl48TU1QG8rNZt5G/Pia2rAxxt21lO+CTY0VVHMG3ZuZy9eNjRVUcwpva3UVL/A3XV+Sl28TbTTWFFPW+Fa6mrLcO+sp7x5AXW1ZbhJ0NtKTXULPOaneY2Hq0HjCtF1K+FwBCkliaKWTCzhXmYsFgVNZyKexQtZV/04//7VbxIaGWEiY2NRZiJtkZPIwElkzCQudDRInHNZJkJTuFDSkAwfGCJ4ZAQkZwhIvyYDxaowHcOIEY4YTEQoCjc/cC/v+eN1KKrKpRAVDpIJIdB1K1fGEQ48x5uWuNxMJRxmRnq2NNC4z4Ovrgw30MPUOna0Q0kVxbTTWFFPG2cse8xP7RoPFy9AW42fxn1MrHAtdbVluHknCtC+LcCyu7y4uQC9ATqBRXM9XFJb6ynfyjS8nNYLFHooXXScjRWVTMzLhqYqinnn69jRDiVVFHMhjtO1D5bdlc/VE6Ctpp7Ox/w0r/EQ1+NZQOm+FqorDrOhqYpioGeLn+rN4KtroNTFVaNxBem6lbGxMImCpgOnakPExpgRaQA6ExFC4L33TmJGjO//w9eJGQbJTvYPMxPWLCvO67IY3NUPUhIXOhYkOhDBeW0WlmwrQghmSpqS6ECEod8PYAQNkJwhIGOpE7vHzkwEQ2GGR0JM5NaS+3nkzypRNZVLQSoWgoZGMl238rbW28rXNwdY9pifUhczUuxroJkzfE0N+AjQVuPneSbWtqmSNiZQuJa62jLcTGzZY35q13hI1LPFT/U23qYCtNX4adxHkhaqK1qIKy3x0rbPy4ZaD5PqbaWmuoW9TG7vpkramELhWupqy3AzQyVVNPu8TGpnPeWbOMPlxVfrpWeLn7bCtdTVluHmrJ4tfqq3LcDN219HYyUbt3KejRWVxC0r8cJWD746L5Nrp7GinjamsNlP+Wam4GVDUxXFTKO3lcaXgM0ttDHOw90k2FpP+Vbe4GVDUxWltQ2UcpbbVYavyQMV9WysqOS0kiqam7xcbRpXkNVqIRyOIKUkUUTLRI+NMSPSBGmCUJiIUBRufuBeIuEwLf/6XYJDIyTqPTnMjAiw5dmQ0UyG9w8iYxIkGKMG/a/0oc/RseXZsTgtqDYNBOeTEiMUwxiKEuoOEjkZRsYk44QiSLsmA8f8dBCCmejrHyUajZFIURRWv+d+PlD1CXS7jUslIhwkE0JgtVp42+ptpaa6hb142bDGAzvrqTm2lg9xytZ6yrdyjr3VlTRyRun6BnwrmVpvgE48+Or8lLo4R88WP9Xb+APjobS2gVLO6tnip3rbaupqy3ADHY2VsL6BYhKsrKK5ibNcZdQ2lTGRjsZKNnaupa62DDcXw0OBh5RpFPsaaPZx1s56yjfBhqYqioGeLX6+/lglpS7OcpVR21TGWV58TQ34OF/PFj/Vm/PZ0FRFMRdpXwvVX1tLXW0Z7jVl+Dilt5Wa6hc4R0kVzT4v0+oN0MkphWupqy3DzVuDxhUkhEDXrYyNhUk0ZtqwWNJRoiPMSCwCmo3JCEVwR1kJ2e5cfvAP32DwZB/juo6dZKaEInAsSAMBIweHMCMmcdIwGesOMdYTQrGoaGkaliwrqq6CCsQgFjKIDkYwggZmxCSZYlFIW5RB2sJ0ZuNQVy+JrLrOHe8r4SHfR7HabVwqpmpjzFBJputWhBC8LfW2UlPdwl7i2tlYUQl48dUBR4GSKjZQz0aqaPZ5eVNvKzXVh7l1JSkXo7eVmuoW9hLXQnVFC2/aWkkbSQrXUldbhpuptLN9Kyx7zIu7t5Wa6he4u85PqYvZ6Q3QCRSQYGs95VuZhpc/XO00VtTTxhkbKyo5y0/5ZpJ42dBURTFTCdC+LQAlaymmncaKeljfgG8lsxCgrcZP4z6gcC11tWW4uQg76ynf1M459rVQXdHCZErXN+BbyRWjcYXpupVIJIppmiQaUzJxMMKMmAZIE4TCZIQiKFq9iie+tIEnv/LPvP7aXuJ6Tw5xvGeAfHcWM+WYn4Y1W2dodz+RoQhIzpBgRmJEIjEi/WFmRIA104rzumy0dI3Z2t/ZzbiMzEweevyj3LbmPQhFcCmNSTvJFEVB161cWS6W3Ab8ltN6goNALpPRdSbV8ZMWeMxP89wWyjdBaUk7bZ0L8Lo89HBG8S1e2LSdDp+XYs7o+EkLe0uqKGYGAofZSz4fcjGxRR7c/CHz4KvzU+piSj1b/FRvY1o9W1pow4NvlQdo55IqqaLZ5+WMdhor6mF9A76VnLGznvJNzECA9m0BWOTBzTtP6foGfCuZ2s56yjcxvZ0tNO6D0nIv0M6F6Gj001XeQN0xP9XbuDC9rdRUt7CXU0qq2FDSzkaqaPZ5mVo7jRX1XGkaV4GuWwmFxkgUNTUM6xy0yEmmJ8GMgqoznYIli3n8b/+a//nPVn7e/GNihsFzv3qNR9behqIIZkpL18jyziFycoxgV5BIf5jZss6x4ZjnwDpHR9EUZmvfgQA9JwaJK7yxmLWf/BgLry1EKIJLyVAziBqCZLpu5cpz4V4C/JbTdh/pBZZw1hG6dvCm26+Zz2SKfQ3UcspOTrvV18CtjZX8104vBZ2w7K58WHkrpdTz5JYAtWs80NvKk1uhdL2XqXQ0+jn6kB/vseNQuBo35+s5GmA6ezf7Kd/M+QpJSdbbytc3B6CkilIX0MuFCxxmL/l8yMVpxb4G6rb4qdmST+0aD+dqp7FiO7c2VdHcxCTaaayop41xXjbUekmZSjuNm9qhcC0PruSCFfsaKAZ6jnHhXGX87yffixCCuI5G3tI0rgKr1UI0amAYBolGZTpOLYQwgkwrFgHFAkJhOpm5c3jQ9xEWXlfI1h8+xYFDR+juHcSTl8VsKBYFW74DW74DY8QgdDyIMRQhNhZDGhIpJUhAgBACYVFQ7SqWDCv2uXZUu8aFikQMfv58B1muXFa/512UffyPURSFS00qOqOGhWSapmG1WrjydAqWFgG7OW1rO7s/fxtFKmcc2s2vg7yhgJuW5zIbxb4GimmncRMsKvcAHh58zEP15hY61qzl6Nda2FtSRe1KJtFOY4WfNjz4HgrQvi0Aizy4uTDLHvNTu8bDO1eAxupKGpmBQqYQoO1rLezFywafl+n0bPFTvRl8dX5KXZynY0c7lFRRzBt6W/n65gB7C9vpWePBTYLefApK2tlY4cdX56fUxQS8+Joa8HH5SSkRQpBISokQgtmQUiKEYOYc5C5ZyPamv+eLT6ns3/86sViMyXmZiJQSIQS//+EPacOD77NluJnGiZ38v/9fC9d+5Iv4VnIOKSVCCM4K0Fbjp3EfCTzcTYKt9ZRv5U15H/wMX314OQcPHiQ7O5sLJaUkTgjB5aRxldhsOiMjBslCajYOI8iMxMKg2ZkRIVh5521cu+pGnv/Jf/Pz535BxR/dgtWqcSG0dI2MpU6QnCZjJtKQSBOEAkITCFUBwUWTEna+doT85Sv4o08+ypw8NwguixB2JmKz6VwtS+9dh5eNtHNK1zf5px/cy1c/XITTOEDzpi/TzhsK1nF/EbO3cztteNmwktPca/xsOFrJxop2wMuGWi/nO07XPti7r4W9JVU0+7yws57yfR58n/VyvgBHO2HZXflMzENpbQOlvNN58NX5KXUxpZ4tfqq3MamORj+N+zz46qooZqbymediAu1s3wql672c1ttKTXULe0uqaPZ5OY/LQ6mvgXlUsrHaD3V+Sl1Mb2c95ZtgQ1MVtU1lXErHjx8nPz+fOCklIyMjPPXUU3i9q8nLyyFuaGiIkZER5s6dSzIpJUNDQwghEEIwESEEUkrOSqOw9D6WFV5PQQZ0dXVRWFiIpmlIKTnH7u/wya+AKiUIgZQSIQRxQgh6O3dS9S8dPFz7Q0pdTCuqpPHaa52siBwEFpPs2Wefpeel/cBqwENpbQOlvKG3lZrqFzhHSRXNPi/jpJSEw2G2bdvGqlWrULkwQgjC4TDf/e53ue+++1i2bBmXg8ZVoqoKNpvO2FiYRFFTI6q7sYR7mJYZAzMKioWZstps3L9uLd577sDo2gNDR0FKLpjgNKEpCI3LwnRkUvT+P+buggIsViuTMg0wIyBNkIAQIBRQLKBoTCeqOokaCslsNh1VVbhqFj7I4w9+mT/9rzAQ5pd/+wG8f0sSnYf+6sMUMVsB2prboaSKYt7Q28qTW5nazu204cFX56fUxSntNG5qh5IqSl1M4Dhd+2BRuYdLYpEHN+98grOklAgh6Hr+u/zD89fgq/trSl2cY8Gy+Sx2gJSScUIIegM9ULgaN2dIKRkXPDCIs/Ivee9KTjnMf329g/2lVTR/wkui7AXzWJQnAUFcsa+BDVSysdoPdX5KXaB7rufeG+cxkZ5jx6FwNW7Ot2ReJnbOklIihGAmenp6GBwcpLu7mxtuuAEhBKFQiEOHDnH77XcTZxgGTz75JIZh8MQTTyCEIFE0GuVrX/samqahKArJHnjgATRN4yc/+QkWiwVFUYBj7Pjhdrj/A6zKMzEMg7/4i79A0zSEEJimiWEYCCHAcy9VVZBvGESBcDiMpmnYbDb6X/gO+81iCm6+j0eLBdORUnLs8Ot0dvawaH4aiaSUxGIxdu/eTb6qcKGEEAghkFKiqioXSkrJoUOHOHbsGLm5uVwuGleRrlsxDAPDiJEoaNrJsGahRAaYmoRYGIQWjX3hAAAcM0lEQVQKQmGmFEUhJz8P3LmED7xC+MgekJK3IjXTRXrRrSgOJ5OTEItALMI5pARpgmmAYgXNCggmYqppBA2NZJqmoutWri4npX/3JJ8LfIivvBhmIksf/y5fKnMyWz1bGmjc58H3WS9xHY2VbNwKyx7z07zGAzvrKa+ohMK11NWW4eYNK6tobuINAdpq6mnDywaflzPaaayop40EJVU0r+QiBWjfFoBFvE0FaKyupJHp5d/mIENKjFiMzs5Ojhx5hZ7XTuIpXsUXNr2bAscokMabXNez5v0F7DvYxYmRI/T395OVlcW8eXmE570Xq8zDzRlCCEKhEEeO7OfQy4fQ5+XQ+eqrWCMnyal4hH+em0ksFuDnf+OncR+nFZU8xrsyQnR19XHkyBFWrVpFsc+Pr7OBrkAAXB4y8xbg3NnNT37+cz757ndzVoD2bQFY5MHNudKXl/DQvEX0dnfz0muv0d3djaqqzJs3j4ULF2Kz2cjOzkYIwUTcbjcDAwOEQiF27drFihUrOH78OA6Hg7w8N3HPPvssPT09PP744wghSGa1WtmwYQOTkVKyZcsWMjMz+cxnPoOiKEA7je1h2o538rvjnPbYJz5HnBCCSCTMgQO7kVJyRh73fvBm8hQFKSVr1txM/09a+I3ldj7+6UKudz2DoiiclU9BITTuaMe30kuclJK4/9n6U2zzF3JdXh6JhBAEg0HS09O5fumtvNqVg0VKJCCE4EIoioLJKVvrKd/KjJRyRiwWY8uWLRQVFZGTk8PlonGV2Ww2RkZGSTYsM3FqUYQxypSkBCMMFjuzpqjoS29E6A7C+3+HlCZvGUKgZeRgv/4uhG5nSmYEYhGmZEbAkKDZSCZVnWFDZyI2m423BEcRn/7hNu5v/SZ133iKtgNDgJOld93LI49/nk/elcvsBWjfFqB0fQOltFJT0cLekiqam7y8aWUVzU3Qs8VPdUULlFTR7PNyjt52nt/nZUNTFcWM8+JrasDHxevZ4qd6c4CzvGyo9fL25MFX56fUxZR6f7aJjjlLGRsb40ff/z6BA//D754LYH/ocT4aOoEcTmfX0aMsW7aMrKwspJRAAUPBF/jsx7+ErtvIyMhCCME1Cwv4yEf/hA8uChMKhbDb7cTFYjF27NhJf/8wWcZOXjkEpmlisQTIEivp7la46bO1lLpcxEkpGR4e5uDBg+Tm5rJ9+3buvvtuSmv9vCn/WubpLXx+fSNbv/UjzuVlQ60XaKexop5XPXk88siDHDt2gl/s38d8eZQbb7yR66+/Hl3XGRgY4KWXXiI/Px+n00l+fj6ZmZkkklISV1hYSGdnJ4ZhIKVE13UeeeQR7HYbfX19uFwuPv3pT5OVlcVsSSkZHh7mhRde4H3vex+KopCodH0DvpWcxzRNYrEYiqIgXm2g4u/gU1+sYoWUmObLPPnEv/PsfZ/m2x9ZydDQEFarlURS5lP62bU8X11PvXEXxSuWo2oqqqKQs6KUzR+6FZeUIASJOl/+Bf39wzwfy+au1QsJd3cz7HDQ3d1Nfn4+GZwv22FhOjnv/zPq/7iYyUgpgQE6f7MfFkikhOPHj/Pud7+bpUuXIqVkMkIILoYYGQ3KNIedqykSiRIKjZFMFSbpRjeYEaalaKDZAMGFiA32Ej74Kkbfca42xZ6OvuA6LPOWgFCYUiwMsQgzpmig2QDBaYrGiMwgZgqS2e02rFYLKX8Yurv7iMvLy+GtIBaL0drayquvvsqjjz5KQUEB43p6ehgYGKCjo4OHH36YuFAoxLe//W08Hg8f+MAHEEIwLhAI8NJLLxGJRHj44YeJGxkZoaWlhcLCQlavXs04KSWvv/46hmFw6NAh7rzzTux2O1JKhoeH2bx5M2vXruXgwYN4vV6ys7NJ1NHRwcsvv8yjjz7KdAYHB6mvrycvL49169aRlpZGnBACKSVCCLq7uzlx4gQnT55k1apVpKWlMS4QCPAf//EfqKqKYRgsWLCAoqIinn76aYQQRKMmQpjEpaWlEWeaJqqq8qlPfYqZkFJy6NAhvvOd7/DFL34RVVW5FKSUGIaBEIKRkRG6u7u55pprUFWVOMMw0DQNTdOI6+zs5Omnn8YwDKLRKDabjXvuuYejR4+SlpbGPffcQ9w3v/lNFEUhJyeHOKvVys0338zTTz/NAw88wNKlS0kkpSQuFArhcDj+//bg/Tmq+n78+PP1Pufsnr1vkiUhVwgFVIKo6FhoLF5gKsPQiq0zHbGtdnScTmdqO/0L/Bv6czvtD7baWqvV8aPjXesUr/UKFgggEQi3hITs7eye8359v9t+8v1mMoEkYGvQfTyYEgQBDz30EBs3bmTNmjU0TExMkM1mERFmOnnyJI8//jjTBUGAiBCLxZjNTTfdxO7du+np6eH6669nLidOjNHR0cpMLotALOYRRRG1Wp3pIjWU3SUk6yOglvOyIYQBuD4XwsktIbH2BsLTR6iPHCScOA3W8t9kEmm8jmV4XSswiQxzigKIaiyIDSGqgxMDMZTJEFlhpljMIxbzaPrq6OhoZTEZHx9n9+7dfPOb36Snp4fp2tvbOX36NMeOHePo0aN0d3dTqVRob2/n2muvRUSYrrOzE9/3McagqogI5yIi9Pf3Mzo6Sr1e5+WXX2bbtm1MqVQqZLNZent7efPNN9m6dSsLpaqEYchvf/tburu7ufPOOzHGoKqcPn2ahkQiQSqVIpVKkcvl8H2fF154gdtuu40phUKB73//+xhjaPB9n1OnTjExMcF9992H7/uoKiLCFFVFRJiLqiIijI6OEgQBDY7joKqICOejqpyPiDA+Ps6vfvUrli1bxsaNG3niiSeoVCokEgl27NjBrl27WL9+PevWraMhDEN83+eOO+5gSiKR4MSJE0RRhIhw7NgxTp48yQMPPEBraysNqkoYhpyPqvLXv/6Ver3Oj370I2ZSVSYnJzl69CgHDx7kmmuuYSZrLRMTE/zgBz9gShRFOI7DubS0tPDhhx8ShiHz0dHRymxcFolEwsdaSxhGTFdXl2qsAz8YYU62DiHgxgFhocSL4XWuwOtcgS2dpfbZXsKzp9FKEbURWMvnRgQxDhLzcdI5vM6v4S7pYV5UIayARlyQqAbGoWry1CNhJtd1SCR8mpq+SCdOnKBarXLNNdcwm7a2NpYuXYq1lgYRYd26ddTrdWazZcsWFqKtrY1isciRI0eo1Wp4nseUWCxGJpOhtbWVQ4cO0d/fz3ypKiLCBx98QBiG3HHHHTiOQ6VS4de//jVBEDAwMMDKlSuZnJzktdde4xe/+AXt7e2MjIxQLpdJJpOoKp7nUSgUmGnnzp10dXVxLqrKXESEcrnM66+/zsDAAFNEhDNnztDS0sJsVJVdu3ZRLBYREdrb2wmCgImJCRpEhIajR4/ywAMPkMvlKBaLNPzyl78kk8kQhiG7du1iJtd1yefzTGeMobu7myiKeOmll1izZg2tra3Ml4hQLBY5ePAgW7ZsYTYiQjKZJJFIMDY2xvj4OPl8npmMMXR1dbEQIsLFcllEEokEpVIZay3TBTaGxJcSD44zJ1uHugU3ASJcKJPK4l9+HRpFaK2CLU4QFcex5bPY0gQ2KKO1gPkSx0XiSUwyjZPMYdI5TDqP8dOI64EI86IhhAGo5cIpgZMniAwzGWNIJBI0NX2RrLWMjY2Rz+dJp9PMpqOjgzvuuIMp8XicIAiIx+McP36cbDaL7/sYY1BVRISFSqVSxONxjh49yvLly5muUChQLpfZs2cPy5YtwxjDfFlreeONN9i4cSO+72Ot5eGHHyaXy7Fz504cx2FycpJnn32WNWvW0JBOp7HWcuLECfr7+3n88cc5fvw4xhgarr76apLJJM899xyu6+L7Ptlsluuvv579+/dz+PBhpogI5XKZrVu3csUVVzCbMAx55JFH6OzspKWlhQZVZWRkhGKxyMTEBMuXL2cmESGTyRCLxTDG0N3dzenTpzl27Bh9fX00qCq5XI5kMomIcDGWLl1Ka2sre/bs4eqrr6ZQKGCtxRjDXFQVEWHv3r2ICFdddRXn4rouuVyOWq3GO++8w+bNmxERFgOXRcQYIZn0KRbLzFS1cYgvJR4cZ04aQVgBJwbG5cIJ4rhIIoNJZHCX9ICNUGtBLUQRakOwFrUR2AisBREwDmIcMAYxDjguGIOIA8aACAuiCrYGUR1QLkYQX0o18phNMuljjNDU9EWKoghrLdlslvlKJpOk02l27dpFOp2mo6OD1tZWEokEiUSCRCJBKpViIWKxGMYYJiYmmMl1XbLZLH19ffzjH//guuuuYz5EhGq1ypkzZ1i9ejUNo6OjDA8P87Of/QzXdWkwxjA6OsqaNWuYUiqVMMbQcPPNN6OqGGNwHAff93nxxReJxWL88Ic/RERomJiYoL+/n+7ubvr6+mhQVay1pFIpZhNFEU8++SQjIyN897vfxVpLg4iQTqf57LPPyOfz7N+/nxUrVuA4DtNdeeWVTFFVnn76aVSV73znO4gIIsIUVaUhiiIuRLVaZWhoiOeff54dO3YwOTnJ4cOH+frXv858BEHACy+8wHXXXYfv+5xPS0sL5XKZjo4O3n//fa655hqmGGNYtmwZXwSXRcZxHFKpBKVShZmqNo7GO/FrJ0At56URhBUwMXBiIMLnwjiIcfgXD4T/NAUbQRSAWi6KGKqxDgIbYzapVALHcWhq+qKpKvF4HMdxWIgVK1awbNkyDh48yIEDB9izZw/ZbJa1a9ciIoRhyMDAAPOhqogI1WoVay2zKRQKlMtlPvnkEyqVColEgvmIoohEIkEul6OhWCzS1tZGW1sbDarKyZMnyefz9PT00FAsFqlUKnR0dNDQ0tLCdJOTk3R1dbFhwwZyuRxTcrkcw8PDRFFEsViku7sbEeFcwjDkf/7nf/j444+58847yefzjI2NMSWbzbJ+/XreffddWlpa2LdvHytWrCAejzOdqtJw9OhRDh06xE9+8hPCMOT999/n2muvxXEcpkRRRK1Ww/M8ziWTyXDLLbcwnaoyPj7OkSNHWLlyJQMDAwwPD+N5HocOHaK/v59zUVUaXn31VRpuuOEG5iIidHR0UKvVOHjwIKVSiVQqRYOI0N3dzfHjx5kv3/dRVS6WyyLkui7JZIJyucJMgY1hvU6S4SmwNeZka6AhmBg4HpcUDSGqgY24aCZG2V1C3brMJplM4LouTU2LgeM4ZLNZqtUq56OqiAjTOY7DqlWrWLVqFQ3FYpHDhw/jeR67d++mo6ODQqHAXESEer3O2NgYqVSKc2lpaWH58uW88cYb3HzzzcxFVRERuru7KRaLtLa2kkgk6O/vZ7qRkRGuvPJKGlSV5557jiuvvBLf95lOVZmcnOTIkSM888wzJJNJpmQyGW644QZefPFF1q9fz/j4ONZaWlpaSKfTiAgNqoqIUK1W+ctf/sLQ0BC33347q1atYjae57FhwwY++OAD4vE4Bw8epLe3l3Q6zXSqylNPPcW6detYunQpp0+fJpFI8Pbbb7NhwwamnD17Ftd18X2fc5mcnORPf/oTxhimfOtb32JycpKenh62bNlCQ3d3N6rKvn376O7uxvM8zmVoaIi///3vbN++nWQyyXx4nkc2m6W3t5c33niDzZs30xBFES+88AJ9fX3M10033YS1lovlskh5nksy6VMuV5mpri5Ft4OUHUPCEnNSC1EVbA1MDIwDYliU1IINwYagEZ8HdVOUTCuRGmaTTPp4nktT02LhOA6+75NMJqnX63iex3SqShRFvPfee/T399PW1oaIoKqICNOl02kGBgYYHR3FGMPevXspFAqcj6oiIoyMjFCpVOjq6uJc0uk0mUwG13UpFovMRUSIxWIMDAxw4MABWltbsdbS09PDiRMnSKVSfPTRR2SzWfr6+picnORvf/sbhw8f5v7772eKqlKtVvnkk0/Yv38/a9euxVrL3XffzRQRwRhDpVKht7eXWCzGa6+9huu6nDlzhiVLlnDrrbfScPz4cR599FEmJyfZuXMnK1euZC5XXXUV//znP6nX6/z5z39m+/btFAoFpuzbt496vc7WrVtRVQqFAuVymQMHDlCtVonH4zQcOnSIzs5ORARV5Vw6OzvZuXMnU1zXZWxsjOlisRipVIp3330Xx3HYvHkzM6kqR44c4Y9//COXX3451113HQvR1tZGpVKhWCwyPDxMX18fDclkknvuuYeFeOedd7hYLouY53kkk0K5XGGmSA1npUAm5mFq48yLWoiqYA0YB4wHYgDhC6UW1IKtg1pQy+fFxvJMag6UWSWTCTzPpalpMVFVkskka9eu5ZNPPmHdunVMJyKMjo7y9NNPc/fdd9PS0sLw8DDDw8PceOONzCYejzM6OkqhUGAuIkIQBLz66qssX76cTCaDqjIbEaFQKFAulzl16hTz4bouuVyO0dFRSqUSXV1dHDp0iN///vcYY7j55psJgoCHH36YMAxZuXIl9957L+l0moZischzzz3H0NAQ1WqVbdu20d7ejoiQzWZRVUSEhmq1ShRFNLS2trJjxw4+++wzPvroI5YvX46IsG/fPh555BEKhQL33nsvHR0dzNfll1/Ovn37OH36NEEQ0KCqRFGE4zjceeedGGMYHx+nXC4TBAGtra289dZbbNq0iXq9zptvvsng4CBzMcbg+z7TiQgzdXR0cNttt7FixQpms3//fh599FHa29u5/fbbWSgRIZ/Ps3v3buLxOH19fXyRXBY5z3NJpRKUShVm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"><br>也可以<code>修改位置和图片大小</code>：<br>代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">![图片描述，可写可不写，但是中括号要有](图片地址，本地链接或者URL地址<span class="hljs-comment">#pic_center空格=长x宽)</span><br>比如我此文章的图片：<br>![卷不动的小白](https:<span class="hljs-regexp">//i</span>-blog.csdnimg.cn<span class="hljs-regexp">/blog_migrate/</span>ec1c9a9c57e4d6494b5b36554f7af692.png<span class="hljs-comment">#pic_center =60x60)</span><br>)<br></code></pre></td></tr></table></figure><p>效果：<br><img src="data:image/png;base64,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fOtb32JycpKenh62bNlCQ3d3N6rKvn376O7uxvM8zmVoaIi///3vbN++nWQyyXx4nkc2m6W3t5c33niDzZs30xBFES+88AJ9fX3M10033YS1lovlskh5nksy6VMuV5mpri5Ft4OUHUPCEnNSC1EVbA1MDIwDYliU1IINwYagEZ8HdVOUTCuRGmaTTPp4nktT02LhOA6+75NMJqnX63iex3SqShRFvPfee/T399PW1oaIoKqICNOl02kGBgYYHR3FGMPevXspFAqcj6oiIoyMjFCpVOjq6uJc0uk0mUwG13UpFovMRUSIxWIMDAxw4MABWltbsdbS09PDiRMnSKVSfPTRR2SzWfr6+picnORvf/sbhw8f5v7772eKqlKtVvnkk0/Yv38/a9euxVrL3XffzRQRwRhDpVKht7eXWCzGa6+9huu6nDlzhiVLlnDrrbfScPz4cR599FEmJyfZuXMnK1euZC5XXXUV//znP6nX6/z5z39m+/btFAoFpuzbt496vc7WrVtRVQqFAuVymQMHDlCtVonH4zQcOnSIzs5ORARV5Vw6OzvZuXMnU1zXZWxsjOlisRipVIp3330Xx3HYvHkzM6kqR44c4Y9//COXX3451113HQvR1tZGpVKhWCwyPDxMX18fDclkknvuuYeFeOedd7hYLouY53kkk0K5XGGmSA1npUAm5mFq48yLWoiqYA0YB4wHYgDhC6UW1IKtg1pQy+fFxvJMag6UWSWTCTzPpalpMVFVkskka9eu5ZNPPmHdunVMJyKMjo7y9NNPc/fdd9PS0sLw8DDDw8PceOONzCYejzM6OkqhUGAuIkIQBLz66qssX76cTCaDqjIbEaFQKFAulzl16hTz4bouuVyO0dFRSqUSXV1dHDp0iN///vcYY7j55psJgoCHH36YMAxZuXIl9957L+l0moZischzzz3H0NAQ1WqVbdu20d7ejoiQzWZRVUSEhmq1ShRFNLS2trJjxw4+++wzPvroI5YvX46IsG/fPh555BEKhQL33nsvHR0dzNfll1/Ovn37OH36NEEQ0KCqRFGE4zjceeedGGMYHx+nXC4TBAGtra289dZbbNq0iXq9zptvvsng4CBzMcbg+z7TiQgzdXR0cNttt7FixQpms3//fh599FHa29u5/fbbWSgRIZ/Ps3v3buLxOH19fXyRXBY5z3NJpRKUShVm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"><br><code>注意：等号前有空格，是x不是*</code></p><blockquote><p>博主自己经常 Ctrl+v 粘贴图片更为便捷</p></blockquote><h3 id="3-7-列表"><a href="#3-7-列表" class="headerlink" title="3.7 列表"></a>3.7 列表</h3><p>列表分为有序列表和无序列表</p><ul><li>无序列表，使用<code>*</code>、<code>+</code>、<code>-</code>，再加一个空格作为列表的标记</li><li>有序列表，使用数字并加上<code>.</code>号，再加一个空格作为列表的标记<br>代码：</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> 无序列表 1<br><span class="hljs-bullet">+</span> 无序列表 2<br><span class="hljs-bullet">-</span> 无序列表 3<br><br><span class="hljs-bullet">1.</span> 有序列表 1<br><span class="hljs-bullet">2.</span> 有序列表 2<br><span class="hljs-bullet">3.</span> 有序列表 3<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><ul><li><p>无序列表 1</p></li><li><p>无序列表 2</p></li><li><p>无序列表 3</p></li></ul><ol><li>有序列表 1</li><li>有序列表 2</li><li>有序列表 3</li></ol></blockquote><p>如果想要控制列表的层级，则需要在列表符号前使用<code>Tab</code><br>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> 无序列表 1<br><span class="hljs-bullet">+</span> 无序列表 2<br><span class="hljs-bullet">+</span> 无序列表 2.1<br><span class="hljs-bullet">+</span> 无序列表 2.2<br><br><span class="hljs-bullet">1.</span> 有序列表 1<br><span class="hljs-code">1.1 有序列表 1.1</span><br><span class="hljs-code">2. 有序列表 2</span><br><span class="hljs-code">2.1 有序列表2.1</span><br></code></pre></td></tr></table></figure><p>效果：</p><ul><li>无序列表 1</li><li>无序列表 2<ul><li>无序列表 2.1</li><li>无序列表 2.2</li></ul></li></ul><ol><li>有序列表 1<ol><li>有序列表 1.1</li></ol></li><li>有序列表 2<ol><li>有序列表 2.1</li></ol></li></ol><h3 id="3-8-分割线"><a href="#3-8-分割线" class="headerlink" title="3.8 分割线"></a>3.8 分割线</h3><p>Markdown 中给出了多种分割线的样式，我们可以使用分割线让文章结构更加的清晰。<br>分割线的使用，可以在一行中用三个<code>-</code>or<code>*</code>来建立一个分割线，但是注意：在分割线的上面空一行！！！</p><p>代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">分割线：</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-string">***</span><br><span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span> <span class="hljs-bullet">-</span><br><span class="hljs-string">*</span> <span class="hljs-string">*</span> <span class="hljs-string">*</span><br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><hr><hr><hr><hr><p>注意：写分割线前，要空一行之后写，否则会导致前一行字体放大。</p></blockquote><h3 id="3-9-删除线"><a href="#3-9-删除线" class="headerlink" title="3.9 删除线"></a>3.9 删除线</h3><p>删除线的的使用，可以在要添加删除线的文字前后添加两个<code>~</code><br>代码：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haml">~~这是要被删除的文字~~<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p><del>这是要被删除的文字</del></p></blockquote><h3 id="3-10-下划线"><a href="#3-10-下划线" class="headerlink" title="3.10 下划线"></a>3.10 下划线</h3><p>下划线的使用和 html 中类似，在需要添加下划线的文字首尾添加<code>&lt;u&gt;文本&lt;/u&gt;</code><br>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>这行文字已被添加下划线<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这行文字已被添加下划线</p></blockquote><h3 id="3-11-代码块"><a href="#3-11-代码块" class="headerlink" title="3.11 代码块"></a>3.11 代码块</h3><p>Markdown 中代码块有两种：<br>如果在一行内需要引用代码，只需要用反引号 &#96; 引起来就好了。<br>代码：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">`Hello` World.<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p><code>Hello</code> World.</p></blockquote><p>如果是在一个块内需要引用代码，则在需要引用的代码块的前一行和后一行使用三个反引号，同时在前一个反引号后写入代码的语言。<br>代码：<br><img src="data:image/png;base64,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cEGJbh/f9+np4PzsKDEgsy/LWYID7B6FeNTm/BK42xwgx9gElyHBxg7I7TlAwNmyOz28vgwBEIzngTgtzZwluy/DSol3pfB9n95OGxERERERkXMZVlyWvcMOG9s4IxjPEYvafGi2w9YOyOzoJxOwKEt6RwY6tuLYnMOmfVMchp8iE7AgyPDEYI7lEt09OGQY2JllSTD0BOlR3mM7bO2AzI5+MgGLAjKPp8m1umxp46IS3T5uG+eRYEtXHIYHSI+wKCDzeJocDls7bSAg0+fh9WUIeE92XwZw2NjGu+xoHEbHCPhgiYdc4qNpkjuznDGSZmAYnEccbMCOxoAcu/cHnDGSZmCYFWF39tLbaSMiIiIiInIhYVZaME6+tYUtLMmyd9hhYzcrItHtk4r2k0x6pFkQ70rhd9qcj93ZS8+4x0DSI02ZQ0/K5alkmvckcP0e8AbwhlnQ6uJ25EjnOSPR7ZOK9pNMeqRZ1NGD353gw7I7e/GjabwdHhkWdfTgb0+wwMbZnoK+JEkvzXscenyXBAvsezcTH0wz4GWId6Xo7eT8bIdeP0raG8AbZlEcN+Xj2Cxoc/G3gbcjiTfIglaXVMrliWSa3fsDnE4bERERERGRq8WampoqsYImJycRWSn19fWIiIiIiMhHl0FERERERESkQhlEREREREREKpRBREREREREpEJZU1NTJUREREREREQqkEFERERERESkQhlEREREREREKpRBREREREREpEIZRERERERERCqUQURERERERKRCGUREREREREQqlEFERERERESkQhlEREREREREKpRBREREREREpEIZRERERERERCqUQURERERERKRCGUREREREREQqlEFERERERESkQoVZYZOTk8jlqa+vR0RERERERN7PICIiIiIiIlKhDCIiIiIiIiIVyrDiAjJ9Ht7OLJcnINPXTybgtyYY6sfz0mS5EgGZPo/+oYCyYKgfb2eW8xpJ43kenpcmi4iIiIiIiFyINTU1VWIFTU5OckVG0ng78ripXhyb604w1E9yz2ZS2x1sygIyfUl2b0rR22nznixpb4B8V4reTpuy+vp6RERERERE5P0M8uEFGZ4YBPcxB5slNs4jDrnBXWRZJhgnD8SiNiIiIiIiIvLBwqy4gExfknSsB787AWRJewPku1JsHU8yMMwihx7fJQEEQ/0kB3OUpZMe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PkEmYFGW9I4MtLpsaePStbn0dEBmR5osi4IMTwzmuBzBeB6IEbUREREREZHfAWGuA/EuF3Z4eCzq6MHvTnBV2O1sboX0Do9Mq0tqu8P5JB5yiSd3cyBwcGxWXKLbJxXtJ5n0SLOoowe/O8GlSnT7pKL9JJMeaRbEu1L4nTbnsqMxIAcdG0lwrgQbOyAzHGfzvTbLJbp9UtF+kkmPNAviXSn8TpvLlej26cFjwMuwII7b5ZAbzHNpAg7syRHvepQEC4KhfpKD4KZ6cWxEREREROQ6Y01NTZVYQZOTk6ycLGlvgHxXit5Om8oSkOlLko714HcnkAowksbbAT2+S4L3ZHf2M/5QL44N9fX1iIiIiIjI9cMgV8jGecwlPvwUmQD5rQvIfD9DvGsLCZbLsnc4RtRGRERERESuQwa5crbDo12QfjxDgPw2BUNPkI710Ntpc5aRveS7tpBARERERESuR9bU1FSJFTQ5OYlIpaqvr0dERERERK4f1tTUVAkRERERERGRCmQQERERERERqVAGERERERERkQplEBEREREREalQBhEREREREZEKZRARERERERGpUAYRERERERGRCmUQERERERERqVAGERERERERkQplEBEREREREalQBhEREREREZEKZRARERERERGpUAYRERERERGRCmUQERERERERqVBhVtjk5CTnU19fj4iIiIiIiMjlMIiIiIiIiIhUKIOIiIiIiIhIhTKssGCoH8/z8PoyBIiIiIiIiIhcOWtqaqrECpqcnASypL0B2ObjtvGu+vp6RERERERERC6H4aqwaWmF/HiAiIiIiIiIyJUyXEW58QARERERERGRK2UQERERERERqVCGq8ImGkNERERERETkQzFcJYkNDgw/RSZARERERERE5IoYrpY2F9/fyljSIz2CiIiIiIiIyGULc7WMpPF25HFTPo6NiIiIiIiIyGUzXCXZfRlo3Uy7jYiIiIiIiMgVMVxNsSg2IiIiIiIiIlfGICIiIiIiIlKhDFdFwHgeERERERERkQ/FcBXFozYiIiIiIiIiVyrMCguG+kkO5qDVJdVpIyIiIiIiInKlrKmpqRIraHJykvOpr69HRERERERE5HJYU1NTJUREREREREQqkEFERERERESkQhlEREREREREKpRBREREREREpEIZRERERERERCqUQURERERERKRCGUREREREREQqlEFERERERESkQhlEREREREREKpRBREREREREpEIZRERERERERCqUQURERERERKRCGUREREREREQqVJgVNjk5yZWwLAtjDLZtMzU1hYiIiIiIiFwdxhhKpRKlUolKZ6gQpVKJQqGAiIiIiIjIEsuyWM4YQyQSwbIslliWhWVZXIgxBmMMxhiMMRhjMMZgjMEYgzEGYwzGGIwxGGMwxmCMwRiDMYYrZYyhqqqKyxGJRLAsi/OJRCKEQiE+DMuysCyLXC5HEARcKcuyqKqqwhjD1WQQERERERGpQMYYIpEIQRCwxLIspqen+fd//3fGxsYoi0QizMzMMD4+zvmEQiGmp6eZmZlhZmaGmZkZZmZmmJmZYWZmhpMnT3Ly5ElmZ2eZmZlhZmaGmZkZZmZmmJ2dZXZ2lt/85jfMz89zJU6cOMHjjz/OsWPHuBhjDIVCge985zu88sornMuyLJ577jl++tOf8mHMz8/zi1/8grGxMa6UMYa5uTl83+fgwYNcLWFW2lxAbu9B3ibG792/ljoWTb7BvgN5uPFjtN9pE6HsFEdeep7XjsDN7fezth4RERERkY+UUCiEMQbLsiiVShSLRQqFAudjjMEYgzGGslKpRLFYpFAosJxlWYTDYZYrlUqUFYtFisUi57Isi3A4TKlUYn5+nvMJhUKUFQoFLocxBmMMlmVhWRalUolSqUSxWKRYLHIhxWKRN998k+npaV588UXuuusuLMtienqa1157jZqaGsLhMIVCgcHBQebn5/E8D8uyWG5qaop//Md/JBwOY1kW5/qjP/ojIpEITz31FJFIBMuyWK5UKjE/P88//MM/EA6HsSyLcDjM/Pw8lmVxrqmpKSzLoqamhiVTU1MYY7iYUCjExMQEBw8epKOjg+WMMRQKBV588UXuvPNOPgzLsiiVSoTDYa5UKBQil8sxPj7OjTfeyNUSZqVV2cTvX82Rl57nN683smFdA++qX8uG+xt545cvkA9WE7cjQIQb77yfxuA3HDjwBmvuX4uIiIiIyEeBZVlEIhEKhQIvv/wyr7/+OlVVVaxbt45IJEJtbS21tbUsCYfDGGM4evQo2WyW48eP09TUxLp16wiFQjQ2NhKJRCizLIu5uTny+Tyzs7OUWZZFfX09dXV1hEIhamtrMcawxLIsZmdnOXbsGK+99hrt7e1UVVWxnGVZHDp0iGw2i+M4XIxlWYTDYSzL4vDhw2SzWQ4fPkwoFCIWi3HbbbdRVVVFXV0dlmVxPmvWrOHtt99mbm6OkZERPvGJTzA+Ps6qVauwbRtjDLt27WJiYoK/+qu/wrIszlVVVUVvby/nY4whHA7zzDPP0NjYyN/+7d9ijOGDlEol8vk8//qv/0qpVHq4K3AAABWKSURBVGI5YwylUonPfe5z3HfffZRZlkWZZVl8EMuysCyLvXv30tzcTHNzM8sZY5ienqahoYG7774bYwxLisUiV8KyLK5EOBymUCjwzDPPkEgkaGpq4moJc1VEuPHO+7mRczWw9v77OVfE/j022IiIiIiIfGREIhFmZ2f5t3/7N8bHx7nzzju54YYbGBkZYf369bzxxhvcfvvtrF69GsuyMMbw4osv8t3vfpebb76ZO++8k5mZGfbv38/HPvYxXn31Vdra2li1ahVl8/Pz/OpXv+LIkSM0NjZSViwWqamp4ZOf/CSWZdHY2MiNN97Ikvn5eXK5HM3NzTz//PM88MADnGtycpKxsTEuxrIsIpEIU1NTfO973+ONN96gvb2dj3/841RXV/P222+zZ88e1q1bR2NjI01NTTQ0NLDEsiwikQhlH/vYx3j11VeZn5+nbNWqVXR1dREOhzl27BjRaJRvfvObrFmzhlKpxKlTp7hUoVCIyclJ/ud//oeHHnoIYwyX4uabb6anpwdjDJZlsaRUKlEsFgmFQixXVVWFZVmcTygUIhQKUTY3N8dtt93GAw88QFVVFYVCgUKhQJkxhrfeeotYLEbZxMQExhjq6up4/fXXaW5upqGhgXNZlkWpVOKDWJZFqVTifEKhEKFQiHONjY3x+c9/ntbWViKRCOczPz9PsVjkwwgjIiIiIiLXVCgUolgs8tOf/pSJiQm+9rWvsXbtWpYcO3YMy7L4r//6Lx5++GGMMczOzjI8PMzdd9/Nww8/jGVZLAmCgIMHD/Lss8/ypS99ieU2btzIfffdx5JSqcShQ4ewLIuRkRHuu+8+Vq1axZJ9+/axdetWyo4fP86aNWu4EpFIhLfffpt//ud/prm5mW984xs0NjZiWRbFYpFSqUTZxMQE77zzDiMjI9x9993U1dVRViqVOHToED/4wQ+wLItisUgsFiMcDvPMM89QVl1dzdTUFGW1tbVYlkWxWMQYw1//9V9zMaFQCMuyOHr0KKVSiXvvvZdLZYzBGMP5hEIhqqqqmJ+fx7IsisUif/Inf0JDQwOhUIiy2dlZLMsiHA5jWRavvvoqP/jBDygUCpw6dYqamhocx+HQoUNUV1fz6U9/mrIf//jHlB0+fJiy6upqNm/ezHPPPceDDz5IQ0MD54pEIkxNTRGJRDgfy7KIRCIcO3aM2tpaLMviXEEQ8L3vfY8lxhhmZ2cxxhAOhzmfz372sxw4cIBbbrmF++67jysVRkREREREriljDMeOHeOFF17g93//91m7di3LNTU1ceTIEQ4fPszY2Bjr1q1jdnaW5uZmPvnJT2JZFsvZtk04HKampoZSqcQHsSyLWCzGO++8w9q1a3nuuefYsmULS6anp6mtreXWW29l7969dHZ2crnC4TDz8/P8y7/8Cy0tLXz5y1+mpqaGYrHIW2+9RSgUIhKJ0NDQQG1tLWvWrKGmpoZMJsMXv/hFljQ1NbF161aMMZQ1NDQQBAHHjh3j61//OtXV1Vwpy7IIhUIcOXKEubk5ykKhEJZlUSqVuJBwOIxlWVzMW2+9xT/90z9x++238wd/8Ac8+eSTTE9PU1tby5/92Z/x85//nPb2dtrb2yk7deoU1dXVbN26lSWrV69mfHycQqFAOBzmjTfe4M033+Qb3/gGTU1NLDHGcCHGGEqlEk8//TQzMzO4rsu5SqUSJ06c4M0332RycpJ77rmHcxUKBd5++226urpYUigUCIVCXMjNN9/M/v37mZ+f58MIIyIiIiIi15RlWbz55pvMzs5y7733cq5SqURjYyM33XQTxWKRYrFI2Sc+8QlKpRKWZVEqlVjOcRwux5o1a5ienmZ8fJy5uTlqampYYoyhrq6Om266iVdffZXbb7+dy2GMYe/evczPz/PII49QXV3N9PQ0TzzxBHNzc9x1110kEglyuRzDw8P8/d//Pc3Nzbz55ptMT0/T2NiIMYaqqirq6upY7ujRo3zta1/jtttu44PMz89TLBa5kEgkwvT0ND//+c+5++67KQuFQoRCIYIgoLGxkfMpFovs2bOHqakpym6++WZOnjzJ8ePHKbMsC8uyOHToEN/4xjdoampidnaWsm9+85s0NjZijOHnP/855wqHw6xZs4YlkUgEYwy33norxWKR//zP/ySRSNDU1MSlMsYwNTXFyy+/jOM4XEhVVRWrVq3i6NGjHD9+nDVr1nAuYwzRaJRLVVVVxUoIIyIiIiIi11SpVOLo0aOsWbOG+vp6zqe5uZmtW7eyxBjDyZMnqamp4dixYzQ0NFBVVUVZoVDgcpVKJerq6qiurmZsbIzW1laWu+GGG5idneWFF14gFothjOFSWJZFqVRi9+7dfOpTn6K2tpayb33rWzQ2NvKVr3yFSCTCyZMn+dGPfkQikaCstraWUqnExMQEtbW1PP300xw+fBjLsijbuHEjdXV1/PjHPyYSiVBVVcWaNWvYvHkzL730EqOjoywxxjA9Pc1nP/tZEokE54pEIhQKBb71rW+xdu1a1qxZQ1mhUGBiYoKpqSneeecd1q5dy7mKxSK1tbWEQiEsy2LdunUcOXKE119/nbVr17IkkUhQW1uLZVmUlUolrkRLSwu2bfPiiy+yceNGbrjhBorFIsYYLsayLIwx/PrXv6asvb2dCzHGUF9fT3NzM/v37+fBBx/EsiwqQRgREREREbmmCoUCpVKJhoYGLlVNTQ2RSITdu3fT2NjILbfcQlNTE6tWrWLVqlVEIhGqq6u5HJFIBGMMJ06c4FyWZVFfX88dd9zB/v37+eQnP8mlsCyLubk5jh8/zvr16zHGcOTIEQ4dOsTf/M3fEA6HMcZgWRZBEPDFL34Ry7KwLIvJyUmMMZT94R/+IaVSCcuyiEQiNDQ08LOf/YxIJMJf/MVfsGRqaop4PE40GiUajbKkUChQV1fHuSKRCKVSie9///scPnyYrVu3YoxhSVVVFYcOHaKpqYnXXnuNdevWEQqFWO6uu+6izBhDOBzm6aefplQq8aUvfYlCocD5FAoFLMvics3OznLw4EF27drFn/7pnzI9Pc1rr73Ghg0buJhwOMzc3Bw/+9nP2LBhAzU1NXyQhoYGZmdnaWlp4cCBA9xzzz0sMcZwxx13YIzhWgsjIiIiIiLXXHV1NaFQiMtxxx13EIvFeOWVV3jllVf4v//7P2644Qba29uxLIvp6Wk+/vGPcyksy8KyLGZnZykUCpzP6tWrmZ2d5Y033mBmZoaGhgYuplQqMT8/T01NDatXr6ZscnKSpqYmbrzxRsqMMRw+fJjVq1ezdu1aQqEQJ06cYGZmhubmZsrWrFlDmTGGcDjM5OQkt956K/fffz+rV69muVdeeYWqqirm5ua4+eabKZVKnMuyLCKRCIVCgR/96Ee88MIL/Pmf/zlr1qzhxIkTLGloaOCuu+7iwIED2LbNa6+9xrp166iqquJc4XCY119/nVdeeYXHHnuMUqnE//7v/3LPPfcQCoUosyyLQqHA3Nwc4XCYC1m9ejVbtmyhqqqK5Y4ePcprr71GPB5n/fr1vPnmm9TU1PDaa69x2223cSGhUAjLshgeHqbsgQce4FI0NTUxPz/P4cOHmZqaoq6ujjJjDLfeeitBEHCpVq1aRalU4sMKIyIiIiIi15RlWTQ2NnLy5EkuJBQKUSwWKZVKLBcKhVi/fj3r16+nbHJykrGxMWpqanjppZe46aabaG5u5mIsy2J+fp4jR45QV1fH+ZRKJRoaGrjjjjv41a9+xWc+8xkuplQqYYxh3bp1TE1NUVNTw6pVq4jH45SFw2Esy2JiYoL29nbC4TDGGH7yk59w1113UVNTQ5llWYRCIYwxTE5O8vrrr/PDH/6QmpoaljQ2NvLpT3+aZ599lk984hMcO3aMsjVr1rBq1SoKhQJloVCIUCjEyZMnefLJJzl48CAPP/ww69ev53wikQgbNmzgxRdfpL6+njfeeIPm5mbq6upYEgqFKJVK/Md//Aft7e3cdNNNHD9+nIaGBvbu3cunPvUpyowxnDhxgnA4TE1NDRdy4sQJvv3tb2NZFks+//nPMzk5ydq1a/nMZz5DWXNzM2UvvfQS0WiUqqoqzhUKhQiFQhw8eJD//u//5vOf/zy1tbVcilAoRF1dHbFYjOeff55Pf/rTlM3Pz7Nr1y7WrVvHpfrsZz9LqVTiwwojIiIiIiLXXE1NDXV1dZw6dYpIJMJyxhjK9u3bRywW45ZbbqFUKnHq1Cksy2K5+vp6EokE77zzDsYYDh48SHNzMx/EsiyMMYyNjTEzM0M0GuVCVq1aRX19PTU1NUxNTXEpjDG0t7czOjrKDTfcwKlTp4jFYhw/fpyqqipGRkZYvXo1sViMyclJnnvuOQ4dOsTXv/51LMsiEolQdvLkSV544QVyuRzt7e0UCgVc12VJKBSiurqa2dlZWlpaqK6u5he/+AVVVVUcPXqUpqYmtmzZQigU4vDhw3z3u9/lnXfe4ctf/jLxeJyLueuuu3j55ZcpFot8//vf56GHHuLGG2+kLBQK8etf/5r5+Xk+97nPYYyhqamJ2dlZDh48yOzsLDU1NViWxejoKLfccguWZXEhpVKJm2++ma985Sssqa2t5ciRIxQKBZaEw2Gqqqp4/vnnKRaLfOYzn2G5UChEKBTi9ddf59vf/jZ33nknGzZs4HI0NjZy8uRJZmZmOHToELfffjtlq1at4qtf/SqXqqqqil/96ld8WGFEREREROSaKhQK1NbWcs899/DSSy9x1113sVw4HGZiYoJnnnkG13WxbZuxsTFeeeUVHnjgAc5ljKGqqoogCFi9ejUXEw6HmZubI5PJEIvFaGho4IOsXr2atWvXcvToUS6FZVk0NjYyPz/P9PQ0zc3N5HI5nn32WUKhEA8++CDvvPMOP/zhD5mfn6e1tZW//Mu/pL6+nlKpxDvvvMPPfvYzDh48yMzMDF/4whe46aabKGtsbKQsFAphWRanTp2iUChQdsMNN/DHf/zHvP7667zwwgvcdtttFItFstks3/nOd7jxxhv52te+xs0338ylWr9+PS+//DJvvfUWJ0+epCwSiVAoFKiursZ1Xaqrqzlx4gTT09PMzs7S1NTE888/T0dHB/Pz8+zZs4dNmzZxMcYYampqWBIKhbAsi3PZts0XvvAF7rjjDs5VKBQ4ePAgTz75JDfddBMPP/wwV2LVqlUcOHCAUCjE7bffzm9TGBERERERueaqq6upr69ndnaWubk5qqursSyLcDjM/Pw8Tz/9NLZtc9ttt1EqlSgWi6xbt47jx4/T1NREqVTCsixCoRCWZZHP5xkbG+PBBx9kSTQaxbZtQqEQZZZlYYxhfn6eZ599lrfeeouvfvWrXEw4HKauro4TJ05w4sQJLkVDQwPHjh3j2LFjhEIhHnjgAe6//36WGGPYsGED51NdXU2xWGTTpk20tbVxww03cOLECZYrlUocP36cQ4cOceLECerq6ohEIpw6dYp169axbt06lrS2tvLQQw/R3t5OOBzmcq1fv56/+7u/IxKJUDY/P8+TTz5JLpdjbm6Ompoa1qxZw+rVq1mzZg2vvPIK69atwxjz/9uDt5co+gCOw5/fjOOuzexBrS3NLemgVBhFISydLjpIQYeb8KJu6qJ/wj8l6KKLLoIgCAuyCCroJjTJQBRBUSJMSatxdydn5sULQaTDmtG7L+/3eRgcHCQIAvbv38+ftHfvXn6ktbWVzs5OOjs7SSQS/A7P87hx4waZTIZ/Ww0iIiIiIvLXJZNJgiCgXC4zMzNDQ0MDjuMwMzPDw4cPef/+PVeuXMEYw5LGxkb6+/vJ5XJEUYTruti2TalUYmhoiGfPnrFr1y527NjBsnw+j+u6fP78mSVBEDA9Pc2LFy+Ynp6mq6uLfD5PJbLZLOVymcXFRSrhui65XI43b97Q1NRES0sLqVSK2tpajDGUy2XGxsbI5XKk02lWO3/+PCsZY4jjmGVRFHHr1i2CIODIkSNks1nm5+e5f/8+3d3d2LbNSgcPHmQ9HMdhWRzHHD58mEKhQDabpa6ujpWCIMDzPObn53nw4AGFQgHP8/gZYwy2bfMnWJbFiRMnWK9MJsMyx3G4dOkStbW1/G01iIiIiIjIv2Lnzp2MjIzw+PFjFhYWKBaLlEolmpubuXr1Klu3bmVZMpnk0KFDPH/+nKdPnxKGIeVymYWFBTzP49ixYxQKBYwxRFHE+Pg4d+/eZTXXdWlpaeHcuXM0NzezLIoiRkZGKJVK/EgQBDx58oTW1lYq0djYyPHjx3n9+jWvXr2iVCoRxzG+77O4uMimTZs4deoU6XSaX7Esi2w2y0rXrl3DdV1s28ayLGZnZ5mbm8O2bdbKGMNabNu2je+xbRvP8/j69Ss3b95k8+bNHD16FMuyMMZgjCGKIorFIiul02lOnjyJ4zisFMcxP2OMYUkYhlTKGEMcxywuLlKpKIro7e2lr6+PSp05c4YwDFmvGqqIZVmIiIiIiPyftLW10dbWxvz8PMVikVQqheu6fE8ikeD06dPEcczc3Bzlcpm6ujoymQyr7d69m56eHtaio6ODjo4OfiSfz9PT08NaOI5DoVCgUCjg+z6+72OMIZ1Ok0gkqEQURQRBQFdXF0ts22ZJfX09y8Iw5N27dzQ1NfE7LMsiiiIsy+J3GGNwHIclExMT3Llzh3Q6TXd3N7Zts6RYLPLt2zempqb48OEDqVSKZV++fOH27dsYY1h24cIFfN8nmUyymmVZWJaFMQbf95mdncW2bX6mpqaGKIowxuD7Ph8/fsRxHCoRhiG+73P58mUqtXHjRvr7+1mvGv4wz/NYD9/3ERERERH5v8lkMmQyGSphjKG+vp7/Gtd1cV2X37FhwwYePXrEvXv3+J4oiiiVSly8eJG1CMOQwcFBwjAkDEMsy+J3xHHM9PQ0fX19jIyMsG/fPs6ePUsikWBJFEUMDw/T29uLMYYDBw6wfft2loRhyMTEBE1NTVy/fp1llmXx9u1bkskkq0VRxNTUFC9fvmRycpJkMklzczM/E4Yhw8PDDA0NMT4+TiKRIJ/P8ythGDIwMIDjOORyOdZicnKSfD7Pehjf92NERERERET+A3zfJwxDvse2bVzXZa1836dUKtHQ0IAxhvUYGBigvr6e1tZWVisWiywsLJDJZKipqWGl8fFxyuUy7e3trDQ6OkoqlWLLli2s9unTJwYGBshms7S3t+O6Lr8yNjbG6OgojY2N7NmzB8/zqHbG9/0YERERERERkSpkISIiIiIiIlKlLERERERERESqlIWIiIiIiIhIlbIQERERERERqVIWIiIiIiIiIlXKQkRERERERKRKWYiIiIiIiIhUKQsRERERERGRKvUP/J6AAj4rXFQAAAAASUVORK5CYII="><br>效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>支持以下语言：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">bash<br><span class="hljs-keyword">c</span>，clojure，cpp，<span class="hljs-keyword">cs</span>，css<br>dart，dockerfile, diff<br>erlang<br><span class="hljs-keyword">go</span>，gradle，groovy<br>haskell<br>java，javascript，json，julia<br>kotlin<br>lisp，<span class="hljs-keyword">lua</span><br>makefile，markdown，matlab<br>objectivec<br><span class="hljs-keyword">perl</span>，php，<span class="hljs-keyword">python</span><br>r，<span class="hljs-keyword">ruby</span>，rust<br>scala，<span class="hljs-keyword">shell</span>，sql，swift<br>tex，typescript<br>verilog，vhdl<br>xml<br>yaml<br></code></pre></td></tr></table></figure><h3 id="3-12-表格"><a href="#3-12-表格" class="headerlink" title="3.12 表格"></a>3.12 表格</h3><p>表格使用<code>|</code>来分割不同的单元格，使用<code>-</code>来分隔表头和其他行</p><ul><li><code>:-</code>：将表头及单元格内容左对齐</li><li><code>-:</code>：将表头及单元格内容右对齐</li><li><code>:-:</code>：将表头及单元格内容居中</li></ul><p>代码：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> 项目        </span>|<span class="hljs-string"> 价格   </span>|<span class="hljs-string">  数量  </span>|<br>|<span class="hljs-string"> --------   </span>|<span class="hljs-string"> -----:  </span>|<span class="hljs-string"> :----:  </span>|<br>|<span class="hljs-string"> 计算机     </span>|<span class="hljs-string"> \$1600 </span>|<span class="hljs-string">   5     </span>|<br>|<span class="hljs-string"> 手机        </span>|<span class="hljs-string">   \$12   </span>|<span class="hljs-string">   12   </span>|<br>|<span class="hljs-string"> 管线        </span>|<span class="hljs-string">    \$1    </span>|<span class="hljs-string">  234  </span>|<br></code></pre></td></tr></table></figure><p>效果：</p><table><thead><tr><th>项目</th><th align="left">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="left">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="left">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="left">$1</td><td align="center">234</td></tr></tbody></table><h3 id="3-13-脚注"><a href="#3-13-脚注" class="headerlink" title="3.13 脚注"></a>3.13 脚注</h3><p>脚注是对文本的备注，我们时长在论文中看到脚注，在 Markdown 中的使用方法<br>代码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。<br>[<span class="hljs-symbol">^1</span>]:<span class="hljs-link">Markdown是一种纯文本标记语言</span><br>[<span class="hljs-symbol">^2</span>]:<span class="hljs-link">HyperText Markup Language 超文本标记语言</span><br>[<span class="hljs-symbol">^T</span>]:<span class="hljs-link">NEW WAY TO READ &amp; WRITE MARKDOWN.</span><br></code></pre></td></tr></table></figure><p>效果：<br>使用 Markdown<a href="#fn1">1</a> 可以效率的书写文档, 直接转换成 HTML<a href="#fn2">2</a>,</p><blockquote><p>注意：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</p></blockquote><h3 id="3-14-特殊符号"><a href="#3-14-特殊符号" class="headerlink" title="3.14 特殊符号"></a>3.14 特殊符号</h3><p>对于 Markdown 中的语法符号，前面家反斜线<code>\</code>即可以显示符号本身。<br>代码：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\\</span><br><span class="hljs-string">\*</span><br><span class="hljs-string">\_</span><br><span class="hljs-string">\+</span><br><span class="hljs-string">\.</span><br>等等<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p>\  </p><ul><li>_</li></ul><ul><li>.</li></ul></blockquote><h2 id="四、Markdown-的高级用法"><a href="#四、Markdown-的高级用法" class="headerlink" title="四、Markdown 的高级用法"></a>四、Markdown 的高级用法</h2><hr><h3 id="4-1-个人看法"><a href="#4-1-个人看法" class="headerlink" title="4.1 个人看法"></a>4.1 个人看法</h3><p><code>Markdown</code> 是非常厉害的，但是我认为它建立的初衷是为了方便大家记笔记写博客，它具有很强大的功能，例如流程图、复杂的公式呈现，虽然看起来很有用，但是我认为这些功能与它创立的初衷是违背的，而且做流程图和复杂的公式是有专门的工具，而且十分便捷。所以个人认为，<code>Markdown</code>的一些高级用法了解一下即可，博主也不是很会使用参考了其他资料稍微来整理一下笔记。此处只简要提一下，如果想要了解更多详细的高级用法：<a href="https://www.runoob.com/markdown/md-advance.html">菜鸟教程 Markdown 高级用法</a>、<a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C">Cmd Markdown 简明语法手册</a></p><h3 id="4-2-制作待办事项"><a href="#4-2-制作待办事项" class="headerlink" title="4.2 制作待办事项"></a>4.2 制作待办事项</h3><p>我们可以使用<code>Markdown</code>来制作一个待办事项，格式为、<code>-[]</code> 表示未完成；<code>-[x]</code>表示已完成<br>代码：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[ ] 支持以 PDF 格式导出文稿<br><span class="hljs-bullet">- </span>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率<br><span class="hljs-bullet">- </span>[x] 新增 Todo 列表功能<br><span class="hljs-bullet">- </span>[x] 修复 LaTex 公式渲染问题<br><span class="hljs-bullet">- </span>[x] 新增 LaTex 公式编号功能<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><ul><li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li><li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li><input checked="" disabled="" type="checkbox"> 新增 Todo 列表功能</li><li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li><li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能</li></ul></blockquote><h3 id="4-3-书写公式"><a href="#4-3-书写公式" class="headerlink" title="4.3 书写公式"></a>4.3 书写公式</h3><p>Markdown 支持书写公式，例如书写一个质能守恒公式。<br><code>$$</code>表示整行公式<br>代码：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>E=mc^<span class="hljs-number">2</span><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p>E &#x3D; m c 2 E&#x3D;mc^2 E&#x3D;mc2</p></blockquote><h3 id="4-4-绘制流程图"><a href="#4-4-绘制流程图" class="headerlink" title="4.4 绘制流程图"></a>4.4 绘制流程图</h3><p>代码:<br><img src="data:image/png;base64,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vUlx+2NMzAc1hyOGkzkfkvZLxr2E5nDEcDLnjbRfMu4lfEjaLxn3En6TuEUbWPKuhtUSaCMiIiIiIu94wH3oPsJQcfRjg+klXKnxtmDZLxn3EpLemNDjo6T9knEv4cMyHm1D9f1rmp4h4Up9YCmWjrIwJHyMmK0OVN+/pukZEi6sOV4AbURERERE5B0R9yLjaT9lPhniZ1yqDwoqDM96CXeR9MaMewm/JvubI114hgc1l2aeYgrmG0PCx0owQ0e68Lw4bLhQHxRUiIiIiIjIbR5wT5LemNDy2D1LxbmOowyGhN9JbBiHFt4W2CnnUtx+wMTcTWwY78NoZ4idcGbb4Toej4iIiIiIvOuLk5OTnxEREREREbmjCBERERERkQ1EiIiIiIiIbCBCRERERERkAxEiIiIiIiIbiBAREREREdlAhIiIiIiIyAYiRERERERENhAhIiIiIiKygQgREREREZENRIiIiIiIiGwgQkREREREZAMRIiIiIiIiG4gQERERERHZQISIiIiIiMgGIkRERERERDYQISIiIiIisoEIERERERGRDUSIiIiIiIhsIEJERERERGQDESIiIiIiIhuIEBERERER2UCEiIiIiIjIBiJEREREREQ2ECEiIiIiIrKBCBERERERkQ1EiIiIiIiIbCBCRERERERkAxEiIiIiIiIbiBAREREREdlAhIiIiIiIyAYiRERERERENhAhIiIiIiKygQgREREREZENRIiIiIiIiGwgQkREREREZAMRIiIiIiIiG4gQERERERHZQISIiIiIiMgGIkRERERERDYQISIiIiIisoEIERERERGRDUSIiIiIiIhsIEJERERERGQDESIiIiIiIhuIEBERERER2UCEiIiIiIjIBiJEREREREQ2ECEiIiIiIrKBCBERERERkQ1EiIiIiIiIbCBCRERERERkAxEiIiIiIiIbiPiE6gOLnyG/g+ZwhLUjqjUiIiIiIp9ExKeyrng55SPUeOup+eM1hyNGhw0iIiIiIvK+iM9SRWEt1npq/ljzyRBrLaPDBhERERERufLFycnJz9yHdcVoxzPnitkNuC4w89i9iksdR1kYEj6kocqH+AXnDHlwZLyvORwxnMy5tJ0TBhkX6gNLsXTkj48oJnPOpLj9MSbm1808dq/iQtovGfcS3lfjbUHFBUMeHBlXmsMRw8mcS9s5YZBx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bFeMByLg9GzAJUtyME2e04aTJIYgtPEBwsxfuDeOS5rE1gwz8tsfIznCLA7BTiA3Rp5LFeaBjSEYSpAc5rQ86cEkWVw29DjMsW+ULCE6lnF+AZeBhIvDRQRcNnRDdttjpAucliG5JQ1dMR6IMEuaxNYMMzJb+0iOhIitDyMiIiIi8knzcZk4PQOkgkmiW6KkOa07Tqo3zClhYqlBOuJ99EWTnBIi9mgKN8AlChNLxSGaIDrEKV0xYt1ZkjnOCK+PEdq0g9cKLm6AS+L0DJAKJoluiZLmtO44qUSYs2VeSEN3HDfAZRHuTTEY7KdvU5Qkp4Q2DpLqcZijK0aMBNEop7nEUzHCiIiIiIh88kyxWPT41MqTjveR7IyT6g3ziSik6d+0g3WPDuAGuGIyW6MkcjEGEy4OIiIiIiJXnsWnmoPbFyM09DjpAp+IzJNJst0bcAOIiIiIiPyfYvFpF3B5ZCMkB9PkucyGkyRyMQZ7w4iIiIiI/F9jisWih4iIiIiIyCWyEBERERERWQALERERERGRBbAQERERERFZAAsREREREZEFsBAREREREVkACxERERERkQWwEBERERERWQALERERERGRBbAQERERERFZAAsREREREZEFsBAREREREVkACxERERERkQWwEBERERERWQALERERERGRBbAQERERERFZAAsREREREZEFsBAREREREVkAH5fLsT28+PpuYDGdn7+eQC3ncIw9O15nH9D6mdsIBWo4lxOF3/La7w4Aq7h+3QqaEBERERH5v8GyLDzPw/M8/tCZYrHocRmdKPyW1353gGWfW8eKZs5tqkD2xd9xZOXn+PzKZs7n+Ls7+O27i+n8/PUEahERERGRPyDGGDzPY4ZlWdi2TalUwvM8qowxVHmex7lYlsXHValUWAjLsvD5fExPTzNffr+fUqmE53mcze/3U6lUKJfLLJQxBsuyGBkZoaWlhSVLlrAQxhj8fj+lUolKpcInxeIy8weu5/Pr1rGimfOrDRBat47Pr2zmQppWruPz664nUIuIiIiI/AGxLAu/38/+/fuZYYxhfHycf/qnf2Lv3r1U+f1+JiYmeO+99zgX27YZHx9nYmKCiYkJJiYmmJiYYGJigomJCaamppiammJycpKJiQkmJiaYmJhgYmKCyclJJicn+d3vfkepVGIhjh49yj/+4z9y6NAhLsay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OnQI27a54447uP3225lhWRY333wz51JbW0ulUmHt2rV89rOfZdGiRRw9epTZPM/j8OHD7Nmzh6NHj9LY2Ijf7+fEiRN0dHTQ0dHBjGuuuYaenh4ikQg+n49LtXr1av76r/8av99PValU4oknnmDXrl1MT09TV1dHW1sbra2ttLW18c4779DR0YFlWbz++utMT09z4403cjl99rOf5Xw6Ozu57bbbuO2226itrWUhmpqa+N73vkdrayv/03yIiIiIyBx1dXVMT08zNTXF/v37aW9vx+/3s3//fp599ln27t3Lww8/jDGGqsWLF/PKK6/gOA6VSoXGxkZs22ZycpI33niDX/ziF6xevZprrrmGGStWrKCxsZGjR49SNT09TT6f5z//8z/J5/Pcd999rFixgvloa2tjamqKUqnEfDQ2NuI4Dq+99hrLly+no6OD5uZmampqMMYwNTXFrl27cByHlpYWzva1r32N2YwxeJ7HjEqlQjKZZHp6mjvvvJO2tjaOHDnCT3/6UzZs2IBt28x200038XH4/X5meJ7Hrbfeyu23305bWxv19fXMNj09TVNTE0eOHOGpp57i9ttvp6mpiQsxxmDbNpeDZVncfffdfFytra3M8Pv9fOMb36CmpoYrzYeIiIiIfMS1115LNpslnU4zPj7OxMQEk5OTXHXVVfzZn/0ZwWCQGXV1ddxyyy08//zz/Nu//RvlcpmpqSnGx8dpamrii1/8IrfffjvGGCqVCrlcjh//+MecrbGxkY6ODr761a9y1VVXMaNSqZDNZpmcnOR8pqenee655+js7GQ+Fi9ezF133cVLL73Ef/3XfzE5OYnneRSLRUqlEoFAgHvvvZeWlhYuxrIs2tramO273/0ujY2N2LaNZVkcOHCAw4cPY9s2l8oYw6VYuXIl52LbNk1NTRw/fpwf/OAHLF26lHXr1mFZFsYYjDFUKhUmJiaYraWlha985Sv4/X5m8zyPCzHGUFUul5kvYwye51EqlZivSqXCM888w9DQEPPlui7lcpmPy4eIiIiInFMoFCIUCnHkyBEmJiZobm6msbGRc6mtraW7uxvP8zh8+DBTU1PU19fT2trK2bq6uti8eTOXIhKJEIlEOJ8VK1awefNmLoXf7+f222/n9ttvp1gsUiwWMcbQ0tJCbW0t81GpVJienua+++6jyrZtqhYtWsSMcrlMJpNh+fLlLIRlWVQqFSzLYiGMMfj9fqp2797Nj370I1paWtiwYQO2bVM1MTHBiRMnGB0dZd++fTQ3NzPj2LFj/PCHP8QYw4z169dTLBapq6vjbJZlYVkWxhiKxSIHDhzAtm0uxOfzUalUMMZQLBYpFAr4/X7mo1wuUywW+eY3v8l8LVmyhFdeeYWPy4eIiIiIXFBrayutra3MhzGGRYsW8b9NY2MjjY2NLERDQwM/+9nPeOKJJziXSqXC5OQkX//617kU5XKZ119/nXK5TLlcxrIsFsLzPPL5PENDQ2SzWcLhMPfffz+1tbVUVSoV3nrrLZ555hmMMaxZs4ZVq1ZRVS6X2b17N8uXLycWizHDsiyGh4epq6vjbJVKhdHRUXbs2MGePXuoq6vjqquu4kLK5TJvvfUWb7zxBrlcjtraWlasWMHFlMtlXn31Vfx+P47jcCn27NnDihUr+DhMsVj0EBERERH5mIrFIuVymXOxbZvGxkYuVbFYZHJykvb2dowxfByvvvoqixYtorOzk7NNTEwwPj5Oa2srPp+P2XK5HFNTU3zmM59htpGREZqbm1m2bBlnO3ToEK+++iptbW185jOfobGxkYvZtWsXIyMjLF68mOuvv56mpib+0JliseghIiIiIiJyiSxEREREREQWwEJERERERGQBLERERERERBbAQkREREREZAEsREREREREFsBCRERERERkASxEREREREQWwEJERERERGQB/j/IRVupwnNgUwAAAABJRU5ErkJggg=="><br>效果：</p><p>Created with Raphaël 2.3.0 Start Your Operation Yes or No? End yes no</p><h3 id="4-5-绘制序列图"><a href="#4-5-绘制序列图" class="headerlink" title="4.5 绘制序列图"></a>4.5 绘制序列图</h3><p>代码：<br><img src="data:image/png;base64,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"></p><p>效果：</p><p>Alice Bob Hello Bob, how are you? Bob thinks I am good thanks! Alice Bob</p><h3 id="4-6-绘制甘特图"><a href="#4-6-绘制甘特图" class="headerlink" title="4.6 绘制甘特图"></a>4.6 绘制甘特图</h3><p>代码：<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA4MAAAH8CAYAAABrfHrHAAAgAElEQVR4AezBb2hciWHv/e8OguNsOj3DjYKsEeS4PGqwUbmnA36ITW+aqHjMIYUtwYaqwTADh60TcMiw2zIMDBkmDAyCrBg1gqxjDp0ppihgvWheLAeNy9KQ1IbuZXK2CPsWPeBzi0YSUds5d6pEB1L24byY51FV+c863l3b8/t8Xtnf3/8AERERERERGSspREREREREZOykEBERERERkbGTQkRERERERMZOChERERERERk7KURERERERGTspBAREREREZGxk0JERERERETGToqn9O//5//wDz/5CRu9Hge//CXH+dWvfsU/bWzwDz/5Cf/y85/zMP/y85/zDz/5Cf+0scGvfvUrxkEcxywuLuJ5Ho/i+z6vv/46YRgiIiIiIiLyrEzwlH7jN3+T//t//A/+5ec/5x//5//kzH//7/zGb/4mh01MTPD5uTkOfvlL/p/794l/+Uuyn/scR33ms5/lM5/9LP3//b/5X//4j/xfp09z4lOf4mVmGAblchkREREREZFPwgS/ps989rN85rOf5VFOfOpTzOVyPE72c58j+7nPISIiIiIiIh+tCV4AURRRr9f54he/yD/90z/R6/VI5HI5SqUSN2/epNvtkshms9RqNUzTZCSKIur1Ov1+n0Q6naZarWJZFokoiqjX63zxi1/knXfeYTgcks/nSezt7fH5z3+eH/7whyTS6TTVapXBYECz2WSkUqlg2zYjURRRr9fp9/uM5PN5XNclEccxrVaLyclJXNdlxPM8ut0uiWw2y9mzZxEREREREXnWUrxAfvjDH+I4DqurqywuLrK5uUmhUGBmZobV1VU6nQ5TU1O8/fbbxHFMIgxD/uzP/oy5uTlWV1dZXV3l0qVLNBoNwjDksHfeeYdqtcrq6iqu65Lo9Xr867/+K6urq3Q6HWZnZymXy/i+T6fTYXV1lWKxyMrKCmEYkoiiiHq9zsWLF1ldXWV1dZXFxUXu3r2L7/scJ45jFhcX2djY4Pr166yurlIoFPjRj36EiIiIiIjIs5biBZLP57Ftm8TJkyeZnZ0ll8sxPz9PwjAMbNtmd3eXg4MDErdv3yadTnP58mVG5ufnmZ2dZXV1lTiOGTl37hyWZXFYNpvl8uXLJAzDwLZt0uk0CwsLGIZB4syZMyQGgwGJO3fukDh//jwjlmVx7tw5giAgjmOOun//Pr1ej0KhgGmaJGzbplgsIiIiIiIi8qxN8AKZmZnhw4iiiI2NDebm5jBNkxHDMLBtm/X1dQ4ODhiZmZnhqKmpKU6cOMGH4TgOjuOQCMOQRqPBcDgkkcvlOM729jbZbJZTp05x2PT0NCIiIiIiIs/aBGOg2+3S7XY5KpvN8lGIooh6vU6/3yeRz+dxXRfP89jb2+M4W1tbHCeTyZBOpxEREREREXmWJhgDxWIRx3F4mCiKeJZu3bpF4vr165imyZOYmZlhY2ODowaDAcPhEBERERERkWcpxUvMNE3m5uYIgoA4jjnM8zwWFxeJ45hnKY5j9vb2mJqa4sSJE4xEUcTGxgYPMz09Tb/f58GDBxy2vb2NiIiIiIjIs5biJXfhwgU2Nze5efMmI0EQ0O12cRwHwzB4lgzDYHJyks3NTXZ2dhi5desW/X6fh7Ftm3w+T6fTIYoiEmEYsra2hoiIiIiIyLM2wUvOsiy++93vUq/XWVhYIJFOp1lcXMSyLD4KruuSKJfLjBSLRYrFImtra+zs7HDy5EmOcl0Xz/O4evUqiXQ6zVe+8hXeeecdREREREREnqVX9vf3P0BERERERETGSgoREREREREZOylERERERERk7KQQERERERGRsZNCRERERERExk4KERERERERGTspREREREREZOykEBERERERkbGTQkRERERERMZOChERERERERk7KURERERERGTspBAREREREZGxk0JERERERETGTgoREREREREZOylERERERERk7KQQERERERGRsZNCRERERERExk4KERERERERGTspREREREREZOykEBERERERkbGTQkRERERERMZOihdEHMd873vfIwxDRsIw5Hvf+x5xHCMiIiIiIiJPLsUL4v79+7z//vscdvv2bX7xi18gIiIiIiIiH04KERERERERGTuv7O/vf8BT8n2fdrtNIp1Oc+XKFW7evMm1a9ewbZtEFEXU63X6/T4j+Xwe13VJxHFMq9VicnKSmZkZ2u02iXQ6TbVaxbIsfN+n3W4z8gd/8Af827/9G71ej5FKpYJt24iIiIiIiMjjTfCUPM/j7t27LC4uYlkWYRjSaDQYDoeMRFFEvV7n4sWLOI5DIgxDGo0GMzMzOI7DSLfbpVgssrq6ShzHtFotlpeXqdVq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ZwfLsngSURRRr9eZm5vDdV2Oc+fOHfr9Pv1+n0KhwFHFYhHHcTAMg3K5jOd5XL16lUQ6naZarWJZFh+GZVl897vfpV6vs7CwQCKdTlOtVrEsi0cxDINyuYzneVy9epVEOp2mWq1iWRYjrusyMzNDuVxmJJ/P47ouj3Lnzh36/T79fp9CocBRxWKR8+fPs76+TqLZbHJUNpulVqthmia+77O2tka1WsWyLI5j2zaLi4s0Gg2GwyGJbDbL9evXMU2TEdd18TyPq1evkkin03zlK1/hnXfeQURERESerVf29/c/4CUSBAGdTodarYZpmoRhiOd5vPnmm5imSRAEdDodarUapmkShiGe5/Hmm29imiaPEgQBnU6HWq2GaZocFoYhjUaDS5cu4TgOURRRr9dJ1Go1TNMkjmNarRa9Xo+RdDpNtVrFsiyOEwQBnU6HWq3GnTt3CIKAUqmEYRiMxHFMq9XCtm0cx2HchGHIT3/6U772ta8hn4y//uu/5vd+7/ewLAsREREReTFMMKZ+9rOf8f3vf59EPp/HNE2OEwQBzWaTkWKxiGmaHGVZFjdu3CARBAHNZpNisYjjOIwYhkG5XOZpRFHE3//93+O6LoZhIP+/e/fu8d/+239DPhlRFPHP//zPZDIZREREROTF8cr+/v4HiLyg4jjm5s2bXL58GdM0kY9fEARsb2/jOA4iIiIi8uJ4ZX9//wNERERERERkrKQQERERERGRsZNCRERERERExk4KERERERERGTspREREREREZOykEBERERERkbGTQkRERERERMZOChERERERERk7KURERERERGTspBAREREREZGxk0JERERERETGTgoREREREREZOylERERERERk7KQQERERERGRsZNCRERERERExk4KERERERERGTsp5KHiOOZ73/seYRjyNHzfx/M8Hsb3fTzP41F832dxcZE4jvl1+L7P4uIicRyTiOOYxcVFgiBARERERETGzwQviTiOabVa9Ho9nlY+n8d1XUbu37/P+++/z2uvvUYURdTrdfr9Pg+Ty+UolUoYhsHD+L5PEASUSiWehud5dLtdHqVYLOI4DiNRFLG+vk6hUMAwDERERERERCZ4SRiGQblc5sPwPI+9vT1KpRKGYXBYGIasrKxw7do1LMsisbS0xK8jjmOCIMC2bQzD4Gnl83lc1+U4nudx1K1b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QqHA+vo6N27c4M6dO1y9epVz585xUKFQYH9/n62tLebm5jiKMYYPP/wQ27bZ3t5menqan//851y9epWVlRUyy8vLeJ7HQZOTk5w+fZozZ84wOTnJo0ePsG2b5eVlnjx5gm3bWJbFQcPhkMzS0hKO4/C6CoKAmzdvkiQJz+I4DktLS9y9e5eFhQUWFhbY2tri448/xrZtxjzPY2ZmhuvXr7OwsECr1eInP/kJIiIiIiLyak5xjO3v77Ozs0OlUsF1XeI4ptVqcfXqVVzXJY5jxvr9PlNTUzx48IDMuXPnyExNTRFFEWmaYoxhLE1Tv9NFIgAAIABJREFUoijCcRyMMbiuS7/f58GDB7iuy0Gbm5uMGWOo1WqMJUnC1tYW5XKZw2zbZnl5mUwQBHS7XcbK5TIHlctlDiqVSniexw+B53m8DNu2uX37Ni/ieR6e53HQT3/6U0RERERE5OW9sbe39xXHTBAEzM3N4TgOY0mS0Gw2KZfLOI5DJk1TfN+n1+uRy+X41//6X/Of/tN/wnEcXNclkyQJzWaTwWDAYbOzs1SrVYwxHBYEAd1ul0wul+NP/uRP+M//+T/T6/V4kXq9juM4iIiIiIiIfFve2Nvb+woRERERERE5USYQERERERGRE2cCEREREREROXEmEBERERERkRNnAhERERERETlxJhAREREREZETZwIRERERERE5cSYQERERERGRE2cCEREREREROXEmEBERERERkRNnAhERERERETlxJhAREREREZETZwIRERERERE5cSYQERERERGRE2cCEREREREROXEmEBERERERkRNnAhERERERETlxJhD5/6RpytLSElEU8TLSNOXXv/41cRxzUJIk3Lx5kzAMERERERGRH6ZTyPcqSRKazSaDwYDnKRaLNBoNLMsiSRKazSaDwYCXUSwWaTQaWJbFi/z+7/8+7Xaber2O4zg8jzGGf/7P/zkrKys0Gg0syyLz4MEDMpcuXUJERERERH6YTnGCpGnKX/7lX/LHf/zH2LZNmqb4vk+hUMDzPL5NcRzTarUYjUYcVKlUWF5eZiyKIlZXV1lcXMS2bZ6nUqngui7PE0URa2trHBQEAd1ul+dpt9scpVKp4LouY47jMDMzw9OnT3EchyRJ2NjYYDAYcP36dY5SLBZpNBpYloWIiIiIiHw/TnGCPH78mP/xP/4Hf/zHf0zGGEOtVuO7YNs2t2/fJk1TfN/HdV0cx+Gwzc1NLl68iG3bfJtKpRKe5/EqgiAgkyQJzWaTwWDAWLfbJZfLkcvlmJycpN1uY4xBRERERER+mE4h37sgCOh2uxzU7XYZy+VyLC4uYts237QgCMh4nsdYHMcEQcBHH32EZVkcZlkWy8vLhGFIv9/H8zwycRyzsrLCwsICxhgyYRjS7/fxPA8REREREfnhOMUPQBzHtFotRqMRY/V6HcdxGEvTFN/36fV6jNXrdRzH4aAwDOl0OoxVKhVc1yUMQzqdDplarUapVOLdd9/F930KhQKe5zEWhiGdToexUqmE53mMhWHIxsYG5XKZ1dVVRqMRmUqlguu6fB2lUgnP8zgsjmNWVlY4SqfTodPp8CLFYpGDPM9jzPM8giBgYWGBer2O4zg8i+d5PI9t2ywvLyMiIiIiIj98p/iexXFMq9Xi6tWruK5LJooiVldXWVxcxLZtkiSh2WwyOTnJ2toaxhiiKKLdblOv13Ech0wQBDx8+JClpSVs2yaOY1qtFhnXdTl79iyrq6ssLi5i2zZpmnJYEAQ8fPiQpaUlbNsmSRKazSZLS0tUq1WMMWQGgwFhGLK6uooxhjAM6XQ6nD17Fsdx+LrSNMX3fVzXxXEcnqdSqeC6Ls8TRRFra2s8j+d5XLt2jWazSblcJp/P87K63S7dbpdMqVTC8zyCIGBqaopMp9Mh0+12GavX6ziOg4iIiIiIfH8m+J4Nh0MyFy5cYMxxHG7fvo1t22QePHjAaDRiYWEBYwwZx3EolUqsra2RJAlxHPPw4UM++OADbNsmY9s2V69eJYoi0jTlReI45uHDh3zwwQfYtk3GsizK5TK9Xo/Hjx8zlsvlWFhYwBhD5tKlSxSLRba3t3kdJEnCzZs3iaKIjGVZLC8v4zgOw+GQL7/8khfp9/uUSiXW19cplUrs7u5y8+ZNut0unU6HTKVSoVQqsb6+zq1bt/in//Sfks/nERERERGR79cE37Nz586Ry+Wo1WoEQcBhaZoSRRHT09OcOXOGg+bm5hiNRgyHQ4bDIZl8Ps9BrutSq9UwxvAiw+GQTD6f56Bz585RLBbZ3t5mLJfLkc/neZ396Z/+KWtraywtLZGmKV/H1NQUY4VCgeXlZUqlEpVKBdd1OWg4HPLll18iIiIiIiLfv1N8zyzLYnl5mSAI6Ha7dLtdMqVSCc/zGOv1epTLZQ7L5XJktre3+V1tb2/zu+r3+3xXOp0OnU6HFykWixxmWRaZ5eVlwjDE932q1SrGGLa3t5mcnOT06dO8iqmpKV7knXfeIZ/PIyIiIiIi369T/EB4nofneWTCMKTT6ZB59913yZRKJTzP41kePXrE7+rs2bN83/b399nb2yOfz/MilUoF13V5niiKWFtbYyxJEprNJoPBgMPK5TIHlctlDisWizQaDU6fPs3u7i5zc3O8yO7uLjdv3mQwGFAqlbAsCxERERER+X6d4gfo8uXLRFHE7u4uGcdx2NjYIEkSLMtiLAxDNjY2aDQaXLhwgcxwOMS2bcaiKGJ1dZXFxUVeJJ/Pk3n06BG2bTP29OlTBoMBZ8+e5ZvSbrfJzM7O8tZbb/HWW2+Refr0KV9++SX5fJ5vg2VZLC8v8yxBELC1tUWj0cCyLJ4lSRL29vbI5/Okacru7i5TU1McpVAoUKvVEBERERGRH44JvmdRFLGwsEAURYx98cUXPHnyBMdxMMZw6dIlMp9++ilpmpKJ45i7d+8yPz+PZVnYts3FixdZXV0ljmMySZKwtrbGxYsXsW2bfD5PZjgcchTbtrl48SJ3794ljmMySZKwtrbG7Ows58+f5+uK45j33nuPcrlMZm1tjfX1dWq1Gh9++CGe55GmKWEYMhgMuH79OlEUYds2y8vL2LbNty0IArrdLoPBgOvXr7O0tESaphzl6dOnvP3225w5c4ZXkSQJN2/eJIoiRERERETk+3OK75njONTrddrtNgdVKhVc1yVjWRbtdhvf9ymXy4zV63Ucx2HM8zympqao1WqMVSoVXNclc+bMGaanp2m328zOzvKLX/yCwzzPY2pqilqtxlilUsF1XX4Xtm1z+/ZtniVNU3zfp1AosL6+ThzHtFotpqenqVarGGP4tsRxTKvVIpfLcevWLSzLIk1TfN+nXC5TKpXwPI+xNE0JwxDHcTDGkCQJOzs7nD17lrF+v0/GdV0OGg6HvPPOO5w7dw4REREREfn+vLG3t/cV8r0Kw5BOp0OlUsF1XcbSNMX3fZ48ecLi4iK2bZNJkoRms8lgMOBlFItFGo0GlmVxUBiGdDodMvV6HcdxOCxNU3zfp9frUalUcF2XOI75/PPP+Zf/8l/yZ3/2Z4xGI2ZnZ6lWqxhjSJKEZrPJYDDgKJVKBdd1ERERERGR788be3t7XyHfiziOabVaTE9PU61WMcZwlCiKWFtbo9FoYFkWSZLQbDaZn5/HdV2eJ4oi1tbWaDQaWJZFkiQ0m00GgwGVSgXXdXkZaZri+z6FQgHP8xARERERkdfbG3t7e18hIiIiIiIiJ8oEIiIiIiIicuJMICIiIiIiIifOBCIiIiIiInLiTCAiIiIiIiInzgQiIiIiIiJy4kwgIiIiIiIiJ84EIiIiIiIicuJMICIiIiIiIifOBCIiIiIiInLiTCAiIiIiIiInzgQiIiIiIiJy4kwgIiIiIiIiJ84EIiIiIiIicuJMICIiIiIiIifOBCIiIiIiInLiTHAMBUFAFEW8ztI0JQgCkiTheYIgIAgCREREREREXsUpjrkgCOh2u4z97Gc/4ze/+Q29Xo+Dcrkci4uLDIdD2u02X0exWKTRaGBZFnEc8/nnn/Pzn/8cYwxjQRDQ7XY5rFgs0mg0sCyLsd3dXT799FOq1SrGGERERERERL4ppzgB6vU6juMQBAFvvvkmtVqNTJIkfPLJJ3ieh23bZGzbZn19nYOiKCIMQ6rVKsYY4jgmCAI++ugjLMviKG+++Sb/8A//QL1ep9FoYFkWY5VKBdd1GYvjmCAIOMgYQ7Vaxfd9fN+nWq1ijOF1lKYpvu/T6/UYq1QquK7LQWma4vs+vV6PTLFYpNFoYFkWR4njmJWVFW7cuIFt2xyUpim+79Pr9Rir1+s4jsOLpGmK7/v0ej0yxWKRRqOBZVlkoiii3W7zLJVKBdd1eZ44jmm1WoxGIzKlUgnP8zgoCAK63S6H1et1HMfhmxbHMa1Wi9FoxEGzs7NUq1WMMRwlSRKazSYzMzN4noeIiIiIvB5OcQJFUUQYhvyrf/WvOEoYhnQ6HQ4rl8scdP36dcZyuRyLi4vYtk3mRz/6Eb/61a/wfZ8HDx7gui5JkrC1tcXc3BwvwxjDwsICn3/+Oa+rJEloNptMTk6ytraGMYY4jmm1WvT7fTzPI5OmKb7vUygUWF9fJxMEAc1mk0ajgWVZHJQkCSsrK4xGIw5LkoRms8nk5CRra2sYYwjDkHa7Tb1ex3EcniVNU3zfp1AosL6+TiYIAprNJo1GA8uycByH9fV1DkrTFN/32dnZ4dKlSzxPHMe0Wi0++OADHMchSRKazSZBEOB5Hpk0Tdnd3aVUKuF5Ht+F4XBIZmlpCdu2EREREZHj7RTHSBAEdLtdMt1ul2KxyOTkJO12m7FKpcL29jaFQgFjDM9SKpXwPI9MFEWEYUi1WsUYQxzHBEHARx99hGVZJEnCJ598wmHGGGq1Gpk4jmm1WkxPT3P+/Hlelm3bfPjhh7yunj59ymg04saNGxhjyNi2zdWrV9nY2CBJEizL4v79+zx58oSFhQXGrl27xtbWFg8ePMB1XcaiKKLdbpPJ5XIc9uDBAzLvv/8+xhgyly9fJooiNjc3cRyHZ7l//z5PnjxhYWGBsWvXrrG1tcWDBw9wXZej3L9/nydPnrC4uIhlWTxLmqasr68zPT3N+fPnyViWRblcZnV1lStXrmDbNvv7++zs7OC6Lt+V7e1tpqenOXPmDCIiIiJy/E1wjHiex61btygWi9TrdZaXlykUCtTrddbX1ymVShw0HA7J5PN5vk1JkrCyssLFixep1WoYYzjozJkzvP3221y/fp2FhQXCMOR1Fccx7733HmEYknEch9u3b2PbNoeNRiOGwyGZfr/P9PQ0Z86cYcyyLGZmZoiiiDRNyURRRLvdplKpUK/XOSxNU6IoYn5+HsuyGDPGUKvV8DyP5+n3+0xPT3PmzBnGLMtiZmaGKIpI05TDkiRhY2ODixcvYts2z7O/v8/Ozg6O42CMYezcuXPkcjkePXpEZjgcksnn83xX+v0+hUIBYwzPE8cx7733HgsLCywsLPBXf/VXiIiIiMjr5xTHzHA4ZDQa8Tz9fp+pqSm+DWma4vs+vV6PTKlUwvM8lpeXeRZjDLVajbEkSbh58yaDwYBMqVTi3Xffxfd9er0eR+l2uxxUKpXwPI/vmm3b3L59mxfp9/vkcjny+TxpmrK7u0uhUMAYw2E7Ozvs7+9jjMFxHNbX18lEUcRh+/v77OzscPbsWcIwpNPpkMnlciwuLmLbNs+Spim7u7sUCgWMMRy2s7PD/v4+xhgOevDgAaPRiCtXrvAiw+GQ0WjE2bNnOUq/3yfz6NEjRqMRKysrDAYDMrlcjsXFRWzb5puWJAlbW1u8/fbbLCwsMFYqlfA8j7Eoimi321QqFVzXJU1TfN9nMBgwMzODiIiIiLw+TnHMPHr0iNFoRLvdplKp8CydToex69evk6nX6ziOQ6bb7dLtdjmoXC5z0PXr1xnL5XJkjDHUajUyQRAwFscxrVaL0WjEs8zOzlKtVrEsi+XlZTJhGNLv9zHGUKvVOCwIAjKe5/G6iKKIbrdLpVLBsizSNOVZpqam2Nra4mUNh0NGoxHtdptSqcT6+jqZMAyp1WrU63Ucx+FVTU1NsbW1xWFJkrCxscHFixexbZuv6/Tp00xOTjLW7/fJ3LhxA9u2yYRhSK1Wo16v4zgO36ThcMhoNGJmZoZ/9+/+HZkkSWg2mywtLVGtVsmEYcjs7CyXL18mY4zh/fffp9lsIiIiIiKvl1McI2ma0u/3mZ2d5Y/+6I/4m7/5G3q9Ht1ul7FKpYLneXieRxRFhGFItVrFGMNBpVIJz/PIxHHMysoKN27cwLZtDkuShE8++YTnsW2bq1evEkUR1WoVYwxjaZri+z6FQgFjDMdZHMesrq4yOzvL5cuX+bbMzs7y7rvvMnb58mWiKCIMQ86fP48xhm/C06dPGQwGlMtlvkme5+F5HgddvnyZKIoIw5Dz589jjOGbYts2t2/f5iDLsiiXy7TbbR4/fsy5c+fY2dlhfn4eYwxjp0+fZnJyEhERERF5vZziGPniiy948803KRQKnD59mlqtRhAEzM3N4TgOQRBw0ObmJoVCAWMMB7muy0H37t1jZmYG27Y5imVZ/Nt/+295kUuXLrGxscHjx49xHIex+/fvs7Ozw/vvv89xFscxrVaL6elpqtUqxhhepN/v83UUCgWMMYwZY3Ach42NDfb397lz5w7dbpexYrHIn/7pn/Is/X6fo2xublIsFjl37hwHxXFMq9ViNBoxVqlUuHDhAkfZ399nZ2eHQqHAsxhjKBQKbG1tsb+/jzGGb1s+nyeXy7G9vU0+n2c0GnGYMYZCoYCIiIiIvF5OcYzcu3ePubk5Njc3OSyKIjKu65KJ45iHDx+Sy+VIkgTLskiShGazyWAw4CjdbpcXKZVKeJ7HUSzLYn5+nrW1NRqNBpZlEccxd+/e5YMPPsCyLI6rKIpot9vMzs5SrVYxxjBmjKFQKLC7u0uaphhjOGhycpLTp0/zMvL5PLlcjhfxPA/P8zisUCiwu7tLmqYYYzhocnKS06dPM5YkCVtbW8zMzGBZFgfZts3t27c5LEkScrkc29vbOI7DYVNTU/xQ5fN5crkch6Vpyu7uLoVCARERERF5fZzimEjTlN/7vd/j/PnzbG5ucpjjOGxvbxOGIa7rcu/ePUajEblcjjHLslheXmYsjmNWVla4ceMGtm1zUJIkNJtNZmZm8DyP50nTlL/+67/mJz/5Ca7r0u/3aTablMtlVldXuXr1Ko7jcFxFUUS73aZUKuF5HkeZmppia2uL/f19jDFkkiRha2uL+fl5jDG8DMuymJmZYWtriyRJsCyLTJqmRFHEzMwMlmXxLFNTU2xtbbG/v48xhkySJGxtbTE/P48xhrHhcMhoNGJubo6Xdfr0aSYnJ+n3+xz09OlTRqMRFy5cIE1TfN8nU61WMcaQSdOU3d1dZmZmsCyLb1IURbTbber1Oo7jMDYcDslcuHCB06dPMzk5SRRFXL58GWMMmf39fXZ2digUCoiIiIjI62OCY8IYw09/+lOMMRy2v7/P0tISnU6HjY0N/vZv/5aHDx/yi1/8gnfeeYdMGIYsLS2RpimZOI5ptVoMBgNqtRpBEDAWxzG//OUvmZmZwfM8nqfb7VIul/m7v/s79vf3ybz77rtMTk7Sbre5evUqruvyMtI0JQgCkiThdRHHMaurq5RKJTzP41kuXbpE5tNPPyVNUzKfffYZmUuXLvEqrly5wmg04rPPPmPs/v37PHnyhCtXrvA8ly5dIvPpp5+SpimZzz77jMylS5c4aDgcksnn87wsYwyu69LtdgnDkEySJKytrXHx4kVs28YYg+u69Ho97t+/z9idO3d48uQJV65c4Zt2/vx5ZmdnWVtbI0kSMnEcs7q6ysWLF7FtG2MMCwsLPHnyhPv37zP22WefMRgMEBEREZHXyymOsTRN2d3d5c///M8plUqsr68TxzGtVourV69y7tw5DioUChhjyNi2ze3bt8mkaYrv+ywsLDBWqVRwXZdnSdOU3d1dMpVKBdd1ycRxTKvVIvPjH/+YTqdDFEVUq1WMMTxLGIZ0Oh2KxSLXrl3jhyqOY1qtFlevXsV1Xe7du8doNKLb7dLtdjmsXq/jOA6WZdFut/F9n3K5TKZYLNJoNLAsi1dh2zYff/wxzWaThYUFMrlcjsXFRWzb5nksy6LdbuP7PuVymUyxWKTRaGBZFgdtb2/zdTiOw9LSEq1Wi06nQ6ZUKuF5HmOO47C0tESr1aLT6ZApFot8/PHHWJbFq4jjmFarxdWrV3Fdl6MYY6jVagRBwPXr1xmrVCq4rsuYbdssLi7SarXodDpkfvzjHzM7O4uIiIiIvF7e2Nvb+4pjJggC5ubmOHfuHM1mk/n5eVzXJY5jWq0WV69exXVd4jgmCAI++ugjPvvsM6ampnBdl4PSNMX3fXq9HplSqcTU1BSdToexer2O4zgclCQJn3zyCZ7nYds2YRjS6XTIVCoVXNclk6Ypvu/T6/UoFos0Gg0sy2IsCAK63S65XI7FxUVs2+agIAjIeJ6HyLNEUcT29jau6yIiIiIiknljb2/vK46ZIAiYm5vDcRzGkiSh2WxSLpdxHIdMmqb4vk+v1yOXy7G4uMhwOKTdbjOWy+VYXFzEtm2OkiQJzWaTwWBAvV7HcRwOStMU3/d58uQJi4uL2LbNUdI0xfd9er0elUoF13VJkoRms8n8/Dyu63KUIAjIeJ6HyLMEQcDc3ByO4yAiIiIiknljb2/vK0Tk2EqShM8++4x3330XYwwiIiIiIpk39vb2vkJEREREREROlAlERERERETkxJlARERERERETpwJRERERERE5MSZQERERERERE6cCUREREREROTEmUBEREREREROnAlERERERETkxJlARERERERETpwJRERERERE5MSZQERERERERE6cCUREREREROTEmUBEREREREROnAlERERERETkxJlARERERERETpwJ5EhJknDz5k3CMEREREREROS4meAYSZKEIAhI05SD4jjm17/+NWmaclgQBERRxGFPnz4lc+nSJb4PaZoSBAFJkvA8QRAQBAEiIiIiIiKv4hTHSJqmxHGM7/tUq1WMMWTOnDnDb3/7W+7cuYPneYyFYcjW1hb/7J/9Mw5K05QwDJmfn8eyLDJBENDtdnme2dlZqtUqxhjiOObzzz/n5z//OcYYxoIgoNvtclixWKTRaGBZFmO7u7t8+umnVKtVjDGIiIiIiIh8U05xjPzoRz/io48+otlscufOHTzPI2OM4f333+eTTz4hjmNs2yYMQzY2Nmg0GliWxUGPHz8mc/nyZQ4qlUp4nkcmDEP6/T6e55EJw5Aoihh78803+Yd/+Afq9TqNRgPLshirVCq4rstYHMcEQcBBxhiq1Sq+7+P7PtVqFWMMr6M0TfF9n16vx1ilUsF1XQ5K0xTf9+n1emSKxSKNRgPLsjhKHMesrKxw48YNbNvmoDRN8X2fXq/HWL1ex3EcXiRNU3zfp9frkSkWizQaDSzLIhNFEe12m2epVCq4rsvzxHFMq9ViNBqRKZVKeJ7HQUmS0Gw2GQwGZIrFIo1G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5NChQ+zevZtwOExBOBxm9+7dPP/881y+fJkdO3ZwPT/72c/o7++noqKCTCaDbdsUlJSUEIlEmKqtrY3Ozk52795NOBxmJjt27GC22traOHz4MHlVVVWsXbsWIYQQQgghhJgrk3mspKSEnp4eDh06xOOPP853v/tdJiYmmO7ee+9lZGSEtrY2vvzlLzPdyMgIiUSCZ599ll/96lek02ls2yYvFouRF4lEmGrHjh3crHg8zt/+7d/S0NBAY2MjeZlMhj179jA0NMTLL79MOBymo6ODF154gWAwiBBCCCGEEELMhck8EovFyItEIvT09DA5OcmqVavYuHEjeXv37uVG4vE405WXl/Pcc8+RyWR499136enpoaWlhbwzZ84QCATw+/3MVSaTYc+ePZw4cYJgMMhf/dVfYds2eWfPnuXEiRPs2rWLcDhMXktLC0888QT79u1DCCGEEEIIIeZCM88MDAzw9NNP88ILL9Df38/zzz9PPB6noLe3l507d9Lb20tePB5n586dHDx4kBuxbZuWlhaOHTtGXiaToaOjg5aWFmzbZq5s2+a5556jvb2db33rWzz33HMcPHiQvIGBAaqqqqivr2eqyspKhBBCCCGEEGKuNPNIXV0de/fupb29nfb2dnbt2kVePB5n586ddHR0sGjRIioqKojFYuTFYjHyVqxYwVSxWIydO3dy+PBhplq3bh29vb309vZy9uxZzp8/z4oVK/h9aWlpYfPmzRw6dIh4PM7ly5eZSSQSIRgMIoQQQgghhBBzofkE8Pv9VFRUcOzYMWzbpry8nGPHjpF35swZmpqaqKurIy8WizEwMMALL7zA448/zubNm5kqHA6zfv162tra2LdvH/fccw91dXX8oVRXVzOTWCzGxMQEQgghhBBCCDEXmnmmo6ODRx99lKeeeooLFy6QZ9s2LS0tjIyMkMlkqK6uZmRkhHg8TkdHB2vXrqUgFosRDAZ5+eWXaWlpYSbr1q1jcnKSyclJvvzlLzMXmUyGF198kba2NqbKZDKMjIxQUVGB3++nsrKS/v5+enp6mGpgYAAhhBBCCCGEmCvNPBGPx9m5cyfHjh2jvb2dvXv3snTpUgpWrFjB0NAQg4ODrFixgqGhIX7729+SSCSor6+noKWlhZdeeolwOMxMOjo6ePrpp6moqGDJkiU8//zzxONxbpZt27S2tnL48GE6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"></p><p>效果：</p><p>2016-06-26 2016-07-03 2016-07-10 2016-07-17 2016-07-24 2016-07-31 需求分析 可行性报告 概念验证 概要设计 详细设计 编码 测试 发布 验收 项目确定 项目实施 发布验收 项目开发流程</p><blockquote><p>如果感兴趣可以去 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C">Cmd Markdown 简明语法手册</a>这里学习更多。</p></blockquote><h3 id="4-7-Html"><a href="#4-7-Html" class="headerlink" title="4.7 Html"></a>4.7 Html</h3><p>Markdown 支持原生<code>HTML</code>语法，譬如，你可以用 Html 写一个纵跨两行的表格：<br>代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>值班人员<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期一<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期二<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期三<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>李强<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>王平<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p>效果：</p><table><tbody><tr><th rowspan="2">值班人员</th><th>星期一</th><th>星期二</th><th>星期三</th></tr><tr><td>李强</td><td>张明</td><td>王平</td></tr></tbody></table><p>也可以实现对字体格式的改变</p><p>代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;font <span class="hljs-attribute">face</span>=<span class="hljs-string">&quot;楷体&quot;</span> <span class="hljs-attribute">color</span>=#00ffff <span class="hljs-attribute">size</span>=5&gt;改变文字格式&lt;/font&gt;<br></code></pre></td></tr></table></figure><p>效果：</p><blockquote><p>改变文字格式</p></blockquote><h2 id="五、Markdown-工具"><a href="#五、Markdown-工具" class="headerlink" title="五、Markdown 工具"></a>五、Markdown 工具</h2><hr><ul><li>本地 APP：首推 Typora，当然还有其他一些好用的软件，我用的是 Typora；</li><li>国内博客平台：CSDN、简书、掘金、博客园、知乎等。<br>Typora 下载链接：<a href="http://www.itmind.net/20343.html">Typora 下载</a></li></ul><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><hr><p>为什么要写这篇博客，不仅是为了分享我的学习过程，也是为了给自己记个笔记，哪里忘记了，回来再看一眼，也可以很快的回想起来。所以快快把 Markdown 语法学起来吧，一起加油！！！</p><ol><li><p>Markdown 是一种纯文本标记语言 <a href="#fnref1">↩︎</a></p></li><li><p>HyperText Markup Language 超文本标记语言 <a href="#fnref2">↩︎</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序设计Debug作业</title>
    <link href="/2024/11/24/Debug_Homework/"/>
    <url>/2024/11/24/Debug_Homework/</url>
    
    <content type="html"><![CDATA[<h2 id="SuH4x">（1）问题描述和错误代码</h2>在本次作业中，错误代码从用户输入读取一个字符，如果这个整数在 0 到 9 之间，就输出对应的英文单词（如输入 5 则输出 “Five”）；如果输入的字符不是 0 到 9 中的数字字符，则输出 “Other”。代码中使用了一个字符串数组来存储数字 0 到 9 对应的英文单词，通过条件判断来确定输出内容。代码的初步实现存在逻辑错误和变量类型错误，导致输出的结果不符合预期。<p>题目要求：</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731144361517-dcb46d7b-ab82-4c9b-a0bc-c8cccfd12d86.png"></p><p>错误代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cin&gt;&gt;i;<br>    string num[]=&#123;<span class="hljs-string">&quot;Zero&quot;</span>,<span class="hljs-string">&quot;One&quot;</span>,<span class="hljs-string">&quot;Two&quot;</span>,<span class="hljs-string">&quot;Three&quot;</span>,<span class="hljs-string">&quot;Four&quot;</span>,<span class="hljs-string">&quot;Five&quot;</span>,<span class="hljs-string">&quot;Six&quot;</span>,<span class="hljs-string">&quot;Seven&quot;</span>,<span class="hljs-string">&quot;Eight&quot;</span>,<span class="hljs-string">&quot;Nine&quot;</span>&#125;;<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>||i&lt;=<span class="hljs-number">9</span>)<br>        cout&lt;&lt;num[i];<br>    <span class="hljs-keyword">else</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Other&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码在实现过程中存在以下几个问题：</p><ol><li>变量类型错误：代码错误的将输入数据存储的变量类型定义为整数（int）而忽略了其他字符输入的可能性。</li><li>条件判断错误：If语句中的逻辑运算错误的使用了或运算（||），从而使得if语句的执行错误。</li><li>比较符号错误：在0到9的条件中，左侧的0错误使用了大于号，使得等于0这一情况被忽略。</li></ol><h2 id="muR5p">（2）通过debug查错纠错</h2>通过调试器设置断点，并在代码运行时监视变量，我们发现了代码中的多个问题。以下是通过debug工具检查错误的步骤：<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143857136-f0b8b82f-800b-4aaf-9cee-40d4cacea113.png"></p><p>在将代码复制到IDE后，IDE对代码提出了一个警告：不可到达的代码：11</p><p>随后我们对If中的条件进行修改（解决问题2和3）</p><p>运行测试之后发现其对于0-9之间的字符输入能够完成符合要求的输出，随后对其他字符测试出现错误输出Zero（预期输出：Other）</p><p>于是我们在第八行打点进行单步调试观察变量数值。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143857386-752e0f81-3110-48ce-bb96-865ec867c395.png"></p><p>在输入0-9的时候，变量i能够正确赋值并执行下一步操作，最后输出符合要求。</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143857621-7b960fa6-19de-44b8-aa60-6c8802996fab.png"></p><p>当输入其他字符（此处为‘a’）时，变量i赋值为0。此时，我们发现由于变量定义为整型（int）所以只能够储存数字，因此我们将其改为字符变量（char），并对代码进行相关调整，进行调试之后发现能够正常赋值。（解决问题1）<img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143857888-7aeb6f81-bf2f-44e0-83cd-50b61e3a5307.png"></p><p>至此，我们完成了对这一段代码的debug任务。我们发现单步调试能帮助开发者通过逐步跟踪代码执行、观察变量变化、设置断点等手段，快速精确定位问题所在，深入理解代码逻辑，高效解决并预防错误，从而提升开发效率和质量。</p><h2 id="cLCK8">（3）通过AI查错纠错</h2>在软件开发和编程的复杂环境中，错误和漏洞的及时发现与修复是确保软件质量和用户体验的关键。传统的代码审查和测试方法虽然有效，但往往受限于人力资源和时间成本。为了应对这一挑战，越来越多的开发者开始引入AI查错技术，利用人工智能的智能化和自动化优势，提升代码审查的效率和准确性。因此，我们使用了几款功能十分强大的Ai来进行同一个项目的纠错。<h4 id="O8uIw">Cursor（依于Claude3.5）</h4>作为目前互联网上近期十分热门的代码大模型，我们对其进行测试。<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143858128-9dd9fbd0-959d-4462-a6f6-b560a2890c4c.png"></p><blockquote><ol><li>原代码中的条件判断 if(i&gt;0||i&lt;&#x3D;9) 是错误的：使用 OR (||) 运算符会导致条件永远为真，因为任何数要么大于0，要么小于等于9。应该使用 AND (&amp;&amp;) 运算符来确保数字在0到9的范围内</li><li>条件判断中还需要包含0：原条件 i&gt;0 排除了0。应改为 i&gt;&#x3D;0 以包含0</li><li>由于题目要求输入的是字符，建议将代码进一步优化为处理字符输入。</li></ol></blockquote><h4 id="V2yEF">Cursor（依于Chatgpt-4o）</h4>![](https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143858344-7a4f92a6-f753-4d7f-adb2-c22face8abce.png)<blockquote><p><strong>输入类型</strong>：原代码中使用了int i来接收输入，但题目要求输入一个字符，因此应使用char ch。</p><p><strong>条件判断</strong>：原代码中的条件if(i&gt;0||i&lt;&#x3D;9)逻辑不正确。应检查字符是否在’0’到’9’之间，即if (ch &gt;&#x3D; ‘0’ &amp;&amp; ch &lt;&#x3D; ‘9’)。</p><p><strong>数组索引</strong>：在输出数字对应的英文单词时，使用num[ch - ‘0’]来将字符转换为对应的整数索引。</p></blockquote><p>相同的是，两款语言模型在cursor的环境之下已经能够完成对这一段代码的错误分析，并作出改正。</p><h4 id="RspLe">通义灵码</h4>作为阿里巴巴专为编程开发的大模型工具，我们使用相同题目进行测试。![](https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143858585-4decc06a-15aa-4a39-9cc2-d560582bfd35.png)<blockquote><p><strong>输入类型错误：</strong>当前代码中，i 被定义为 int 类型，而题目要求输入的是一个字符。因此，应该将 i 改为 char 类型。</p><p><strong>条件判断错误：</strong>当前的条件判断 if(i&gt;0||i&lt;&#x3D;9) 是不正确的。应该检查输入的字符是否在 ‘0’ 到 ‘9’ 之间。</p><p><strong>数组索引计算：</strong>输入的字符需要转换为对应的整数索引，才能正确访问 num 数组。可以使用 i - ‘0’ 来实现这一点。</p><p><strong>代码优化：</strong>可以使用 switch 语句来简化代码，但这里我们保持使用 if 语句。</p></blockquote><h4 id="wkLVe">豆包MarsCode</h4>字节跳动也对编程开发了大模型MarsCode，我们采用同样的测试方式。<p><img src="https://cdn.nlark.com/yuque/0/2024/png/12641858/1731143858811-7be39f35-154c-4dc0-bc75-a4b21df1fb7d.png"></p><blockquote><p>主要问题出现在条件判断语句 if(i&gt;0||i&lt;&#x3D;9) 上。这个条件判断语句并没有正确地涵盖所有可能的数字字符范围。</p><p>此外，在输出时直接使用了整数 i 作为数组的索引，这可能会导致运行时错误。</p></blockquote><h2 id="EPFus">（4）错误原因及修改方案总结</h2><h3 id="i1Tgx">错误原因：</h3>1. 变量类型错误：代码错误的将输入数据存储的变量类型定义为整数（int）而忽略了其他字符输入的可能性。2. 条件判断错误：If语句中的逻辑运算错误的使用了或运算（||），从而使得if语句的执行错误。3. 比较符号错误：在0到9的条件中，左侧的0错误使用了大于号，使得等于0这一情况被忽略。<h3 id="kZJxE">修改方案：</h3>1. 更换变量类型（int）为字符型（char）2. 将或运算（||）改为与运算（&&）3. 将大于（>）改为大于等于(>=)<p>修改后代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> i;<br>    cin&gt;&gt;i;<br>    string num[]=&#123;<span class="hljs-string">&quot;Zero&quot;</span>,<span class="hljs-string">&quot;One&quot;</span>,<span class="hljs-string">&quot;Two&quot;</span>,<span class="hljs-string">&quot;Three&quot;</span>,<span class="hljs-string">&quot;Four&quot;</span>,<span class="hljs-string">&quot;Five&quot;</span>,<span class="hljs-string">&quot;Six&quot;</span>,<span class="hljs-string">&quot;Seven&quot;</span>,<span class="hljs-string">&quot;Eight&quot;</span>,<span class="hljs-string">&quot;Nine&quot;</span>&#125;;<br>    <span class="hljs-keyword">if</span>(i&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;i&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>        cout&lt;&lt;num[i -<span class="hljs-string">&#x27;0&#x27;</span>];<br>    <span class="hljs-keyword">else</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;Other&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WhO8N">(5)两种方案比较</h2><h3 id="lL1Gy">1.通过编译器和单步调试进行debug操作</h3>编译器能够初步对一些简单的逻辑问题和语法问题进行指出，可以一定程度上减少代码出现问题<p>在使用单步调试的时候，我们能够清楚直观了解到变量的变化情况，以及相关运算过程，来确定运算期间出现的错误，从而定位错误点然后做出改正。</p><h3 id="DTZAX">2.使用ai来进行查错纠错</h3>AI能够快速且准确地扫描和分析大量代码，识别出潜在的错误和漏洞，从而显著提高查错效率，减少开发人员的等待时间。同时，借助先进的机器学习和深度学习技术，AI能够更深入地理解和分析代码的语法、语义和逻辑结构，进一步增强查错的准确性，减少误报和漏报的情况。<p>此外，AI还能根据错误类型和上下文信息，提供智能化的修复建议，帮助开发人员更快地定位和解决问题，降低手动修复的时间和成本。通过将AI查错集成到开发流程中，可以实现自动化的代码审查和测试，优化开发流程，提高整体开发效率。最重要的是，AI查错有助于开发人员编写出更高质量、更可靠、更安全的代码，降低人力成本，使开发人员能够将更多的时间和精力投入到创新和优化工作中。</p><h3 id="w7Br4">3.两者进行比较</h3><table><thead><tr><th>项目</th><th>AI纠错</th><th>人工纠错</th></tr></thead><tbody><tr><td>速度</td><td>通常速度较快，能够在几秒钟内分析代码并提供建议。适合快速发现常见错误。</td><td>速度较慢，尤其是在复杂问题上，需要逐步分析和测试代码。</td></tr><tr><td>准确性</td><td>在常见错误和模式识别上准确性较高，但在复杂逻辑或特定业务场景下可能不如人工。</td><td>准确性依赖于开发者的经验和对代码的理解，通常在复杂问题上更具优势。</td></tr><tr><td>学习和适应能力</td><td>可以通过训练数据不断提高，但需要大量数据和时间来适应新技术或语言。</td><td>开发者可以通过学习和经验积累快速适应新技术和语言。</td></tr><tr><td>成本</td><td>初始成本可能较高（如购买或订阅AI工具），但长期使用成本较低。</td><td>需要投入人力成本，尤其是在复杂项目中。</td></tr><tr><td>用户体验</td><td>提供即时反馈，用户体验较好，但可能缺乏详细解释。</td><td>提供详细的分析和解释，但需要更多时间和精力。</td></tr><tr><td>复杂问题处理</td><td>在处理简单和中等复杂度的问题时表现良好，但在复杂问题上可能力不从心。</td><td>能够深入理解和解决复杂问题，特别是在涉及业务逻辑的情况下。</td></tr><tr><td>创新和创造力</td><td>主要依赖于已有的数据和模式，创新能力有限。</td><td>开发者可以通过创造性思维找到新的解决方案。</td></tr></tbody></table><p>综上所述，AI纠错和人工debug各有优劣，通常可以结合使用以达到最佳效果。AI可以用于快速识别和修复常见问题，而人工debug则适合处理复杂和特定的问题。</p>]]></content>
    
    
    <categories>
      
      <category>程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
